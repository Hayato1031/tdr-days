This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
assets/
  AppIcons/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
src/
  components/
    charts/
      BarChart.tsx
      HeatMap.tsx
      index.ts
      LineChart.tsx
      PieChart.tsx
      SimplePieChart.tsx
      StatsCard.tsx
      TopRankingList.tsx
    layouts/
      GridLayout.tsx
      index.ts
      ResponsiveContainer.tsx
      SidebarLayout.tsx
      TabletNavigation.tsx
    AboutAppModal.tsx
    ActionDetailModal.tsx
    ActionModal_old.tsx
    ActionModal.tsx
    AreaPicker.tsx
    CalendarPicker.tsx
    CategoryForm.tsx
    CompanionManager.tsx
    DrawerMenu.tsx
    Header.tsx
    HelpSupportModal.tsx
    LocationSelector_old.tsx
    LocationSelector.tsx
    ParkSelector.tsx
    PhotoEditor.tsx
    PhotoGallery.tsx
    PhotoGridView.tsx
    PhotoManager_old.tsx
    PhotoManager.tsx
    PhotoPreview.tsx
    ProfileEditModal.tsx
    ProfileSetupModal.tsx
    SearchableList.tsx
    SwipeableScreen.tsx
    TermsOfServiceModal.tsx
    ThemeCustomizer.tsx
    TimelineAction.tsx
    ValidationFeedback.tsx
    VisitCard.tsx
    VisitFilter.tsx
  constants/
    icons.ts
    index.ts
    presets.ts
  contexts/
    LanguageContext.tsx
    ThemeContext.tsx
  hooks/
    useActions.ts
    useResponsive.ts
    useVisits.ts
  mocks/
    expo-screen-capture-mock.js
  navigation/
    AppNavigator.tsx
    index.ts
    TabNavigator.tsx
  screens/
    AnalyticsScreen.tsx
    HomeScreen.tsx
    index.ts
    ProfileScreen.tsx
    RecordScreen.tsx
    VisitDetailScreen.tsx
    VisitListScreen.tsx
  services/
    photoService.ts
    profileService.ts
    storage.ts
  styles/
    colors.ts
    designStyles.ts.backup
    index.ts
    theme.ts
    typography.ts
  types/
    models.ts
  utils/
    responsive.ts
    validation.ts
.gitignore
app.json
App.tsx
babel.config.js
eas.json
index.js
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "mcp__ide__getDiagnostics",
      "Bash(npx tsc:*)",
      "Bash(rg:*)",
      "Bash(grep:*)",
      "Bash(npm install:*)",
      "Bash(rm:*)",
      "Bash(mv:*)",
      "Bash(npm run lint)"
    ],
    "deny": []
  }
}
</file>

<file path="assets/AppIcons/Assets.xcassets/AppIcon.appiconset/Contents.json">
{"images":[]}
</file>

<file path="src/components/AboutAppModal.tsx">
import React, { useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Animated,
  ScrollView,
  Linking,
  Alert,
  Image,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';

interface AboutAppModalProps {
  visible: boolean;
  onClose: () => void;
}

export const AboutAppModal: React.FC<AboutAppModalProps> = ({
  visible,
  onClose,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 100,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      fadeAnim.setValue(0);
      scaleAnim.setValue(0.8);
    }
  }, [visible]);

  const handleLineContact = async () => {
    const lineUrl = 'https://lin.ee/zYjJIxf';
    try {
      const supported = await Linking.canOpenURL(lineUrl);
      if (supported) {
        await Linking.openURL(lineUrl);
      } else {
        Alert.alert(
          language === 'ja' ? 'LINEが見つかりません' : 'LINE Not Found',
          language === 'ja' 
            ? 'LINEアプリがインストールされていないか、このURLを開けません。\n\nURL: https://lin.ee/zYjJIxf'
            : 'LINE app is not installed or cannot open this URL.\n\nURL: https://lin.ee/zYjJIxf'
        );
      }
    } catch (error) {
      console.error('Error opening LINE URL:', error);
      Alert.alert(
        language === 'ja' ? 'エラー' : 'Error',
        language === 'ja' ? 'LINEを開くことができませんでした。' : 'Could not open LINE.'
      );
    }
  };

  if (!visible) return null;

  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      statusBarTranslucent
    >
      <View style={styles.overlay}>
        <BlurView intensity={80} style={StyleSheet.absoluteFill} />
        
        <Animated.View
          style={[
            styles.container,
            {
              opacity: fadeAnim,
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <LinearGradient
            colors={[
              theme.colors.background.elevated,
              theme.colors.background.card,
            ]}
            style={styles.content}
          >
            {/* Header */}
            <View style={styles.header}>
              <Text style={[styles.title, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? 'アプリについて' : 'About App'}
              </Text>
              <TouchableOpacity onPress={onClose} style={styles.closeButton}>
                <Ionicons name="close" size={24} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            </View>

            <ScrollView showsVerticalScrollIndicator={false}>
              {/* App Logo & Info */}
              <View style={styles.section}>
                <View style={styles.logoContainer}>
                  <View style={styles.logoIcon}>
                    <Image 
                      source={require('../../assets/icon.png')} 
                      style={styles.logoImage}
                      resizeMode="contain"
                    />
                  </View>
                  <Text style={[styles.appName, { color: theme.colors.text.primary }]}>
                    TDR Days
                  </Text>
                  <Text style={[styles.appTagline, { color: theme.colors.text.secondary }]}>
                    {language === 'ja' ? '東京ディズニーリゾート来園記録アプリ' : 'Tokyo Disney Resort Visit Recorder'}
                  </Text>
                </View>
              </View>

              {/* App Description */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'アプリの概要' : 'App Overview'}
                </Text>
                <Text style={[styles.description, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' 
                    ? 'TDR Daysは、東京ディズニーランド・ディズニーシーへの来園記録を美しく記録できるアプリです。アトラクション、レストラン、ショー、グリーティングなどの体験を写真と共に記録し、統計やグラフで来園データを分析できます。'
                    : 'TDR Days is an app that beautifully records your visits to Tokyo Disneyland and Disney Sea. Record attractions, restaurants, shows, character greetings and other experiences with photos, and analyze your visit data with statistics and charts.'
                  }
                </Text>
              </View>

              {/* Features */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? '主な機能' : 'Key Features'}
                </Text>
                <View style={styles.featuresList}>
                  <View style={styles.featureItem}>
                    <Ionicons name="calendar" size={20} color={colors.purple.bright} />
                    <Text style={[styles.featureText, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? '来園記録の作成・管理' : 'Create & manage visit records'}
                    </Text>
                  </View>
                  <View style={styles.featureItem}>
                    <Ionicons name="location" size={20} color={colors.blue[500]} />
                    <Text style={[styles.featureText, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? 'アトラクション・レストラン記録' : 'Track attractions & restaurants'}
                    </Text>
                  </View>
                  <View style={styles.featureItem}>
                    <Ionicons name="camera" size={20} color={colors.green[500]} />
                    <Text style={[styles.featureText, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? '写真付きタイムライン' : 'Photo timeline'}
                    </Text>
                  </View>
                  <View style={styles.featureItem}>
                    <Ionicons name="stats-chart" size={20} color={colors.orange[500]} />
                    <Text style={[styles.featureText, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? '統計・分析機能' : 'Statistics & analytics'}
                    </Text>
                  </View>
                  <View style={styles.featureItem}>
                    <Ionicons name="people" size={20} color={colors.pink[500]} />
                    <Text style={[styles.featureText, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? '同行者管理' : 'Companion management'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* App Details */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'アプリ情報' : 'App Information'}
                </Text>
                <View style={[styles.detailsCard, { backgroundColor: theme.colors.background.secondary }]}>
                  <View style={styles.detailRow}>
                    <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? 'アプリ名' : 'App Name'}
                    </Text>
                    <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                      TDR Days
                    </Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? 'バージョン' : 'Version'}
                    </Text>
                    <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                      1.0.0
                    </Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? '開発者' : 'Developer'}
                    </Text>
                    <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                      TDR Days Team
                    </Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                      {language === 'ja' ? 'プライバシー' : 'Privacy'}
                    </Text>
                    <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                      {language === 'ja' ? 'ローカル保存のみ' : 'Local storage only'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Contact */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'お問い合わせ' : 'Contact'}
                </Text>
                <TouchableOpacity
                  style={[styles.contactButton, { backgroundColor: colors.green[500] }]}
                  onPress={handleLineContact}
                  activeOpacity={0.8}
                >
                  <Ionicons name="chatbubble-ellipses" size={20} color="white" />
                  <Text style={styles.contactButtonText}>
                    {language === 'ja' ? 'LINEでお問い合わせ' : 'Contact via LINE'}
                  </Text>
                  <Ionicons name="open-outline" size={16} color="white" />
                </TouchableOpacity>
              </View>

              {/* Copyright */}
              <View style={styles.section}>
                <Text style={[styles.copyright, { color: theme.colors.text.disabled }]}>
                  © 2024 TDR Days Team
                </Text>
                <Text style={[styles.copyright, { color: theme.colors.text.disabled }]}>
                  Made with ❤️ for Disney fans
                </Text>
              </View>

              {/* Bottom spacing */}
              <View style={{ height: 40 }} />
            </ScrollView>
          </LinearGradient>
        </Animated.View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  container: {
    width: '95%',
    maxWidth: 500,
    maxHeight: '90%',
  },
  content: {
    borderRadius: 24,
    elevation: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.25,
    shadowRadius: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 24,
    paddingBottom: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
  },
  closeButton: {
    padding: 4,
  },
  section: {
    paddingHorizontal: 24,
    marginBottom: 24,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 8,
  },
  logoIcon: {
    width: 80,
    height: 80,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
    overflow: 'hidden',
  },
  logoImage: {
    width: '100%',
    height: '100%',
  },
  appName: {
    fontSize: 28,
    fontWeight: '700',
    marginBottom: 4,
  },
  appTagline: {
    fontSize: 14,
    textAlign: 'center',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 12,
  },
  description: {
    fontSize: 14,
    lineHeight: 20,
  },
  featuresList: {
    gap: 12,
  },
  featureItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  featureText: {
    fontSize: 14,
    flex: 1,
  },
  detailsCard: {
    borderRadius: 12,
    padding: 16,
  },
  detailRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  detailLabel: {
    fontSize: 14,
  },
  detailValue: {
    fontSize: 14,
    fontWeight: '500',
  },
  contactButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 12,
    gap: 8,
  },
  contactButtonText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  copyright: {
    fontSize: 12,
    textAlign: 'center',
    marginBottom: 4,
  },
});
</file>

<file path="src/components/ActionDetailModal.tsx">
import React, { useState } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Modal,
  Image,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { TimelineAction, ActionCategory } from '../types/models';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';

const { width: screenWidth } = Dimensions.get('window');

interface ActionDetailModalProps {
  visible: boolean;
  onClose: () => void;
  action: TimelineAction | null;
  onEdit?: (action: TimelineAction) => void;
}

export const ActionDetailModal: React.FC<ActionDetailModalProps> = ({
  visible,
  onClose,
  action,
  onEdit,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const [selectedPhotoIndex, setSelectedPhotoIndex] = useState<number | null>(null);

  if (!action) return null;

  const getCategoryIcon = (category: ActionCategory): string => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      default:
        return 'ellipse';
    }
  };

  const getCategoryColor = (category: ActionCategory): string => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return colors.purple[500];
      case ActionCategory.RESTAURANT:
        return colors.orange[500];
      case ActionCategory.SHOW:
        return colors.pink[500];
      case ActionCategory.GREETING:
        return colors.yellow[500];
      case ActionCategory.SHOPPING:
        return colors.green[500];
      default:
        return colors.gray[500];
    }
  };

  const getCategoryName = (category: ActionCategory): string => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return language === 'ja' ? 'アトラクション' : 'Attraction';
      case ActionCategory.RESTAURANT:
        return language === 'ja' ? 'レストラン' : 'Restaurant';
      case ActionCategory.SHOW:
        return language === 'ja' ? 'ショー' : 'Show';
      case ActionCategory.GREETING:
        return language === 'ja' ? 'グリーティング' : 'Character Greeting';
      case ActionCategory.SHOPPING:
        return language === 'ja' ? 'ショッピング' : 'Shopping';
      default:
        return language === 'ja' ? 'その他' : 'Other';
    }
  };

  const formatTime = (date: Date): string => {
    return new Date(date).toLocaleTimeString(language === 'ja' ? 'ja-JP' : 'en-US', { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
  };


  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
      onRequestClose={onClose}
    >
      <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
        {/* Header */}
        <LinearGradient
          colors={[
            getCategoryColor(action.category) + '20',
            getCategoryColor(action.category) + '10',
          ]}
          style={styles.header}
        >
          <View style={styles.headerContent}>
            <TouchableOpacity
              onPress={onClose}
              style={styles.closeButton}
            >
              <Ionicons name="close" size={24} color={theme.colors.text.primary} />
            </TouchableOpacity>
            
            <View style={styles.headerInfo}>
              <View style={[styles.categoryIcon, { backgroundColor: getCategoryColor(action.category) }]}>
                <Ionicons 
                  name={getCategoryIcon(action.category) as any} 
                  size={24} 
                  color="white" 
                />
              </View>
              <View style={styles.headerText}>
                <Text style={[styles.locationName, { color: theme.colors.text.primary }]}>
                  {action.locationName}
                </Text>
                <Text style={[styles.categoryText, { color: theme.colors.text.secondary }]}>
                  {getCategoryName(action.category)} • {action.area}
                </Text>
                <Text style={[styles.timeText, { color: theme.colors.text.secondary }]}>
                  {formatTime(action.time)}
                </Text>
              </View>
            </View>

            <TouchableOpacity
              onPress={() => onEdit?.(action)}
              style={styles.editButton}
            >
              <Ionicons name="pencil" size={20} color={theme.colors.text.primary} />
            </TouchableOpacity>
          </View>
        </LinearGradient>

        <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
          {/* Details Section */}
          <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? '詳細情報' : 'Details'}
            </Text>
            
            <View style={styles.detailsGrid}>
              <View style={styles.detailItem}>
                <Ionicons name="time" size={16} color={theme.colors.text.secondary} />
                <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '時刻' : 'Time'}
                </Text>
                <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                  {formatTime(action.time)}
                </Text>
              </View>

              <View style={styles.detailItem}>
                <Ionicons name="location" size={16} color={theme.colors.text.secondary} />
                <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? 'エリア' : 'Area'}
                </Text>
                <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                  {action.area}
                </Text>
              </View>

              {/* Attraction specific details */}
              {action.category === ActionCategory.ATTRACTION && (
                <>
                  {action.waitTime && (
                    <View style={styles.detailItem}>
                      <Ionicons name="hourglass" size={16} color={theme.colors.text.secondary} />
                      <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                        {language === 'ja' ? '待ち時間' : 'Wait Time'}
                      </Text>
                      <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                        {language === 'ja' ? `${action.waitTime}分` : `${action.waitTime}min`}
                      </Text>
                    </View>
                  )}
                  
                  {action.duration && (
                    <View style={styles.detailItem}>
                      <Ionicons name="stopwatch" size={16} color={theme.colors.text.secondary} />
                      <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                        {language === 'ja' ? '体験時間' : 'Duration'}
                      </Text>
                      <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                        {language === 'ja' ? `${action.duration}分` : `${action.duration}min`}
                      </Text>
                    </View>
                  )}
                </>
              )}
            </View>

          </View>

          {/* Notes Section */}
          {action.notes && (
            <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? 'メモ' : 'Notes'}
              </Text>
              <Text style={[styles.notesText, { color: theme.colors.text.primary }]}>
                {action.notes}
              </Text>
            </View>
          )}

          {/* Photos Section */}
          {action.photos.length > 0 && (
            <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                {language === 'ja' 
                  ? `写真 (${action.photos.length}枚)` 
                  : `Photos (${action.photos.length})`
                }
              </Text>
              
              <ScrollView 
                horizontal 
                showsHorizontalScrollIndicator={false}
                style={styles.photosContainer}
                contentContainerStyle={styles.photosContent}
              >
                {action.photos.map((photo, index) => (
                  <TouchableOpacity
                    key={photo.id}
                    style={styles.photoItem}
                    onPress={() => setSelectedPhotoIndex(index)}
                  >
                    <Image source={{ uri: photo.uri }} style={styles.photo} />
                  </TouchableOpacity>
                ))}
              </ScrollView>
            </View>
          )}
        </ScrollView>

        {/* Photo Full Screen Modal */}
        {selectedPhotoIndex !== null && (
          <Modal
            visible={true}
            animationType="fade"
            onRequestClose={() => setSelectedPhotoIndex(null)}
          >
            <View style={styles.photoModal}>
              <TouchableOpacity
                style={styles.photoModalClose}
                onPress={() => setSelectedPhotoIndex(null)}
              >
                <Ionicons name="close" size={24} color="white" />
              </TouchableOpacity>
              
              <ScrollView
                horizontal
                pagingEnabled
                showsHorizontalScrollIndicator={false}
                contentOffset={{ x: selectedPhotoIndex * screenWidth, y: 0 }}
              >
                {action.photos.map((photo, index) => (
                  <View key={photo.id} style={styles.photoModalItem}>
                    <Image 
                      source={{ uri: photo.uri }} 
                      style={styles.photoModalImage} 
                      resizeMode="contain"
                    />
                  </View>
                ))}
              </ScrollView>
              
              <View style={styles.photoCounter}>
                <Text style={styles.photoCounterText}>
                  {(selectedPhotoIndex || 0) + 1} / {action.photos.length}
                </Text>
              </View>
            </View>
          </Modal>
        )}
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    paddingTop: spacing[8],
    paddingBottom: spacing[4],
    paddingHorizontal: spacing[4],
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  closeButton: {
    padding: spacing[2],
    marginRight: spacing[2],
  },
  headerInfo: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
  },
  categoryIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: spacing[3],
  },
  headerText: {
    flex: 1,
  },
  locationName: {
    fontSize: 20,
    fontWeight: '700',
    marginBottom: spacing[1],
  },
  categoryText: {
    fontSize: 14,
    marginBottom: spacing[1],
  },
  timeText: {
    fontSize: 14,
    fontWeight: '500',
  },
  editButton: {
    padding: spacing[2],
    marginLeft: spacing[2],
  },
  content: {
    flex: 1,
  },
  section: {
    margin: spacing[4],
    borderRadius: borderRadius.lg,
    padding: spacing[4],
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: spacing[3],
  },
  detailsGrid: {
    gap: spacing[3],
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  detailLabel: {
    fontSize: 14,
    marginLeft: spacing[2],
    minWidth: 80,
  },
  detailValue: {
    fontSize: 14,
    fontWeight: '500',
    flex: 1,
    marginLeft: spacing[2],
  },
  notesText: {
    fontSize: 14,
    lineHeight: 20,
  },
  photosContainer: {
    marginTop: spacing[2],
  },
  photosContent: {
    paddingRight: spacing[2],
  },
  photoItem: {
    marginRight: spacing[2],
  },
  photo: {
    width: 120,
    height: 120,
    borderRadius: borderRadius.md,
  },
  photoModal: {
    flex: 1,
    backgroundColor: 'black',
    justifyContent: 'center',
  },
  photoModalClose: {
    position: 'absolute',
    top: 60,
    right: 20,
    zIndex: 1,
    padding: spacing[2],
  },
  photoModalItem: {
    width: screenWidth,
    justifyContent: 'center',
    alignItems: 'center',
  },
  photoModalImage: {
    width: screenWidth,
    height: '80%',
  },
  photoCounter: {
    position: 'absolute',
    bottom: 60,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  photoCounterText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
});
</file>

<file path="src/components/ActionModal_old.tsx">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Modal,
  Alert,
  TextInput,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { useTheme } from '../contexts/ThemeContext';
import { useActions } from '../hooks/useActions';
import { TimelineAction, ActionCategory, ParkType, ParkArea } from '../types/models';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { AreaPicker } from './AreaPicker';
import { LocationSelector } from './LocationSelector';
import { PhotoManager } from './PhotoManager';
import { ValidationFeedback } from './ValidationFeedback';

interface ActionModalProps {
  visible: boolean;
  onClose: () => void;
  visitId: string;
  parkType: ParkType;
  action?: TimelineAction;
  onSave?: (action: TimelineAction) => void;
}

interface FormData {
  category: ActionCategory;
  area: ParkArea | '';
  locationName: string;
  time: Date;
  notes: string;
  photos: string[];
  rating?: 1 | 2 | 3 | 4 | 5;
  waitTime?: number;
  duration?: number;
}

interface FormErrors {
  category?: string;
  area?: string;
  locationName?: string;
  time?: string;
}

const CATEGORY_OPTIONS = [
  { value: ActionCategory.ATTRACTION, label: 'アトラクション', icon: 'rocket' },
  { value: ActionCategory.RESTAURANT, label: 'レストラン', icon: 'restaurant' },
  { value: ActionCategory.SHOW, label: 'ショー/パレード', icon: 'musical-notes' },
  { value: ActionCategory.GREETING, label: 'グリーティング', icon: 'hand-left' },
  { value: ActionCategory.SHOPPING, label: 'ショッピング', icon: 'bag' },
];

export const ActionModal: React.FC<ActionModalProps> = ({
  visible,
  onClose,
  visitId,
  parkType,
  action,
  onSave,
}) => {
  const { theme } = useTheme();
  const { createAction, updateAction } = useActions();
  
  const [formData, setFormData] = useState<FormData>({
    category: ActionCategory.ATTRACTION,
    area: '',
    locationName: '',
    time: new Date(),
    notes: '',
    photos: [],
    rating: undefined,
    waitTime: undefined,
    duration: undefined,
  });
  
  const [errors, setErrors] = useState<FormErrors>({});
  const [isLoading, setIsLoading] = useState(false);
  const [showTimePicker, setShowTimePicker] = useState(false);

  useEffect(() => {
    if (action) {
      setFormData({
        category: action.category,
        area: action.area,
        locationName: action.locationName,
        time: new Date(action.time),
        notes: action.notes || '',
        photos: action.photos.map(p => p.uri),
        rating: action.rating,
        waitTime: action.waitTime,
        duration: action.duration,
      });
    } else {
      setFormData({
        category: ActionCategory.ATTRACTION,
        area: '',
        locationName: '',
        time: new Date(),
        notes: '',
        photos: [],
        rating: undefined,
        waitTime: undefined,
        duration: undefined,
      });
    }
    setErrors({});
  }, [action, visible]);

  // Animation effects
  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(backdropAnimation, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnimation, {
          toValue: 0,
          duration: 400,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(backdropAnimation, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnimation, {
          toValue: height,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible]);

  // Step animation
  useEffect(() => {
    Animated.spring(stepAnimation, {
      toValue: currentStep,
      tension: 100,
      friction: 8,
      useNativeDriver: true,
    }).start();

    // Update progress
    Animated.timing(progressAnimation, {
      toValue: (currentStep + 1) / Object.keys(WizardStep).length * 2,
      duration: 300,
      useNativeDriver: false,
    }).start();
  }, [currentStep]);

  const getCategoryColor = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return colors.purple[500];
      case ActionCategory.RESTAURANT:
        return colors.orange[500];
      case ActionCategory.SHOW:
        return colors.pink[500];
      case ActionCategory.GREETING:
        return colors.yellow[500];
      case ActionCategory.SHOPPING:
        return colors.green[500];
      default:
        return colors.gray[500];
    }
  };

  const getCategoryIcon = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      default:
        return 'calendar';
    }
  };

  // Helper to get current form data in validation format
  const getCurrentFormData = (): Partial<ActionFormData> => ({
    category: selectedCategory,
    area: selectedArea,
    locationName: selectedLocation,
    time: formData.time,
    duration: formData.duration,
    notes: formData.notes,
    rating: formData.rating,
    waitTime: formData.waitTime,
    fastPass: formData.fastPass,
    mealType: formData.mealType,
    reservationMade: formData.reservationMade,
    partySize: formData.partySize,
    purchaseAmount: formData.purchaseAmount,
    purchasedItems: formData.purchasedItems,
    performerNames: formData.performerNames,
    showTime: formData.showTime,
    meetingDuration: formData.meetingDuration,
  });

  const validateCurrentStep = (): ValidationResult => {
    const validation = validateStep(currentStep, getCurrentFormData());
    setCurrentValidation(validation);
    setShowValidation(!validation.isValid || validation.warnings.length > 0);
    return validation;
  };

  const canProceedToNextStep = (): boolean => {
    const validation = validateCurrentStep();
    return validation.isValid;
  };

  const nextStep = () => {
    if (canProceedToNextStep() && currentStep < WizardStep.PHOTOS) {
      setCurrentStep(currentStep + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > WizardStep.CATEGORY) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleSave = async () => {
    // Final validation before saving
    const finalValidation = validateAction(getCurrentFormData(), visitDate);
    
    if (!finalValidation.isValid) {
      setCurrentValidation(finalValidation);
      setShowValidation(true);
      Alert.alert(
        'Validation Error',
        'Please fix the errors before saving:\n\n' + finalValidation.errors.join('\n'),
        [{ text: 'OK' }]
      );
      return;
    }

    // Show warnings if any
    if (finalValidation.warnings.length > 0) {
      Alert.alert(
        'Warning',
        'Please review the following warnings:\n\n' + finalValidation.warnings.join('\n'),
        [
          { text: 'Cancel', style: 'cancel' },
          { text: 'Save Anyway', onPress: () => performSave() }
        ]
      );
      return;
    }

    await performSave();
  };

  const performSave = async () => {
    setIsLoading(true);

    try {
      const actionData: any = {
        visitId,
        category: selectedCategory,
        area: selectedArea!,
        locationName: selectedLocation.trim(),
        time: formData.time,
        notes: formData.notes.trim() || undefined,
        photos: photos,
      };

      // Add optional fields
      if (formData.duration) {
        actionData.duration = parseInt(formData.duration);
      }
      if (formData.rating > 0) {
        actionData.rating = formData.rating as 1 | 2 | 3 | 4 | 5;
      }

      // Category-specific fields
      switch (selectedCategory) {
        case ActionCategory.ATTRACTION:
          if (formData.waitTime) {
            actionData.waitTime = parseInt(formData.waitTime);
          }
          break;

        case ActionCategory.RESTAURANT:
          actionData.mealType = formData.mealType;
          break;

        case ActionCategory.SHOPPING:
          if (formData.purchaseAmount) {
            actionData.purchaseAmount = parseFloat(formData.purchaseAmount);
          }
          if (formData.purchasedItems.trim()) {
            actionData.purchasedItems = formData.purchasedItems
              .split(',')
              .map(item => item.trim())
              .filter(item => item.length > 0);
          }
          break;

        case ActionCategory.SHOW:
        case ActionCategory.GREETING:
          if (formData.performerNames.trim()) {
            actionData.performerNames = formData.performerNames
              .split(',')
              .map(name => name.trim())
              .filter(name => name.length > 0);
          }
          if (formData.showTime.trim()) {
            actionData.showTime = formData.showTime.trim();
          }
          break;
      }

      await onSave(actionData);
      onClose();
    } catch (error) {
      console.error('Error saving action:', error);
      Alert.alert('Error', 'Failed to save action. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleLocationSelect = (locationName: string, preset?: PresetItem) => {
    setSelectedLocation(locationName);
    setSelectedPreset(preset || null);
    
    // Auto-detect area from preset
    if (preset && preset.area !== selectedArea) {
      setSelectedArea(preset.area);
    }
    
    // Re-validate when location changes
    if (currentStep === WizardStep.LOCATION) {
      setTimeout(() => validateCurrentStep(), 100);
    }
  };

  const handleCategorySelect = (category: ActionCategory) => {
    setSelectedCategory(category);
    
    // Re-validate when category changes
    if (currentStep === WizardStep.CATEGORY) {
      setTimeout(() => validateCurrentStep(), 100);
    }
  };

  const handleAreaSelect = (area: ParkArea) => {
    setSelectedArea(area);
    
    // Re-validate when area changes
    if (currentStep === WizardStep.AREA) {
      setTimeout(() => validateCurrentStep(), 100);
    }
  };

  const handleFormDataChange = (newData: Partial<typeof formData>) => {
    setFormData({ ...formData, ...newData });
    
    // Re-validate details step when form data changes
    if (currentStep === WizardStep.DETAILS) {
      setTimeout(() => validateCurrentStep(), 100);
    }
  };

  const renderProgressBar = () => (
    <View style={styles.progressContainer}>
      <Animated.View
        style={[
          styles.progressBar,
          {
            backgroundColor: getCategoryColor(selectedCategory),
            width: progressAnimation.interpolate({
              inputRange: [0, 1],
              outputRange: ['0%', '100%'],
            }),
          },
        ]}
      />
    </View>
  );

  const renderStepIndicator = () => (
    <View style={styles.stepIndicator}>
      <Text style={[styles.stepText, { color: theme.colors.text.secondary }]}>
        Step {currentStep + 1} of {Object.keys(WizardStep).length / 2}
      </Text>
      <Text style={[styles.stepTitle, { color: theme.colors.text.primary }]}>
        {STEP_TITLES[currentStep]}
      </Text>
    </View>
  );

  const renderCategoryStep = () => (
    <View style={styles.stepContent}>
      <Text style={[styles.stepDescription, { color: theme.colors.text.secondary }]}>
        What type of activity did you do?
      </Text>
      
      <View style={styles.categoryGrid}>
        {Object.values(ActionCategory).map(category => (
          <TouchableOpacity
            key={category}
            style={[
              styles.categoryCard,
              {
                backgroundColor: selectedCategory === category
                  ? getCategoryColor(category)
                  : theme.colors.background.elevated,
                borderColor: selectedCategory === category
                  ? getCategoryColor(category)
                  : theme.colors.border,
              },
            ]}
            onPress={() => handleCategorySelect(category)}
          >
            <Ionicons
              name={getCategoryIcon(category) as any}
              size={32}
              color={selectedCategory === category ? 'white' : getCategoryColor(category)}
            />
            <Text
              style={[
                styles.categoryText,
                {
                  color: selectedCategory === category
                    ? 'white'
                    : theme.colors.text.primary,
                },
              ]}
            >
              {category}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );

  const renderAreaStep = () => (
    <AreaPicker
      parkType={parkType}
      selectedArea={selectedArea}
      onSelect={handleAreaSelect}
      style={styles.stepContent}
    />
  );

  const renderLocationStep = () => (
    <LocationSelector
      category={selectedCategory}
      parkType={parkType}
      selectedArea={selectedArea}
      selectedLocation={selectedLocation}
      onLocationSelect={handleLocationSelect}
      style={styles.stepContent}
    />
  );

  const renderDetailsStep = () => (
    <CategoryForm
      category={selectedCategory}
      formData={formData}
      onFormDataChange={handleFormDataChange}
      visitDate={visitDate}
      style={styles.stepContent}
    />
  );

  const renderPhotosStep = () => (
    <View style={styles.stepContent}>
      <PhotoManager
        photos={photos}
        onPhotosChange={setPhotos}
        maxPhotos={10}
      />
    </View>
  );

  const renderStepContent = () => {
    switch (currentStep) {
      case WizardStep.CATEGORY:
        return renderCategoryStep();
      case WizardStep.AREA:
        return renderAreaStep();
      case WizardStep.LOCATION:
        return renderLocationStep();
      case WizardStep.DETAILS:
        return renderDetailsStep();
      case WizardStep.PHOTOS:
        return renderPhotosStep();
      default:
        return null;
    }
  };

  const renderNavigation = () => (
    <View style={styles.navigation}>
      <TouchableOpacity
        style={[
          styles.navButton,
          styles.backButton,
          {
            backgroundColor: theme.colors.background.elevated,
            borderColor: theme.colors.border,
            opacity: currentStep === WizardStep.CATEGORY ? 0.5 : 1,
          },
        ]}
        onPress={prevStep}
        disabled={currentStep === WizardStep.CATEGORY}
      >
        <Ionicons name="chevron-back" size={20} color={theme.colors.text.primary} />
        <Text style={[styles.navButtonText, { color: theme.colors.text.primary }]}>
          Back
        </Text>
      </TouchableOpacity>

      {currentStep === WizardStep.PHOTOS ? (
        <TouchableOpacity
          style={[
            styles.navButton,
            styles.saveButton,
            {
              backgroundColor: getCategoryColor(selectedCategory),
              opacity: isLoading ? 0.6 : 1,
            },
          ]}
          onPress={handleSave}
          disabled={isLoading}
        >
          <Text style={styles.saveButtonText}>
            {isLoading ? 'Saving...' : action ? 'Update' : 'Save'}
          </Text>
          <Ionicons name="checkmark" size={20} color="white" />
        </TouchableOpacity>
      ) : (
        <TouchableOpacity
          style={[
            styles.navButton,
            styles.nextButton,
            {
              backgroundColor: getCategoryColor(selectedCategory),
              opacity: canProceedToNextStep() ? 1 : 0.5,
            },
          ]}
          onPress={nextStep}
          disabled={!canProceedToNextStep()}
        >
          <Text style={styles.nextButtonText}>Next</Text>
          <Ionicons name="chevron-forward" size={20} color="white" />
        </TouchableOpacity>
      )}
    </View>
  );

  if (!visible) return null;

  return (
    <Modal
      transparent
      visible={visible}
      onRequestClose={onClose}
      animationType="none"
    >
      <Animated.View
        style={[
          styles.backdrop,
          {
            opacity: backdropAnimation,
          },
        ]}
      >
        <TouchableOpacity
          style={StyleSheet.absoluteFill}
          onPress={onClose}
          activeOpacity={1}
        />
      </Animated.View>

      <Animated.View
        style={[
          styles.container,
          {
            transform: [{ translateY: slideAnimation }],
          },
        ]}
      >
        <BlurView
          intensity={isDark ? 20 : 80}
          style={[
            styles.modal,
            {
              backgroundColor: isDark
                ? 'rgba(0, 0, 0, 0.85)'
                : 'rgba(255, 255, 255, 0.95)',
            },
          ]}
        >
          <KeyboardAvoidingView
            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
            style={styles.keyboardView}
          >
            {/* Header */}
            <View style={styles.header}>
              <View style={styles.headerContent}>
                <TouchableOpacity onPress={onClose} style={styles.closeButton}>
                  <Ionicons name="close" size={24} color={theme.colors.text.secondary} />
                </TouchableOpacity>
                
                <View style={styles.headerTitle}>
                  <Text style={[styles.title, { color: theme.colors.text.primary }]}>
                    {action ? 'Edit Action' : 'New Action'}
                  </Text>
                  {renderStepIndicator()}
                </View>

                <View style={styles.headerSpacer} />
              </View>
              
              {renderProgressBar()}
            </View>

            {/* Content */}
            <Animated.View
              style={[
                styles.content,
                {
                  transform: [
                    {
                      translateX: stepAnimation.interpolate({
                        inputRange: [0, 1, 2, 3, 4],
                        outputRange: [0, -width, -width * 2, -width * 3, -width * 4],
                      }),
                    },
                  ],
                },
              ]}
            >
              <View style={[styles.step, { width }]}>
                {/* Validation Feedback */}
                {showValidation && currentValidation && (
                  <ValidationFeedback
                    validation={currentValidation}
                    onDismiss={() => setShowValidation(false)}
                    style={styles.validationFeedback}
                  />
                )}
                
                {renderStepContent()}
              </View>
            </Animated.View>

            {/* Navigation */}
            {renderNavigation()}
          </KeyboardAvoidingView>
        </BlurView>
      </Animated.View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  backdrop: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  container: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'flex-end',
  },
  modal: {
    borderTopLeftRadius: borderRadius['3xl'],
    borderTopRightRadius: borderRadius['3xl'],
    maxHeight: height * 0.92,
    borderWidth: 1,
    borderBottomWidth: 0,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  keyboardView: {
    flex: 1,
  },
  header: {
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
    paddingBottom: spacing[3],
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[5],
    paddingTop: spacing[5],
    paddingBottom: spacing[3],
  },
  closeButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    flex: 1,
    alignItems: 'center',
  },
  title: {
    fontSize: 20,
    fontWeight: '700',
  },
  headerSpacer: {
    width: 40,
  },
  progressContainer: {
    height: 3,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginHorizontal: spacing[5],
  },
  progressBar: {
    height: '100%',
    borderRadius: 2,
  },
  stepIndicator: {
    alignItems: 'center',
    marginTop: spacing[2],
  },
  stepText: {
    fontSize: 12,
    fontWeight: '500',
  },
  stepTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginTop: spacing[1],
  },
  content: {
    flex: 1,
    flexDirection: 'row',
  },
  step: {
    flex: 1,
  },
  stepContent: {
    flex: 1,
    padding: spacing[5],
  },
  stepDescription: {
    fontSize: 16,
    fontWeight: '500',
    textAlign: 'center',
    marginBottom: spacing[6],
    lineHeight: 24,
  },
  categoryGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  categoryCard: {
    width: '48%',
    aspectRatio: 1.2,
    borderRadius: borderRadius.xl,
    borderWidth: 2,
    padding: spacing[4],
    marginBottom: spacing[3],
    justifyContent: 'center',
    alignItems: 'center',
  },
  categoryText: {
    fontSize: 14,
    fontWeight: '700',
    marginTop: spacing[2],
    textAlign: 'center',
    textTransform: 'capitalize',
  },
  navigation: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: spacing[5],
    paddingTop: spacing[3],
  },
  navButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
    borderRadius: borderRadius.lg,
    minWidth: 100,
    justifyContent: 'center',
  },
  backButton: {
    borderWidth: 1,
  },
  navButtonText: {
    fontSize: 16,
    fontWeight: '600',
    marginRight: spacing[1],
  },
  nextButton: {
    backgroundColor: colors.purple[500],
  },
  nextButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
    marginRight: spacing[1],
  },
  saveButton: {},
  saveButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
    marginRight: spacing[1],
  },
  validationFeedback: {
    marginHorizontal: spacing[4],
    marginBottom: spacing[2],
  },
});
</file>

<file path="src/components/HelpSupportModal.tsx">
import React, { useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Animated,
  ScrollView,
  Linking,
  Alert,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';

interface HelpSupportModalProps {
  visible: boolean;
  onClose: () => void;
}


export const HelpSupportModal: React.FC<HelpSupportModalProps> = ({
  visible,
  onClose,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 100,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      fadeAnim.setValue(0);
      scaleAnim.setValue(0.8);
    }
  }, [visible]);

  const handleLineSupport = async () => {
    const lineUrl = 'https://lin.ee/zYjJIxf';
    try {
      const supported = await Linking.canOpenURL(lineUrl);
      if (supported) {
        await Linking.openURL(lineUrl);
      } else {
        Alert.alert(
          language === 'ja' ? 'LINEが見つかりません' : 'LINE Not Found',
          language === 'ja' 
            ? 'LINEアプリがインストールされていないか、このURLを開けません。\n\nサポートURL: https://lin.ee/zYjJIxf'
            : 'LINE app is not installed or cannot open this URL.\n\nSupport URL: https://lin.ee/zYjJIxf',
          [
            { text: language === 'ja' ? 'キャンセル' : 'Cancel', style: 'cancel' },
            {
              text: language === 'ja' ? 'URLをコピー' : 'Copy URL',
              onPress: () => {
                Alert.alert('URL', 'https://lin.ee/zYjJIxf');
              }
            }
          ]
        );
      }
    } catch (error) {
      console.error('Error opening LINE URL:', error);
      Alert.alert(
        language === 'ja' ? 'エラー' : 'Error',
        language === 'ja' ? 'LINEを開くことができませんでした。' : 'Could not open LINE.'
      );
    }
  };


  const faqItems = language === 'ja' ? [
    {
      question: 'データはどこに保存されますか？',
      answer: 'すべてのデータはお使いのデバイスに安全に保存されます。外部サーバーには送信されません。',
    },
    {
      question: '写真が表示されません',
      answer: 'アプリに写真ライブラリへのアクセス許可を与えているか確認してください。設定 > プライバシー > 写真から確認できます。',
    },
    {
      question: 'データのバックアップは可能ですか？',
      answer: '現在、手動でのデータバックアップ機能は開発中です。データが消失しないよう、アプリを削除しないでください。',
    },
    {
      question: 'アプリが正常に動作しません',
      answer: 'アプリを完全に終了して再起動してみてください。問題が続く場合はサポートまでご連絡ください。',
    },
  ] : [
    {
      question: 'Where is my data stored?',
      answer: 'All data is securely stored on your device. No data is sent to external servers.',
    },
    {
      question: 'Photos are not displaying',
      answer: 'Please check if you have granted photo library access permission to the app. You can check this in Settings > Privacy > Photos.',
    },
    {
      question: 'Is data backup possible?',
      answer: 'Manual data backup functionality is currently under development. Please do not delete the app to prevent data loss.',
    },
    {
      question: 'The app is not working properly',
      answer: 'Please try completely closing and restarting the app. If the problem persists, please contact support.',
    },
  ];

  if (!visible) return null;

  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      statusBarTranslucent
    >
      <View style={styles.overlay}>
        <BlurView intensity={80} style={StyleSheet.absoluteFill} />
        
        <Animated.View
          style={[
            styles.container,
            {
              opacity: fadeAnim,
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <LinearGradient
            colors={[
              theme.colors.background.elevated,
              theme.colors.background.card,
            ]}
            style={styles.content}
          >
            {/* Header */}
            <View style={styles.header}>
              <Text style={[styles.title, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? 'ヘルプ・サポート' : 'Help & Support'}
              </Text>
              <TouchableOpacity onPress={onClose} style={styles.closeButton}>
                <Ionicons name="close" size={24} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            </View>

            <ScrollView showsVerticalScrollIndicator={false}>
              {/* FAQ */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'よくある質問' : 'Frequently Asked Questions'}
                </Text>
                {faqItems.map((faq, index) => (
                  <View
                    key={index}
                    style={[
                      styles.faqItem,
                      { backgroundColor: theme.colors.background.secondary }
                    ]}
                  >
                    <Text style={[styles.faqQuestion, { color: theme.colors.text.primary }]}>
                      Q. {faq.question}
                    </Text>
                    <Text style={[styles.faqAnswer, { color: theme.colors.text.secondary }]}>
                      A. {faq.answer}
                    </Text>
                  </View>
                ))}
              </View>

              {/* Contact Support */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'お困りの場合' : 'Need Help?'}
                </Text>
                <TouchableOpacity
                  style={[styles.supportButton, { backgroundColor: colors.green[500] }]}
                  onPress={handleLineSupport}
                  activeOpacity={0.8}
                >
                  <View style={styles.supportButtonContent}>
                    <Ionicons name="chatbubble-ellipses" size={24} color="white" />
                    <View style={styles.supportButtonText}>
                      <Text style={styles.supportButtonTitle}>
                        {language === 'ja' ? 'LINEでサポートに連絡' : 'Contact Support via LINE'}
                      </Text>
                      <Text style={styles.supportButtonSubtitle}>
                        {language === 'ja' ? '問題の解決をお手伝いします' : 'We will help you solve the problem'}
                      </Text>
                    </View>
                    <Ionicons name="chevron-forward" size={20} color="white" />
                  </View>
                </TouchableOpacity>
              </View>

              {/* App Info */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'アプリ情報' : 'App Information'}
                </Text>
                <View style={[styles.appInfo, { backgroundColor: theme.colors.background.secondary }]}>
                  <View style={styles.appInfoRow}>
                    <Text style={[styles.appInfoLabel, { color: theme.colors.text.secondary }]}>
                      アプリ名
                    </Text>
                    <Text style={[styles.appInfoValue, { color: theme.colors.text.primary }]}>
                      TDR Days
                    </Text>
                  </View>
                  <View style={styles.appInfoRow}>
                    <Text style={[styles.appInfoLabel, { color: theme.colors.text.secondary }]}>
                      バージョン
                    </Text>
                    <Text style={[styles.appInfoValue, { color: theme.colors.text.primary }]}>
                      1.0.0
                    </Text>
                  </View>
                  <View style={styles.appInfoRow}>
                    <Text style={[styles.appInfoLabel, { color: theme.colors.text.secondary }]}>
                      開発者
                    </Text>
                    <Text style={[styles.appInfoValue, { color: theme.colors.text.primary }]}>
                      TDR Days Team
                    </Text>
                  </View>
                </View>
              </View>

              {/* Bottom spacing */}
              <View style={{ height: 40 }} />
            </ScrollView>
          </LinearGradient>
        </Animated.View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  container: {
    width: '95%',
    maxWidth: 500,
    maxHeight: '90%',
  },
  content: {
    borderRadius: 24,
    elevation: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.25,
    shadowRadius: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 24,
    paddingBottom: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
  },
  closeButton: {
    padding: 4,
  },
  section: {
    paddingHorizontal: 24,
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 16,
  },
  faqItem: {
    padding: 16,
    borderRadius: 12,
    marginBottom: 8,
  },
  faqQuestion: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
  },
  faqAnswer: {
    fontSize: 13,
    lineHeight: 18,
  },
  supportButton: {
    borderRadius: 16,
    padding: 16,
  },
  supportButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  supportButtonText: {
    flex: 1,
    marginLeft: 16,
  },
  supportButtonTitle: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 2,
  },
  supportButtonSubtitle: {
    color: 'white',
    fontSize: 13,
    opacity: 0.8,
  },
  appInfo: {
    borderRadius: 12,
    padding: 16,
  },
  appInfoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  appInfoLabel: {
    fontSize: 14,
  },
  appInfoValue: {
    fontSize: 14,
    fontWeight: '500',
  },
});
</file>

<file path="src/components/LocationSelector_old.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Alert,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { ActionCategory, ParkArea, ParkType } from '../types/models';
import { SearchableList } from './SearchableList';
import { 
  PRESET_ATTRACTIONS_BY_AREA,
  PRESET_RESTAURANTS_BY_AREA,
  PRESET_SHOPS_BY_AREA,
  PRESET_GREETING_BY_AREA,
} from '../constants/presets';

interface PresetItem {
  id: string;
  name: string;
  nameEn?: string;
  category: ActionCategory;
  parkType: ParkType;
  area: ParkArea;
  tags?: string[];
  isPopular?: boolean;
  isNew?: boolean;
}

interface LocationSelectorProps {
  category: ActionCategory;
  parkType: ParkType;
  area: ParkArea;
  selectedArea?: ParkArea;
  selectedLocation?: string;
  onLocationSelect: (locationName: string, presetItem?: PresetItem) => void;
  onCustomLocation?: (locationName: string) => void;
  recentLocations?: PresetItem[];
  style?: any;
}

export const LocationSelector: React.FC<LocationSelectorProps> = ({
  category,
  parkType,
  area,
  selectedArea,
  selectedLocation,
  onLocationSelect,
  onCustomLocation,
  recentLocations = [],
  style,
}) => {
  const { theme } = useTheme();
  const [mode, setMode] = useState<'preset' | 'custom'>('preset');
  const [customLocation, setCustomLocation] = useState('');
  const [selectedPreset, setSelectedPreset] = useState<PresetItem | null>(null);
  const slideAnimation = React.useRef(new Animated.Value(0)).current;

  // Get presets for current category and area
  const categoryPresets = useMemo(() => {
    let presetData: Record<string, PresetItem[]> = {};
    
    switch (category) {
      case ActionCategory.ATTRACTION:
        presetData = PRESET_ATTRACTIONS_BY_AREA;
        break;
      case ActionCategory.RESTAURANT:
        presetData = PRESET_RESTAURANTS_BY_AREA;
        break;
      case ActionCategory.SHOPPING:
        presetData = PRESET_SHOPS_BY_AREA;
        break;
      case ActionCategory.GREETING:
        presetData = PRESET_GREETING_BY_AREA;
        break;
      case ActionCategory.SHOW:
        // Shows are typically custom entries
        return [];
      default:
        return [];
    }

    const areaToUse = area || selectedArea;
    if (areaToUse && presetData[areaToUse]) {
      return presetData[areaToUse].filter(item => 
        item.parkType === parkType && item.category === category
      );
    }

    // Return all presets for the category and park if no area selected
    return Object.values(presetData)
      .flat()
      .filter(item => item.parkType === parkType && item.category === category);
  }, [category, parkType, selectedArea]);

  // Popular suggestions based on category
  const popularSuggestions = useMemo(() => {
    return categoryPresets
      .filter(item => item.isPopular)
      .slice(0, 6);
  }, [categoryPresets]);

  // Recent locations filtered by category
  const filteredRecentLocations = useMemo(() => {
    return recentLocations
      .filter(item => item.category === category && item.parkType === parkType)
      .slice(0, 5);
  }, [recentLocations, category, parkType]);

  useEffect(() => {
    Animated.spring(slideAnimation, {
      toValue: mode === 'preset' ? 0 : 1,
      tension: 100,
      friction: 8,
      useNativeDriver: true,
    }).start();
  }, [mode]);

  const getCategoryColor = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return colors.purple[500];
      case ActionCategory.RESTAURANT:
        return colors.orange[500];
      case ActionCategory.SHOW:
        return colors.pink[500];
      case ActionCategory.GREETING:
        return colors.yellow[500];
      case ActionCategory.SHOPPING:
        return colors.green[500];
      default:
        return colors.gray[500];
    }
  };

  const getCategoryIcon = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      default:
        return 'location';
    }
  };

  const formatAreaName = (area: ParkArea): string => {
    return area.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };

  const handlePresetSelect = (item: PresetItem) => {
    setSelectedPreset(item);
    onLocationSelect(item.name, item);
  };

  const handleCustomLocationSubmit = () => {
    if (customLocation.trim()) {
      onLocationSelect(customLocation.trim());
      onCustomLocation?.(customLocation.trim());
      setCustomLocation('');
    } else {
      Alert.alert('Error', 'Please enter a location name');
    }
  };

  const renderModeToggle = () => (
    <View style={styles.modeToggle}>
      <TouchableOpacity
        style={[
          styles.modeButton,
          {
            backgroundColor: mode === 'preset' 
              ? getCategoryColor(category) 
              : theme.colors.background.elevated,
          },
        ]}
        onPress={() => setMode('preset')}
      >
        <Ionicons
          name="list"
          size={16}
          color={mode === 'preset' ? 'white' : theme.colors.text.secondary}
        />
        <Text
          style={[
            styles.modeButtonText,
            {
              color: mode === 'preset' ? 'white' : theme.colors.text.secondary,
            },
          ]}
        >
          Presets
        </Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={[
          styles.modeButton,
          {
            backgroundColor: mode === 'custom' 
              ? getCategoryColor(category) 
              : theme.colors.background.elevated,
          },
        ]}
        onPress={() => setMode('custom')}
      >
        <Ionicons
          name="create"
          size={16}
          color={mode === 'custom' ? 'white' : theme.colors.text.secondary}
        />
        <Text
          style={[
            styles.modeButtonText,
            {
              color: mode === 'custom' ? 'white' : theme.colors.text.secondary,
            },
          ]}
        >
          Custom
        </Text>
      </TouchableOpacity>
    </View>
  );

  const renderPopularSuggestions = () => {
    if (popularSuggestions.length === 0) return null;

    return (
      <View style={styles.suggestionsContainer}>
        <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
          Popular {category.toLowerCase()}s
        </Text>
        <View style={styles.suggestionsList}>
          {popularSuggestions.map((item, index) => (
            <TouchableOpacity
              key={item.id}
              style={[
                styles.suggestionItem,
                {
                  backgroundColor: selectedPreset?.id === item.id
                    ? getCategoryColor(category)
                    : theme.colors.background.elevated,
                  borderColor: selectedPreset?.id === item.id
                    ? getCategoryColor(category)
                    : theme.colors.border,
                },
              ]}
              onPress={() => handlePresetSelect(item)}
            >
              <View style={styles.suggestionContent}>
                <Text
                  style={[
                    styles.suggestionName,
                    {
                      color: selectedPreset?.id === item.id
                        ? 'white'
                        : theme.colors.text.primary,
                    },
                  ]}
                  numberOfLines={2}
                >
                  {item.name}
                </Text>
                <Text
                  style={[
                    styles.suggestionArea,
                    {
                      color: selectedPreset?.id === item.id
                        ? 'rgba(255, 255, 255, 0.8)'
                        : theme.colors.text.secondary,
                    },
                  ]}
                >
                  {formatAreaName(item.area)}
                </Text>
              </View>
              {item.isNew && (
                <View style={[styles.newBadge, { backgroundColor: colors.green[500] }]}>
                  <Text style={styles.newBadgeText}>NEW</Text>
                </View>
              )}
            </TouchableOpacity>
          ))}
        </View>
      </View>
    );
  };

  const renderSelectedLocation = () => {
    if (!selectedLocation) return null;

    return (
      <View style={styles.selectedLocationContainer}>
        <LinearGradient
          colors={[getCategoryColor(category), `${getCategoryColor(category)}80`]}
          style={styles.selectedLocationGradient}
        >
          <View style={styles.selectedLocationContent}>
            <Ionicons
              name={getCategoryIcon(category) as any}
              size={20}
              color="white"
            />
            <View style={styles.selectedLocationText}>
              <Text style={styles.selectedLocationName}>{selectedLocation}</Text>
              {selectedPreset && (
                <Text style={styles.selectedLocationArea}>
                  {formatAreaName(selectedPreset.area)}
                </Text>
              )}
            </View>
          </View>
          <TouchableOpacity
            onPress={() => {
              onLocationSelect('');
              setSelectedPreset(null);
            }}
            style={styles.clearSelectionButton}
          >
            <Ionicons name="close" size={18} color="white" />
          </TouchableOpacity>
        </LinearGradient>
      </View>
    );
  };

  return (
    <View style={[styles.container, style]}>
      <View style={styles.header}>
        <View style={styles.titleContainer}>
          <Ionicons
            name={getCategoryIcon(category) as any}
            size={20}
            color={getCategoryColor(category)}
          />
          <Text style={[styles.title, { color: theme.colors.text.primary }]}>
            Select {category.toLowerCase()} location
          </Text>
        </View>
        {(area || selectedArea) && (
          <Text style={[styles.subtitle, { color: theme.colors.text.secondary }]}>
            in {formatAreaName(area || selectedArea!)}
          </Text>
        )}
      </View>

      {renderModeToggle()}
      {renderSelectedLocation()}

      <Animated.View
        style={[
          styles.contentContainer,
          {
            transform: [
              {
                translateX: slideAnimation.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, -100],
                }),
              },
            ],
          },
        ]}
      >
        {mode === 'preset' ? (
          <View style={styles.presetContent}>
            {renderPopularSuggestions()}
            
            <View style={styles.searchContainer}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                Search all locations
              </Text>
              <SearchableList
                category={category}
                parkType={parkType}
                selectedArea={selectedArea}
                onSelect={handlePresetSelect}
                placeholder={`Search ${category.toLowerCase()}s...`}
                maxResults={15}
                showRecent={true}
                recentItems={filteredRecentLocations}
              />
            </View>
          </View>
        ) : (
          <View style={styles.customContent}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              Enter custom location
            </Text>
            <Text style={[styles.customDescription, { color: theme.colors.text.secondary }]}>
              Can't find your location in the presets? Enter it manually.
            </Text>
            
            <View style={styles.customInputContainer}>
              <View
                style={[
                  styles.customInput,
                  {
                    backgroundColor: theme.colors.background.elevated,
                    borderColor: theme.colors.border,
                  },
                ]}
              >
                <Ionicons
                  name="create-outline"
                  size={20}
                  color={theme.colors.text.secondary}
                  style={styles.customInputIcon}
                />
                <TextInput
                  style={[
                    styles.customInputText,
                    { color: theme.colors.text.primary }
                  ]}
                  value={customLocation}
                  onChangeText={setCustomLocation}
                  placeholder={`Enter ${category.toLowerCase()} name...`}
                  placeholderTextColor={theme.colors.text.tertiary}
                  returnKeyType="done"
                  onSubmitEditing={handleCustomLocationSubmit}
                  autoCapitalize="words"
                />
              </View>
              
              <TouchableOpacity
                style={[
                  styles.customSubmitButton,
                  {
                    backgroundColor: getCategoryColor(category),
                    opacity: customLocation.trim() ? 1 : 0.5,
                  },
                ]}
                onPress={handleCustomLocationSubmit}
                disabled={!customLocation.trim()}
              >
                <Ionicons name="checkmark" size={20} color="white" />
              </TouchableOpacity>
            </View>
          </View>
        )}
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
  },
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    marginLeft: spacing[2],
  },
  subtitle: {
    fontSize: 14,
    fontWeight: '500',
    marginTop: spacing[1],
  },
  modeToggle: {
    flexDirection: 'row',
    margin: spacing[4],
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: borderRadius.lg,
    padding: spacing[1],
  },
  modeButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: spacing[2],
    borderRadius: borderRadius.md,
  },
  modeButtonText: {
    fontSize: 14,
    fontWeight: '600',
    marginLeft: spacing[1],
  },
  selectedLocationContainer: {
    marginHorizontal: spacing[4],
    marginBottom: spacing[3],
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
  },
  selectedLocationGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: spacing[3],
  },
  selectedLocationContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  selectedLocationText: {
    marginLeft: spacing[2],
    flex: 1,
  },
  selectedLocationName: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  selectedLocationArea: {
    color: 'rgba(255, 255, 255, 0.8)',
    fontSize: 12,
    fontWeight: '500',
    marginTop: 2,
  },
  clearSelectionButton: {
    padding: spacing[1],
  },
  contentContainer: {
    flex: 1,
  },
  presetContent: {
    flex: 1,
    paddingHorizontal: spacing[4],
  },
  suggestionsContainer: {
    marginBottom: spacing[4],
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '700',
    marginBottom: spacing[3],
  },
  suggestionsList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -spacing[1],
  },
  suggestionItem: {
    position: 'relative',
    width: '48%',
    marginHorizontal: '1%',
    marginBottom: spacing[2],
    padding: spacing[3],
    borderRadius: borderRadius.lg,
    borderWidth: 1,
  },
  suggestionContent: {
    flex: 1,
  },
  suggestionName: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: spacing[1],
  },
  suggestionArea: {
    fontSize: 11,
    fontWeight: '500',
  },
  newBadge: {
    position: 'absolute',
    top: spacing[1],
    right: spacing[1],
    paddingHorizontal: spacing[1],
    paddingVertical: 2,
    borderRadius: borderRadius.sm,
  },
  newBadgeText: {
    color: 'white',
    fontSize: 9,
    fontWeight: '800',
    letterSpacing: 0.5,
  },
  searchContainer: {
    flex: 1,
  },
  customContent: {
    padding: spacing[4],
  },
  customDescription: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: spacing[4],
    lineHeight: 20,
  },
  customInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  customInput: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderRadius: borderRadius.lg,
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    marginRight: spacing[2],
  },
  customInputIcon: {
    marginRight: spacing[2],
  },
  customInputText: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
  },
  customSubmitButton: {
    padding: spacing[3],
    borderRadius: borderRadius.lg,
  },
});
</file>

<file path="src/components/PhotoManager_old.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  Image,
  StyleSheet,
  Alert,
  Dimensions,
  Modal,
  TextInput,
  Animated,
  Switch,
  LayoutAnimation,
  Platform,
  UIManager,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
// import * as MediaLibrary from 'expo-media-library'; // Removed dependency
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { photoService, PhotoMetadata } from '../services/photoService';
import { PhotoGallery } from './PhotoGallery';
import { PhotoEditor } from './PhotoEditor';
import { PhotoPreview } from './PhotoPreview';
import { PhotoGridView } from './PhotoGridView';

// Enable LayoutAnimation on Android
if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const { width: screenWidth } = Dimensions.get('window');
const PHOTO_SIZE = (screenWidth - spacing[4] * 2 - spacing[2] * 2) / 3;

interface PhotoManagerProps {
  photos: PhotoMetadata[];
  onPhotosChange: (photos: PhotoMetadata[]) => void;
  maxPhotos?: number;
  style?: any;
  enableAdvancedFeatures?: boolean;
  enableBurstMode?: boolean;
  enableAlbums?: boolean;
  enableTags?: boolean;
  defaultAlbum?: string;
}

export const PhotoManager: React.FC<PhotoManagerProps> = ({
  photos,
  onPhotosChange,
  maxPhotos = 10,
  style,
  enableAdvancedFeatures = true,
  enableBurstMode = true,
  enableAlbums = true,
  enableTags = true,
  defaultAlbum = 'General',
}) => {
  const { theme } = useTheme();
  const [selectedPhoto, setSelectedPhoto] = useState<PhotoMetadata | null>(null);
  const [showPhotoModal, setShowPhotoModal] = useState(false);
  const [editingCaption, setEditingCaption] = useState(false);
  const [captionText, setCaptionText] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  // Advanced features state
  const [viewMode, setViewMode] = useState<'compact' | 'grid' | 'timeline'>('compact');
  const [showGallery, setShowGallery] = useState(false);
  const [showEditor, setShowEditor] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [showGridView, setShowGridView] = useState(false);
  const [selectedPhotos, setSelectedPhotos] = useState<PhotoMetadata[]>([]);
  const [selectionMode, setSelectionMode] = useState(false);
  const [burstModeEnabled, setBurstModeEnabled] = useState(false);
  const [currentAlbum, setCurrentAlbum] = useState(defaultAlbum);
  const [currentTags, setCurrentTags] = useState<string[]>([]);
  const [showAlbumPicker, setShowAlbumPicker] = useState(false);
  const [showTagPicker, setShowTagPicker] = useState(false);
  const [albums, setAlbums] = useState<string[]>(['General', 'Favorites', 'TDR Visit']);
  const [availableTags, setAvailableTags] = useState<string[]>(['attraction', 'food', 'parade', 'character', 'landscape', 'selfie']);
  
  const scaleAnimation = useRef(new Animated.Value(1)).current;
  const fadeAnimation = useRef(new Animated.Value(0)).current;

  const requestPermissions = async () => {
    const { status: cameraStatus } = await ImagePicker.requestCameraPermissionsAsync();
    const { status: mediaStatus } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    
    if (cameraStatus !== 'granted' || mediaStatus !== 'granted') {
      Alert.alert(
        'Permissions Required',
        'Please allow camera and photo library access to add photos.',
        [{ text: 'OK' }]
      );
      return false;
    }
    return true;
  };

  const generatePhotoId = () => {
    return photoService.generatePhotoId();
  };

  const addPhoto = async (imageUri: string, width?: number, height?: number) => {
    setIsLoading(true);
    
    try {
      // Compress photo
      const compressedUri = await photoService.compressPhoto(imageUri, {
        quality: 0.8,
        maxWidth: 1920,
        maxHeight: 1920,
      });
      
      // Generate thumbnail
      const thumbnailUri = await photoService.generateThumbnail(compressedUri, 200);
      
      // Get photo info
      const photoInfo = await photoService.getPhotoInfo(compressedUri);
      
      // Extract metadata
      const exifData = await photoService.extractExifData(compressedUri);
      const location = await photoService.extractLocation(compressedUri);
      
      // Auto-categorize
      const autoTags = await photoService.autoCategorizePhoto({
        id: generatePhotoId(),
        uri: compressedUri,
        thumbnailUri,
        width: width || photoInfo.width,
        height: height || photoInfo.height,
        takenAt: new Date(),
        size: photoInfo.size,
        mimeType: 'image/jpeg',
        location,
        exif: exifData,
      });
      
      const newPhoto: PhotoMetadata = {
        id: generatePhotoId(),
        uri: compressedUri,
        thumbnailUri,
        width: width || photoInfo.width,
        height: height || photoInfo.height,
        takenAt: new Date(),
        size: photoInfo.size,
        mimeType: 'image/jpeg',
        album: currentAlbum,
        tags: [...currentTags, ...autoTags],
        location,
        exif: exifData,
      };

      const updatedPhotos = [...photos, newPhoto];
      onPhotosChange(updatedPhotos);
    } catch (error) {
      console.error('Failed to add photo:', error);
      Alert.alert('Error', 'Failed to process photo. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const removePhoto = (photoId: string) => {
    const updatedPhotos = photos.filter(photo => photo.id !== photoId);
    onPhotosChange(updatedPhotos);
  };

  const updatePhotoCaption = (photoId: string, caption: string) => {
    const updatedPhotos = photos.map(photo =>
      photo.id === photoId ? { ...photo, caption } : photo
    );
    onPhotosChange(updatedPhotos);
  };

  const takePhoto = async () => {
    if (photos.length >= maxPhotos) {
      Alert.alert('Photo Limit', `Maximum ${maxPhotos} photos allowed.`);
      return;
    }

    const hasPermissions = await requestPermissions();
    if (!hasPermissions) return;

    setIsLoading(true);

    try {
      if (burstModeEnabled && enableBurstMode) {
        // Burst mode - take multiple photos
        const burstCount = 3;
        const burstPhotos: string[] = [];
        
        for (let i = 0; i < burstCount && photos.length + i < maxPhotos; i++) {
          const result = await ImagePicker.launchCameraAsync({
            mediaTypes: ImagePicker.MediaTypeOptions.Images,
            allowsEditing: false,
            quality: 0.8,
            exif: true,
          });

          if (!result.canceled && result.assets[0]) {
            burstPhotos.push(result.assets[0].uri);
            
            // Small delay between shots
            await new Promise(resolve => setTimeout(resolve, 100));
          } else {
            break;
          }
        }
        
        // Process burst photos
        for (const uri of burstPhotos) {
          await addPhoto(uri);
        }
        
        if (burstPhotos.length > 0) {
          Alert.alert('Burst Mode', `Captured ${burstPhotos.length} photos!`);
        }
      } else {
        // Single photo mode
        const result = await ImagePicker.launchCameraAsync({
          mediaTypes: ImagePicker.MediaTypeOptions.Images,
          allowsEditing: true,
          aspect: [4, 3],
          quality: 0.8,
          exif: true,
        });

        if (!result.canceled && result.assets[0]) {
          const asset = result.assets[0];
          await addPhoto(asset.uri, asset.width, asset.height);
        }
      }
    } catch (error) {
      console.error('Error taking photo:', error);
      Alert.alert('Error', 'Failed to take photo. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const pickFromLibrary = async () => {
    if (photos.length >= maxPhotos) {
      Alert.alert('Photo Limit', `Maximum ${maxPhotos} photos allowed.`);
      return;
    }

    const hasPermissions = await requestPermissions();
    if (!hasPermissions) return;

    setIsLoading(true);

    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
        allowsMultipleSelection: true,
        selectionLimit: Math.min(5, maxPhotos - photos.length),
      });

      if (!result.canceled) {
        for (const asset of result.assets) {
          await addPhoto(asset.uri, asset.width, asset.height);
        }
      }
    } catch (error) {
      console.error('Error picking photos:', error);
      Alert.alert('Error', 'Failed to select photos. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const showPhotoOptions = () => {
    Alert.alert(
      'Add Photo',
      'Choose how you want to add a photo',
      [
        {
          text: 'Camera',
          onPress: takePhoto,
        },
        {
          text: 'Photo Library',
          onPress: pickFromLibrary,
        },
        {
          text: 'Cancel',
          style: 'cancel',
        },
      ]
    );
  };

  // Advanced photo management methods
  const handleBatchDelete = () => {
    Alert.alert(
      'Delete Photos',
      `Delete ${selectedPhotos.length} selected photos?`,
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: () => {
            const remainingPhotos = photos.filter(
              photo => !selectedPhotos.some(selected => selected.id === photo.id)
            );
            onPhotosChange(remainingPhotos);
            setSelectedPhotos([]);
            setSelectionMode(false);
          },
        },
      ]
    );
  };

  const handleBatchEdit = () => {
    if (selectedPhotos.length === 0) return;
    
    // For simplicity, edit the first selected photo
    setSelectedPhoto(selectedPhotos[0]);
    setShowEditor(true);
  };

  const handleBatchShare = async () => {
    // Share functionality for multiple photos
    Alert.alert('Share', `Share ${selectedPhotos.length} photos`);
  };

  const toggleFavorite = (photo: PhotoMetadata) => {
    const updatedPhotos = photos.map(p =>
      p.id === photo.id ? { ...p, isFavorite: !p.isFavorite } : p
    );
    onPhotosChange(updatedPhotos);
  };

  const handlePhotoEdit = (editedPhoto: PhotoMetadata) => {
    const updatedPhotos = photos.map(p =>
      p.id === editedPhoto.id ? editedPhoto : p
    );
    onPhotosChange(updatedPhotos);
  };

  const handlePhotoDelete = (photo: PhotoMetadata) => {
    removePhoto(photo.id);
  };

  const searchPhotos = (query: string) => {
    // Simple search implementation
    return photos.filter(photo => {
      const searchLower = query.toLowerCase();
      return (
        photo.caption?.toLowerCase().includes(searchLower) ||
        photo.tags?.some(tag => tag.toLowerCase().includes(searchLower)) ||
        photo.album?.toLowerCase().includes(searchLower)
      );
    });
  };

  const openPhotoModal = (photo: PhotoMetadata) => {
    setSelectedPhoto(photo);
    setCaptionText(photo.caption || '');
    setShowPhotoModal(true);
    setEditingCaption(false);

    // Animate modal appearance
    Animated.parallel([
      Animated.spring(scaleAnimation, {
        toValue: 1,
        tension: 100,
        friction: 8,
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnimation, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start();
  };

  const closePhotoModal = () => {
    Animated.parallel([
      Animated.spring(scaleAnimation, {
        toValue: 0.8,
        tension: 100,
        friction: 8,
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnimation, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true,
      }),
    ]).start(() => {
      setShowPhotoModal(false);
      setSelectedPhoto(null);
    });
  };

  const saveCaption = () => {
    if (selectedPhoto) {
      updatePhotoCaption(selectedPhoto.id, captionText);
      setEditingCaption(false);
    }
  };

  const deleteSelectedPhoto = () => {
    Alert.alert(
      'Delete Photo',
      'Are you sure you want to delete this photo?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: () => {
            if (selectedPhoto) {
              removePhoto(selectedPhoto.id);
              closePhotoModal();
            }
          },
        },
      ]
    );
  };

  const renderAddPhotoButton = () => {
    if (viewMode === 'grid' || viewMode === 'timeline') {
      return null; // Don't show in grid/timeline view
    }
    
    return (
      <TouchableOpacity
        style={[
          styles.addPhotoButton,
          {
            backgroundColor: theme.colors.background.elevated,
            borderColor: theme.colors.border,
          },
        ]}
        onPress={showPhotoOptions}
        disabled={isLoading || photos.length >= maxPhotos}
      >
        <LinearGradient
          colors={[colors.purple[400], colors.purple[600]]}
          style={styles.addPhotoGradient}
        >
          <Ionicons
            name={isLoading ? "hourglass" : "add"}
            size={24}
            color="white"
          />
          <Text style={styles.addPhotoText}>
            {isLoading ? 'Adding...' : 'Add Photo'}
          </Text>
        </LinearGradient>
      </TouchableOpacity>
    );
  };

  const renderPhoto = (photo: PhotoMetadata, index: number) => {
    const isSelected = selectedPhotos.some(p => p.id === photo.id);
    
    return (
    <TouchableOpacity
      key={photo.id}
      style={styles.photoContainer}
      onPress={() => openPhotoModal(photo)}
      activeOpacity={0.8}
    >
      <Image source={{ uri: photo.uri }} style={styles.photo} />
      
      {/* Photo indicators */}
      <View style={styles.photoIndicators}>
        {photo.isFavorite && (
          <View style={styles.favoriteIndicator}>
            <Ionicons name="heart" size={12} color={colors.semantic.error.light} />
          </View>
        )}
        {photo.caption && (
          <View style={styles.captionIndicator}>
            <Ionicons name="chatbubble" size={12} color="white" />
          </View>
        )}
        {photo.location && (
          <View style={styles.locationIndicator}>
            <Ionicons name="location" size={12} color="white" />
          </View>
        )}
      </View>

      {/* Selection checkbox */}
      {selectionMode && (
        <TouchableOpacity
          style={[
            styles.selectionCheckbox,
            isSelected && styles.selectionCheckboxActive,
          ]}
          onPress={() => {
            if (isSelected) {
              setSelectedPhotos(selectedPhotos.filter(p => p.id !== photo.id));
            } else {
              setSelectedPhotos([...selectedPhotos, photo]);
            }
          }}
        >
          {isSelected && <Ionicons name="checkmark" size={14} color="white" />}
        </TouchableOpacity>
      )}

      {/* Remove button */}
      {!selectionMode && (
        <TouchableOpacity
          style={styles.removeButton}
          onPress={() => removePhoto(photo.id)}
        >
          <Ionicons name="close-circle" size={20} color={colors.red[500]} />
        </TouchableOpacity>
      )}
    </TouchableOpacity>
    );
  };

  const renderPhotoModal = () => {
    if (!selectedPhoto) return null;

    return (
      <Modal
        visible={showPhotoModal}
        transparent
        animationType="none"
        onRequestClose={closePhotoModal}
      >
        <View style={styles.modalBackdrop}>
          <TouchableOpacity
            style={StyleSheet.absoluteFill}
            onPress={closePhotoModal}
            activeOpacity={1}
          />
          
          <Animated.View
            style={[
              styles.modalContainer,
              {
                opacity: fadeAnimation,
                transform: [{ scale: scaleAnimation }],
              },
            ]}
          >
            <BlurView
              intensity={theme.mode === 'dark' ? 20 : 80}
              style={styles.modalContent}
            >
              {/* Header */}
              <View style={styles.modalHeader}>
                <Text style={[styles.modalTitle, { color: theme.colors.text.primary }]}>
                  Photo Details
                </Text>
                <View style={styles.modalActions}>
                  <TouchableOpacity
                    style={styles.modalActionButton}
                    onPress={deleteSelectedPhoto}
                  >
                    <Ionicons name="trash" size={20} color={colors.red[500]} />
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={styles.modalActionButton}
                    onPress={closePhotoModal}
                  >
                    <Ionicons name="close" size={20} color={theme.colors.text.secondary} />
                  </TouchableOpacity>
                </View>
              </View>

              {/* Photo */}
              <View style={styles.modalPhotoContainer}>
                <Image source={{ uri: selectedPhoto.uri }} style={styles.modalPhoto} />
              </View>

              {/* Caption */}
              <View style={styles.captionContainer}>
                <View style={styles.captionHeader}>
                  <Text style={[styles.captionLabel, { color: theme.colors.text.primary }]}>
                    Caption
                  </Text>
                  <TouchableOpacity
                    onPress={() => {
                      if (editingCaption) {
                        saveCaption();
                      } else {
                        setEditingCaption(true);
                      }
                    }}
                    style={styles.editCaptionButton}
                  >
                    <Ionicons
                      name={editingCaption ? "checkmark" : "create"}
                      size={16}
                      color={colors.purple[500]}
                    />
                  </TouchableOpacity>
                </View>

                {editingCaption ? (
                  <TextInput
                    style={[
                      styles.captionInput,
                      {
                        backgroundColor: theme.colors.background.elevated,
                        color: theme.colors.text.primary,
                        borderColor: theme.colors.border,
                      },
                    ]}
                    value={captionText}
                    onChangeText={setCaptionText}
                    placeholder="Add a caption for this photo..."
                    placeholderTextColor={theme.colors.text.tertiary}
                    multiline
                    autoFocus
                  />
                ) : (
                  <Text
                    style={[
                      styles.captionText,
                      { color: theme.colors.text.secondary }
                    ]}
                  >
                    {selectedPhoto.caption || 'No caption added'}
                  </Text>
                )}
              </View>

              {/* Metadata */}
              {selectedPhoto.takenAt && (
                <View style={styles.metadataContainer}>
                  <Ionicons name="time" size={14} color={theme.colors.text.tertiary} />
                  <Text style={[styles.metadataText, { color: theme.colors.text.tertiary }]}>
                    {selectedPhoto.takenAt.toLocaleString()}
                  </Text>
                </View>
              )}
            </BlurView>
          </Animated.View>
        </View>
      </Modal>
    );
  };

  const renderAdvancedHeader = () => (
    <View style={styles.advancedHeader}>
      <View style={styles.headerTop}>
        <Text style={[styles.title, { color: theme.colors.text.primary }]}>
          Photos
        </Text>
        <View style={styles.headerActions}>
          {enableAdvancedFeatures && (
            <>
              <TouchableOpacity
                style={styles.headerButton}
                onPress={() => setShowGridView(true)}
              >
                <MaterialCommunityIcons
                  name="view-grid"
                  size={20}
                  color={theme.colors.text.primary}
                />
              </TouchableOpacity>
              
              <TouchableOpacity
                style={styles.headerButton}
                onPress={() => setSelectionMode(!selectionMode)}
              >
                <Ionicons
                  name={selectionMode ? "checkbox" : "checkbox-outline"}
                  size={20}
                  color={selectionMode ? colors.purple[500] : theme.colors.text.primary}
                />
              </TouchableOpacity>
              
              {enableBurstMode && (
                <TouchableOpacity
                  style={styles.headerButton}
                  onPress={() => setBurstModeEnabled(!burstModeEnabled)}
                >
                  <MaterialCommunityIcons
                    name="camera-burst"
                    size={20}
                    color={burstModeEnabled ? colors.purple[500] : theme.colors.text.primary}
                  />
                </TouchableOpacity>
              )}
            </>
          )}
        </View>
      </View>
      
      <View style={styles.headerInfo}>
        <Text style={[styles.subtitle, { color: theme.colors.text.secondary }]}>
          {photos.length} / {maxPhotos} photos
          {selectionMode && selectedPhotos.length > 0 && ` • ${selectedPhotos.length} selected`}
        </Text>
        
        {enableAlbums && (
          <TouchableOpacity
            style={styles.albumButton}
            onPress={() => setShowAlbumPicker(true)}
          >
            <Ionicons name="folder" size={14} color={theme.colors.text.secondary} />
            <Text style={[styles.albumText, { color: theme.colors.text.secondary }]}>
              {currentAlbum}
            </Text>
          </TouchableOpacity>
        )}
      </View>
      
      {selectionMode && selectedPhotos.length > 0 && (
        <View style={styles.selectionBar}>
          <TouchableOpacity style={styles.selectionButton} onPress={handleBatchEdit}>
            <Ionicons name="create" size={18} color={theme.colors.text.primary} />
            <Text style={[styles.selectionButtonText, { color: theme.colors.text.primary }]}>
              Edit
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity style={styles.selectionButton} onPress={handleBatchShare}>
            <Ionicons name="share" size={18} color={theme.colors.text.primary} />
            <Text style={[styles.selectionButtonText, { color: theme.colors.text.primary }]}>
              Share
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity style={styles.selectionButton} onPress={handleBatchDelete}>
            <Ionicons name="trash" size={18} color={colors.semantic.error.main} />
            <Text style={[styles.selectionButtonText, { color: colors.semantic.error.main }]}>
              Delete
            </Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );

  const renderViewModeSelector = () => (
    <View style={styles.viewModeSelector}>
      <TouchableOpacity
        style={[styles.viewModeButton, viewMode === 'compact' && styles.viewModeButtonActive]}
        onPress={() => setViewMode('compact')}
      >
        <Text style={[styles.viewModeText, { color: viewMode === 'compact' ? colors.purple[500] : theme.colors.text.secondary }]}>
          Compact
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.viewModeButton, viewMode === 'grid' && styles.viewModeButtonActive]}
        onPress={() => setViewMode('grid')}
      >
        <Text style={[styles.viewModeText, { color: viewMode === 'grid' ? colors.purple[500] : theme.colors.text.secondary }]}>
          Grid
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.viewModeButton, viewMode === 'timeline' && styles.viewModeButtonActive]}
        onPress={() => setViewMode('timeline')}
      >
        <Text style={[styles.viewModeText, { color: viewMode === 'timeline' ? colors.purple[500] : theme.colors.text.secondary }]}>
          Timeline
        </Text>
      </TouchableOpacity>
    </View>
  );

  return (
    <View style={[styles.container, style]}>
      {enableAdvancedFeatures ? renderAdvancedHeader() : (
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.colors.text.primary }]}>
            Photos
          </Text>
          <Text style={[styles.subtitle, { color: theme.colors.text.secondary }]}>
            {photos.length} / {maxPhotos} photos
          </Text>
        </View>
      )}

      {enableAdvancedFeatures && viewMode !== 'compact' && renderViewModeSelector()}
      
      {viewMode === 'compact' ? (
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.photosContainer}
        >
          {photos.map((photo, index) => renderPhoto(photo, index))}
          {photos.length < maxPhotos && renderAddPhotoButton()}
        </ScrollView>
      ) : viewMode === 'grid' ? (
        <ScrollView
          showsVerticalScrollIndicator={false}
          contentContainerStyle={styles.gridContainer}
        >
          <View style={styles.photoGrid}>
            {photos.map((photo, index) => (
              <TouchableOpacity
                key={photo.id}
                style={styles.gridPhotoItem}
                onPress={() => {
                  if (selectionMode) {
                    const isSelected = selectedPhotos.some(p => p.id === photo.id);
                    if (isSelected) {
                      setSelectedPhotos(selectedPhotos.filter(p => p.id !== photo.id));
                    } else {
                      setSelectedPhotos([...selectedPhotos, photo]);
                    }
                  } else {
                    setSelectedPhoto(photo);
                    setShowPreview(true);
                  }
                }}
              >
                <Image source={{ uri: photo.thumbnailUri || photo.uri }} style={styles.gridPhoto} />
                {selectedPhotos.some(p => p.id === photo.id) && (
                  <View style={styles.gridSelectionOverlay}>
                    <Ionicons name="checkmark-circle" size={24} color="white" />
                  </View>
                )}
              </TouchableOpacity>
            ))}
          </View>
        </ScrollView>
      ) : (
        <ScrollView showsVerticalScrollIndicator={false}>
          {photos.map((photo, index) => (
            <View key={photo.id} style={styles.timelineItem}>
              <View style={styles.timelineDate}>
                <Text style={[styles.timelineDateText, { color: theme.colors.text.secondary }]}>
                  {photo.takenAt.toLocaleDateString()}
                </Text>
                <Text style={[styles.timelineTimeText, { color: theme.colors.text.tertiary }]}>
                  {photo.takenAt.toLocaleTimeString()}
                </Text>
              </View>
              <TouchableOpacity
                style={styles.timelinePhoto}
                onPress={() => {
                  setSelectedPhoto(photo);
                  setShowPreview(true);
                }}
              >
                <Image source={{ uri: photo.uri }} style={styles.timelinePhotoImage} />
                {photo.caption && (
                  <Text style={[styles.timelineCaption, { color: theme.colors.text.primary }]}>
                    {photo.caption}
                  </Text>
                )}
              </TouchableOpacity>
            </View>
          ))}
        </ScrollView>
      )}

      {renderPhotoModal()}
      
      {/* Advanced feature modals */}
      {enableAdvancedFeatures && (
        <>
          <PhotoGallery
            photos={photos}
            visible={showGallery}
            onClose={() => setShowGallery(false)}
            initialIndex={photos.findIndex(p => p.id === selectedPhoto?.id) || 0}
            onEdit={handlePhotoEdit}
            onDelete={handlePhotoDelete}
          />
          
          {selectedPhoto && (
            <>
              <PhotoEditor
                photo={selectedPhoto}
                visible={showEditor}
                onClose={() => {
                  setShowEditor(false);
                  setSelectedPhoto(null);
                }}
                onSave={handlePhotoEdit}
              />
              
              <PhotoPreview
                photo={selectedPhoto}
                visible={showPreview}
                onClose={() => {
                  setShowPreview(false);
                  setSelectedPhoto(null);
                }}
                onEdit={handlePhotoEdit}
                onDelete={handlePhotoDelete}
                relatedPhotos={photos.filter(p => p.id !== selectedPhoto.id)}
              />
            </>
          )}
          
          <PhotoGridView
            photos={photos}
            visible={showGridView}
            onPhotoEdit={handlePhotoEdit}
            onPhotosDelete={(photosToDelete) => {
              const remainingPhotos = photos.filter(
                photo => !photosToDelete.some(p => p.id === photo.id)
              );
              onPhotosChange(remainingPhotos);
            }}
            selectionMode={selectionMode}
            selectedPhotos={selectedPhotos}
            onSelectionChange={setSelectedPhotos}
          />
        </>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginVertical: spacing[4],
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[3],
    paddingHorizontal: spacing[4],
  },
  title: {
    fontSize: 16,
    fontWeight: '700',
  },
  subtitle: {
    fontSize: 14,
    fontWeight: '500',
  },
  photosContainer: {
    paddingHorizontal: spacing[4],
  },
  photoContainer: {
    position: 'relative',
    marginRight: spacing[2],
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
  },
  photo: {
    width: PHOTO_SIZE,
    height: PHOTO_SIZE,
    borderRadius: borderRadius.lg,
  },
  photoIndicators: {
    position: 'absolute',
    bottom: spacing[2],
    left: spacing[2],
    flexDirection: 'row',
  },
  favoriteIndicator: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 12,
    padding: 4,
    marginRight: spacing[1],
  },
  captionIndicator: {
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    borderRadius: 12,
    padding: 4,
    marginRight: spacing[1],
  },
  locationIndicator: {
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    borderRadius: 12,
    padding: 4,
  },
  selectionCheckbox: {
    position: 'absolute',
    top: spacing[1],
    left: spacing[1],
    width: 20,
    height: 20,
    borderRadius: 10,
    borderWidth: 2,
    borderColor: 'white',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  selectionCheckboxActive: {
    backgroundColor: colors.purple[500],
    borderColor: colors.purple[500],
  },
  removeButton: {
    position: 'absolute',
    top: spacing[1],
    right: spacing[1],
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 12,
    padding: 2,
  },
  addPhotoButton: {
    width: PHOTO_SIZE,
    height: PHOTO_SIZE,
    borderRadius: borderRadius.lg,
    borderWidth: 2,
    borderStyle: 'dashed',
    overflow: 'hidden',
  },
  addPhotoGradient: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  addPhotoText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
    marginTop: spacing[1],
  },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: screenWidth * 0.9,
    maxHeight: '80%',
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  modalContent: {
    padding: spacing[4],
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[4],
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '700',
  },
  modalActions: {
    flexDirection: 'row',
  },
  modalActionButton: {
    padding: spacing[2],
    marginLeft: spacing[1],
  },
  modalPhotoContainer: {
    alignItems: 'center',
    marginBottom: spacing[4],
  },
  modalPhoto: {
    width: screenWidth * 0.7,
    height: screenWidth * 0.7,
    borderRadius: borderRadius.lg,
  },
  captionContainer: {
    marginBottom: spacing[3],
  },
  captionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[2],
  },
  captionLabel: {
    fontSize: 14,
    fontWeight: '600',
  },
  editCaptionButton: {
    padding: spacing[1],
  },
  captionInput: {
    borderWidth: 1,
    borderRadius: borderRadius.lg,
    padding: spacing[3],
    fontSize: 14,
    minHeight: 60,
    textAlignVertical: 'top',
  },
  captionText: {
    fontSize: 14,
    lineHeight: 20,
    fontStyle: 'italic',
  },
  metadataContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  metadataText: {
    fontSize: 12,
    marginLeft: spacing[1],
  },
  // Advanced features styles
  advancedHeader: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
  },
  headerTop: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[2],
  },
  headerActions: {
    flexDirection: 'row',
  },
  headerButton: {
    padding: spacing[2],
    marginLeft: spacing[2],
  },
  headerInfo: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  albumButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[1],
    backgroundColor: 'rgba(0, 0, 0, 0.05)',
    borderRadius: borderRadius.full,
  },
  albumText: {
    fontSize: 12,
    marginLeft: spacing[1],
  },
  selectionBar: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: spacing[3],
    paddingTop: spacing[3],
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 0, 0, 0.1)',
  },
  selectionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
  },
  selectionButtonText: {
    fontSize: 14,
    marginLeft: spacing[1],
    fontWeight: '500',
  },
  viewModeSelector: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: spacing[3],
    paddingHorizontal: spacing[4],
  },
  viewModeButton: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.full,
    marginHorizontal: spacing[1],
  },
  viewModeButtonActive: {
    backgroundColor: colors.purple[100],
  },
  viewModeText: {
    fontSize: 14,
    fontWeight: '500',
  },
  gridContainer: {
    paddingHorizontal: spacing[4],
  },
  photoGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -spacing[1],
  },
  gridPhotoItem: {
    width: '33.33%',
    padding: spacing[1],
  },
  gridPhoto: {
    width: '100%',
    aspectRatio: 1,
    borderRadius: borderRadius.lg,
  },
  gridSelectionOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(168, 85, 247, 0.3)',
    borderRadius: borderRadius.lg,
    justifyContent: 'center',
    alignItems: 'center',
  },
  timelineItem: {
    paddingHorizontal: spacing[4],
    marginBottom: spacing[4],
  },
  timelineDate: {
    marginBottom: spacing[2],
  },
  timelineDateText: {
    fontSize: 14,
    fontWeight: '600',
  },
  timelineTimeText: {
    fontSize: 12,
  },
  timelinePhoto: {
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
  },
  timelinePhotoImage: {
    width: '100%',
    height: 200,
  },
  timelineCaption: {
    padding: spacing[3],
    fontSize: 14,
    lineHeight: 20,
  },
});
</file>

<file path="src/components/ProfileEditModal.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  Modal,
  Alert,
  Dimensions,
  Image,
  Animated,
  Platform,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { profileService, UserProfile } from '../services/profileService';

const { width, height } = Dimensions.get('window');

interface ProfileEditModalProps {
  visible: boolean;
  onClose: () => void;
  onUpdate: (profile: UserProfile) => void;
  currentProfile?: UserProfile | null;
}

interface ImageCropData {
  originX: number;
  originY: number;
  width: number;
  height: number;
}

interface ImageDimensions {
  width: number;
  height: number;
}

interface CropPosition {
  x: number;
  y: number;
  scale: number;
}

export const ProfileEditModal: React.FC<ProfileEditModalProps> = ({
  visible,
  onClose,
  onUpdate,
  currentProfile,
}) => {
  const { theme } = useTheme();
  const { t, language } = useLanguage();
  const [name, setName] = useState('');
  const [avatarUri, setAvatarUri] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [showImagePicker, setShowImagePicker] = useState(false);
  const [selectedImage, setSelectedImage] = useState<string>('');
  const [cropData, setCropData] = useState<ImageCropData>({
    originX: 0,
    originY: 0,
    width: 300,
    height: 300,
  });
  const [imageDimensions, setImageDimensions] = useState<ImageDimensions>({ width: 0, height: 0 });
  const [cropPosition, setCropPosition] = useState<CropPosition>({ x: 0, y: 0, scale: 1 });
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 });
  
  // Simple Animated values for manual controls
  const translateX = useRef(new Animated.Value(0)).current;
  const translateY = useRef(new Animated.Value(0)).current;
  const scale = useRef(new Animated.Value(1)).current;
  
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  useEffect(() => {
    if (visible && currentProfile) {
      setName(currentProfile.name || '');
      setAvatarUri(currentProfile.avatarUri || '');
    }
  }, [visible, currentProfile]);

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 100,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      fadeAnim.setValue(0);
      scaleAnim.setValue(0.8);
    }
  }, [visible]);

  const handleImagePicker = async () => {
    try {
      const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert(
          t('profile.permissionRequired'),
          t('profile.permissionMessage')
        );
        return;
      }

      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: false,
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        const asset = result.assets[0];
        setSelectedImage(asset.uri);
        
        // Get image dimensions with error handling
        Image.getSize(
          asset.uri, 
          (width, height) => {
            console.log('Image dimensions:', { width, height });
            setImageDimensions({ width, height });
            
            // Reset crop position
            translateX.setValue(0);
            translateY.setValue(0);
            scale.setValue(1);
            setCropPosition({ x: 0, y: 0, scale: 1 });
            
            setShowImagePicker(true);
          },
          (error) => {
            console.error('Error getting image size:', error);
            Alert.alert(
              t('profile.imageError'), 
              t('profile.imageErrorMessage')
            );
          }
        );
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert(t('profile.imageError'), t('profile.imageErrorMessage'));
    }
  };

  const handleCropComplete = async () => {
    try {
      if (!selectedImage || !imageDimensions.width || !containerDimensions.width) return;

      const { width: originalWidth, height: originalHeight } = imageDimensions;
      const { width: containerWidth, height: containerHeight } = containerDimensions;
      
      console.log('=== CROP DEBUG START ===');
      console.log('Original image:', { originalWidth, originalHeight });
      console.log('Container:', { containerWidth, containerHeight });
      console.log('Crop position state:', cropPosition);
      
      // Calculate the base display size (without scale applied)
      const imageAspectRatio = originalWidth / originalHeight;
      const containerAspectRatio = containerWidth / containerHeight;
      
      let baseDisplayWidth, baseDisplayHeight;
      
      if (imageAspectRatio > containerAspectRatio) {
        // Image is wider than container - fit to width
        baseDisplayWidth = containerWidth;
        baseDisplayHeight = containerWidth / imageAspectRatio;
      } else {
        // Image is taller than container - fit to height  
        baseDisplayHeight = containerHeight;
        baseDisplayWidth = containerHeight * imageAspectRatio;
      }
      
      console.log('Base display size:', { baseDisplayWidth, baseDisplayHeight });
      
      // Now apply the scale factor
      const scaledWidth = baseDisplayWidth * cropPosition.scale;
      const scaledHeight = baseDisplayHeight * cropPosition.scale;
      
      console.log('Scaled display size:', { scaledWidth, scaledHeight });
      
      // Calculate where the scaled image is positioned in the container
      // The image starts centered, then we add the manual position offset
      const imageX = (containerWidth - scaledWidth) / 2 + cropPosition.x;
      const imageY = (containerHeight - scaledHeight) / 2 + cropPosition.y;
      
      console.log('Image position in container:', { imageX, imageY });
      
      // The crop circle is always centered in the container
      const cropCenterX = containerWidth / 2;
      const cropCenterY = containerHeight / 2;
      const cropRadius = 100; // 200px diameter = 100px radius
      
      console.log('Crop circle center:', { cropCenterX, cropCenterY, cropRadius });
      
      // Calculate the crop circle's position relative to the scaled image
      const cropRelativeToImageX = cropCenterX - imageX;
      const cropRelativeToImageY = cropCenterY - imageY;
      
      console.log('Crop position relative to scaled image:', { cropRelativeToImageX, cropRelativeToImageY });
      
      // Convert from scaled image coordinates to original image coordinates
      const scaleRatio = originalWidth / scaledWidth;
      
      const cropInOriginalX = cropRelativeToImageX * scaleRatio;
      const cropInOriginalY = cropRelativeToImageY * scaleRatio;
      const cropSizeInOriginal = (cropRadius * 2) * scaleRatio;
      
      console.log('Crop in original image coordinates:', {
        cropInOriginalX,
        cropInOriginalY,
        cropSizeInOriginal,
        scaleRatio
      });
      
      // Calculate the crop rectangle (top-left corner + size)
      const cropX = cropInOriginalX - (cropSizeInOriginal / 2);
      const cropY = cropInOriginalY - (cropSizeInOriginal / 2);
      
      console.log('Crop rectangle before bounds check:', { cropX, cropY, cropSizeInOriginal });
      
      // Ensure crop is within image bounds
      const minCropSize = 50; // Minimum crop size
      const maxCropSize = Math.min(originalWidth, originalHeight) * 0.95; // Max 95% of smaller dimension
      
      const boundedCropSize = Math.max(minCropSize, Math.min(cropSizeInOriginal, maxCropSize));
      const boundedCropX = Math.max(0, Math.min(cropX, originalWidth - boundedCropSize));
      const boundedCropY = Math.max(0, Math.min(cropY, originalHeight - boundedCropSize));
      
      console.log('Final crop parameters:', {
        boundedCropX,
        boundedCropY,
        boundedCropSize
      });
      console.log('=== CROP DEBUG END ===');

      const manipResult = await ImageManipulator.manipulateAsync(
        selectedImage,
        [
          {
            crop: {
              originX: Math.round(boundedCropX),
              originY: Math.round(boundedCropY),
              width: Math.round(boundedCropSize),
              height: Math.round(boundedCropSize),
            },
          },
          { resize: { width: 200, height: 200 } },
        ],
        { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG }
      );

      setAvatarUri(manipResult.uri);
      setShowImagePicker(false);
      setSelectedImage('');
    } catch (error) {
      console.error('Error cropping image:', error);
      Alert.alert(
        t('profile.cropError'), 
        t('profile.cropErrorMessage')
      );
    }
  };

  const handleRemoveImage = () => {
    setAvatarUri('');
    setShowImagePicker(false);
    setSelectedImage('');
  };

  const handleSave = async () => {
    if (!name.trim()) {
      Alert.alert(t('profile.nameRequired'), t('profile.nameRequiredMessage'));
      return;
    }

    setIsLoading(true);
    try {
      const updatedProfile = await profileService.updateProfile({
        name: name.trim(),
        avatarUri: avatarUri || undefined,
      });
      onUpdate(updatedProfile);
      onClose();
    } catch (error) {
      console.error('Error updating profile:', error);
      Alert.alert(t('profile.saveError'), t('profile.saveErrorMessage'));
    } finally {
      setIsLoading(false);
    }
  };

  const handleCancel = () => {
    if (currentProfile) {
      setName(currentProfile.name || '');
      setAvatarUri(currentProfile.avatarUri || '');
    }
    onClose();
  };

  const handleSkipImage = () => {
    setShowImagePicker(false);
    setSelectedImage('');
    // Reset animation values
    translateX.setValue(0);
    translateY.setValue(0);
    scale.setValue(1);
    setCropPosition({ x: 0, y: 0, scale: 1 });
  };
  

  if (!visible) return null;

  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      statusBarTranslucent
    >
      <View style={styles.overlay}>
        <BlurView intensity={80} style={StyleSheet.absoluteFill} />
        
        <Animated.View
          style={[
            styles.container,
            {
              opacity: fadeAnim,
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <LinearGradient
            colors={[
              theme.colors.background.elevated,
              theme.colors.background.card,
            ]}
            style={styles.content}
          >
            {/* Header */}
            <View style={styles.header}>
              <Text style={[styles.title, { color: theme.colors.text.primary }]}>
                {t('profile.editProfile')}
              </Text>
            </View>

            {/* Avatar Section */}
            <View style={styles.avatarSection}>
              <TouchableOpacity
                style={[
                  styles.avatarContainer,
                  {
                    borderColor: colors.purple.bright + '30',
                    backgroundColor: colors.purple.bright + '10',
                  },
                ]}
                onPress={handleImagePicker}
              >
                {avatarUri ? (
                  <Image source={{ uri: avatarUri }} style={styles.avatar} />
                ) : (
                  <View style={styles.avatarPlaceholder}>
                    <Ionicons
                      name="camera"
                      size={32}
                      color={colors.purple.bright}
                    />
                    <Text style={[styles.avatarText, { color: colors.purple.bright }]}>
                      {t('profile.addPhoto')}
                    </Text>
                  </View>
                )}
              </TouchableOpacity>
              
              <View style={styles.avatarActions}>
                <TouchableOpacity
                  style={styles.imageActionButton}
                  onPress={handleImagePicker}
                >
                  <Text style={[styles.imageActionText, { color: colors.purple.bright }]}>
                    {avatarUri ? t('profile.changePhoto') : t('profile.addPhoto')}
                  </Text>
                </TouchableOpacity>
                
                {avatarUri && (
                  <TouchableOpacity
                    style={styles.imageActionButton}
                    onPress={handleRemoveImage}
                  >
                    <Text style={[styles.imageActionText, { color: colors.semantic.error.main }]}>
                      {t('common.delete')}
                    </Text>
                  </TouchableOpacity>
                )}
              </View>
            </View>

            {/* Name Input */}
            <View style={styles.inputSection}>
              <Text style={[styles.inputLabel, { color: theme.colors.text.primary }]}>
                {t('profile.yourName')} *
              </Text>
              <TextInput
                style={[
                  styles.nameInput,
                  {
                    backgroundColor: theme.colors.background.secondary,
                    borderColor: colors.utility.borderLight,
                    color: theme.colors.text.primary,
                  },
                ]}
                value={name}
                onChangeText={setName}
                placeholder={t('profile.namePlaceholder')}
                placeholderTextColor={theme.colors.text.disabled}
                maxLength={50}
              />
            </View>

            {/* Bottom Buttons */}
            <View style={styles.bottomButtons}>
              <TouchableOpacity onPress={handleCancel} style={styles.cancelButtonBottom}>
                <Text style={[styles.cancelText, { color: theme.colors.text.secondary }]}>
                  {t('common.cancel')}
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                onPress={handleSave}
                style={[
                  styles.saveButtonBottom,
                  {
                    backgroundColor: colors.purple.bright,
                    opacity: !name.trim() || isLoading ? 0.5 : 1,
                  },
                ]}
                disabled={!name.trim() || isLoading}
              >
                <Text style={styles.saveText}>
                  {isLoading ? t('profile.saving') : t('common.save')}
                </Text>
              </TouchableOpacity>
            </View>
          </LinearGradient>
        </Animated.View>

        {/* Image Picker Modal */}
        {showImagePicker && (
          <Modal visible={showImagePicker} transparent>
            <View style={styles.overlay}>
              <BlurView intensity={80} style={StyleSheet.absoluteFill} />
              
              <View style={[styles.cropContainer, { backgroundColor: theme.colors.background.elevated }]}>
                <View style={styles.cropHeader}>
                  <TouchableOpacity onPress={handleSkipImage}>
                    <Text style={[styles.cropCancelText, { color: theme.colors.text.secondary }]}>
                      {t('common.cancel')}
                    </Text>
                  </TouchableOpacity>
                  
                  <Text style={[styles.cropTitle, { color: theme.colors.text.primary }]}>
                    {t('profile.cropImage')}
                  </Text>
                  
                  <TouchableOpacity onPress={handleCropComplete}>
                    <Text style={[styles.cropDoneText, { color: colors.purple.bright }]}>
                      {t('common.done')}
                    </Text>
                  </TouchableOpacity>
                </View>

                {selectedImage && (
                  <View 
                    style={styles.cropImageContainer}
                    onLayout={(event) => {
                      const { width, height } = event.nativeEvent.layout;
                      setContainerDimensions({ width, height });
                    }}
                  >
                    <Animated.View
                      style={[
                        styles.imageWrapper,
                        {
                          transform: [
                            { translateX: translateX },
                            { translateY: translateY },
                            { scale: scale },
                          ],
                        },
                      ]}
                    >
                      <Image
                        source={{ uri: selectedImage }}
                        style={styles.cropImage}
                        resizeMode="contain"
                      />
                    </Animated.View>
                    
                    {/* Crop frame overlay */}
                    <View style={styles.cropOverlay}>
                      <View style={styles.cropFrame}>
                        {/* Inner transparent circle to show crop area clearly */}
                        <View style={styles.cropInner} />
                      </View>
                    </View>
                  </View>
                )}

                  <Text style={[styles.cropInstructions, { color: theme.colors.text.secondary }]}>
                    {t('profile.cropInstructions')}
                  </Text>
                  
                  {/* Manual Controls */}
                  <View style={styles.cropControls}>
                    {/* Scale Controls */}
                    <View style={styles.controlRow}>
                      <Text style={[styles.controlLabel, { color: theme.colors.text.secondary }]}>
                        {t('profile.scaleControl') || (language === 'ja' ? '拡大・縮小' : 'Scale')}
                      </Text>
                      <View style={styles.controlButtons}>
                        <TouchableOpacity
                          style={[styles.controlButton, { backgroundColor: theme.colors.background.secondary }]}
                          onPress={() => {
                            const newScale = Math.max(0.5, cropPosition.scale - 0.1);
                            setCropPosition(prev => ({ ...prev, scale: newScale }));
                            Animated.timing(scale, {
                              toValue: newScale,
                              duration: 200,
                              useNativeDriver: true,
                            }).start();
                          }}
                        >
                          <Ionicons name="remove" size={16} color={theme.colors.text.primary} />
                        </TouchableOpacity>
                        <Text style={[styles.scaleText, { color: theme.colors.text.primary }]}>
                          {(cropPosition.scale * 100).toFixed(0)}%
                        </Text>
                        <TouchableOpacity
                          style={[styles.controlButton, { backgroundColor: theme.colors.background.secondary }]}
                          onPress={() => {
                            const newScale = Math.min(3, cropPosition.scale + 0.1);
                            setCropPosition(prev => ({ ...prev, scale: newScale }));
                            Animated.timing(scale, {
                              toValue: newScale,
                              duration: 200,
                              useNativeDriver: true,
                            }).start();
                          }}
                        >
                          <Ionicons name="add" size={16} color={theme.colors.text.primary} />
                        </TouchableOpacity>
                      </View>
                    </View>

                    {/* Position Controls */}
                    <View style={styles.controlRow}>
                      <Text style={[styles.controlLabel, { color: theme.colors.text.secondary }]}>
                        {t('profile.positionControl') || (language === 'ja' ? '位置調整' : 'Position')}
                      </Text>
                      <View style={styles.positionControls}>
                        {/* Vertical Controls */}
                        <TouchableOpacity
                          style={[styles.controlButton, { backgroundColor: theme.colors.background.secondary }]}
                          onPress={() => {
                            const newY = cropPosition.y + 10; // Up button moves image up (positive Y)
                            setCropPosition(prev => ({ ...prev, y: newY }));
                            Animated.timing(translateY, {
                              toValue: newY,
                              duration: 200,
                              useNativeDriver: true,
                            }).start();
                          }}
                        >
                          <Ionicons name="chevron-up" size={16} color={theme.colors.text.primary} />
                        </TouchableOpacity>
                        
                        <View style={styles.horizontalControls}>
                          <TouchableOpacity
                            style={[styles.controlButton, { backgroundColor: theme.colors.background.secondary }]}
                            onPress={() => {
                              const newX = cropPosition.x + 10; // Left button moves image left (positive X)
                              setCropPosition(prev => ({ ...prev, x: newX }));
                              Animated.timing(translateX, {
                                toValue: newX,
                                duration: 200,
                                useNativeDriver: true,
                              }).start();
                            }}
                          >
                            <Ionicons name="chevron-back" size={16} color={theme.colors.text.primary} />
                          </TouchableOpacity>
                          
                          <TouchableOpacity
                            style={[styles.resetButton, { backgroundColor: colors.purple.bright }]}
                            onPress={() => {
                              setCropPosition(prev => ({ ...prev, x: 0, y: 0 }));
                              Animated.parallel([
                                Animated.timing(translateX, {
                                  toValue: 0,
                                  duration: 300,
                                  useNativeDriver: true,
                                }),
                                Animated.timing(translateY, {
                                  toValue: 0,
                                  duration: 300,
                                  useNativeDriver: true,
                                }),
                              ]).start();
                            }}
                          >
                            <Ionicons name="refresh" size={14} color="white" />
                          </TouchableOpacity>
                          
                          <TouchableOpacity
                            style={[styles.controlButton, { backgroundColor: theme.colors.background.secondary }]}
                            onPress={() => {
                              const newX = cropPosition.x - 10; // Right button moves image right (negative X)
                              setCropPosition(prev => ({ ...prev, x: newX }));
                              Animated.timing(translateX, {
                                toValue: newX,
                                duration: 200,
                                useNativeDriver: true,
                              }).start();
                            }}
                          >
                            <Ionicons name="chevron-forward" size={16} color={theme.colors.text.primary} />
                          </TouchableOpacity>
                        </View>
                        
                        <TouchableOpacity
                          style={[styles.controlButton, { backgroundColor: theme.colors.background.secondary }]}
                          onPress={() => {
                            const newY = cropPosition.y - 10; // Down button moves image down (negative Y)
                            setCropPosition(prev => ({ ...prev, y: newY }));
                            Animated.timing(translateY, {
                              toValue: newY,
                              duration: 200,
                              useNativeDriver: true,
                            }).start();
                          }}
                        >
                          <Ionicons name="chevron-down" size={16} color={theme.colors.text.primary} />
                        </TouchableOpacity>
                      </View>
                    </View>
                  </View>
                </View>
              </View>
            </Modal>
        )}
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  container: {
    width: Math.min(400, width * 0.9),
    maxHeight: height * 0.8,
  },
  content: {
    borderRadius: 24,
    padding: 24,
    elevation: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.25,
    shadowRadius: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 24,
  },
  cancelButton: {
    paddingVertical: 8,
    paddingHorizontal: 4,
  },
  cancelText: {
    fontSize: 16,
    fontWeight: '500',
  },
  title: {
    fontSize: 20,
    fontWeight: '700',
    textAlign: 'center',
  },
  saveButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
  },
  saveText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  avatarSection: {
    alignItems: 'center',
    marginBottom: 24,
  },
  avatarContainer: {
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 3,
    overflow: 'hidden',
    marginBottom: 16,
  },
  avatar: {
    width: '100%',
    height: '100%',
  },
  avatarPlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarText: {
    fontSize: 12,
    fontWeight: '600',
    marginTop: 4,
  },
  avatarActions: {
    flexDirection: 'row',
    gap: 16,
  },
  imageActionButton: {
    paddingVertical: 4,
  },
  imageActionText: {
    fontSize: 14,
    fontWeight: '600',
  },
  inputSection: {
    marginBottom: 16,
  },
  inputLabel: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  nameInput: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
  },
  cropContainer: {
    width: Math.min(400, width * 0.95),
    height: height * 0.8,
    borderRadius: 20,
    overflow: 'hidden',
  },
  cropHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
  },
  cropCancelText: {
    fontSize: 16,
    fontWeight: '500',
  },
  cropTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  cropDoneText: {
    fontSize: 16,
    fontWeight: '600',
  },
  cropImageContainer: {
    flex: 1,
    position: 'relative',
    margin: 20,
    overflow: 'hidden',
  },
  gestureContainer: {
    flex: 1,
  },
  imageWrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cropImage: {
    width: '100%',
    height: '100%',
  },
  cropOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
  },
  cropFrame: {
    width: 200,
    height: 200,
    borderWidth: 4,
    borderColor: 'white',
    borderRadius: 100,
    backgroundColor: 'transparent',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.9,
    shadowRadius: 6,
    // Add a second border for better visibility
    borderStyle: 'solid',
  },
  cropInner: {
    position: 'absolute',
    top: 4,
    left: 4,
    right: 4,
    bottom: 4,
    borderRadius: 92, // 96 - 4 (border width)
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.8)',
  },
  cropInstructions: {
    textAlign: 'center',
    padding: 20,
    fontSize: 14,
    lineHeight: 20,
  },
  cropControls: {
    paddingHorizontal: 20,
    paddingBottom: 20,
  },
  controlRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  controlLabel: {
    fontSize: 14,
    fontWeight: '500',
  },
  controlButtons: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  controlButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scaleText: {
    fontSize: 14,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'center',
  },
  positionControls: {
    alignItems: 'center',
    gap: 8,
  },
  horizontalControls: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  resetButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  bottomButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 24,
    gap: 16,
  },
  cancelButtonBottom: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: colors.utility.borderLight,
    alignItems: 'center',
  },
  saveButtonBottom: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
});
</file>

<file path="src/components/ProfileSetupModal.tsx">
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  Modal,
  Alert,
  Dimensions,
  Image,
  Animated,
  Platform,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { profileService, UserProfile } from '../services/profileService';

const { width, height } = Dimensions.get('window');

interface ProfileSetupModalProps {
  visible: boolean;
  onComplete: (profile: UserProfile) => void;
}

interface ImageCropData {
  originX: number;
  originY: number;
  width: number;
  height: number;
}

export const ProfileSetupModal: React.FC<ProfileSetupModalProps> = ({
  visible,
  onComplete,
}) => {
  const { theme } = useTheme();
  const { t } = useLanguage();
  const [name, setName] = useState('');
  const [avatarUri, setAvatarUri] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [showImagePicker, setShowImagePicker] = useState(false);
  const [selectedImage, setSelectedImage] = useState<string>('');
  const [cropData, setCropData] = useState<ImageCropData>({
    originX: 0,
    originY: 0,
    width: 300,
    height: 300,
  });
  
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  React.useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 100,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible]);

  const handleImagePicker = async () => {
    try {
      const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert(
          t('profile.permissionRequired'),
          t('profile.permissionMessage')
        );
        return;
      }

      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: false,
        aspect: [1, 1],
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        setSelectedImage(result.assets[0].uri);
        setShowImagePicker(true);
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert(t('profile.imageError'), t('profile.imageErrorMessage'));
    }
  };

  const handleCropComplete = async () => {
    try {
      if (!selectedImage) return;

      const manipResult = await ImageManipulator.manipulateAsync(
        selectedImage,
        [
          {
            crop: {
              originX: cropData.originX,
              originY: cropData.originY,
              width: cropData.width,
              height: cropData.height,
            },
          },
          { resize: { width: 200, height: 200 } },
        ],
        { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG }
      );

      setAvatarUri(manipResult.uri);
      setShowImagePicker(false);
      setSelectedImage('');
    } catch (error) {
      console.error('Error cropping image:', error);
      Alert.alert(t('profile.cropError'), t('profile.cropErrorMessage'));
    }
  };

  const handleComplete = async () => {
    if (!name.trim()) {
      Alert.alert(t('profile.nameRequired'), t('profile.nameRequiredMessage'));
      return;
    }

    setIsLoading(true);
    try {
      const profile = await profileService.saveProfile({
        name: name.trim(),
        avatarUri: avatarUri || undefined,
      });
      onComplete(profile);
    } catch (error) {
      console.error('Error saving profile:', error);
      Alert.alert(t('profile.saveError'), t('profile.saveErrorMessage'));
    } finally {
      setIsLoading(false);
    }
  };

  const handleSkipImage = () => {
    setAvatarUri('');
    setShowImagePicker(false);
    setSelectedImage('');
  };

  if (!visible) return null;

  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      statusBarTranslucent
    >
      <View style={styles.overlay}>
        <BlurView intensity={80} style={StyleSheet.absoluteFill} />
        
        <Animated.View
          style={[
            styles.container,
            {
              opacity: fadeAnim,
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <LinearGradient
            colors={[
              theme.colors.background.elevated,
              theme.colors.background.card,
            ]}
            style={styles.content}
          >
            {/* Header */}
            <View style={styles.header}>
              <Text style={[styles.title, { color: theme.colors.text.primary }]}>
                {t('profile.welcomeTitle')}
              </Text>
              <Text style={[styles.subtitle, { color: theme.colors.text.secondary }]}>
                {t('profile.welcomeMessage')}
              </Text>
            </View>

            {/* Avatar Section */}
            <View style={styles.avatarSection}>
              <TouchableOpacity
                style={[
                  styles.avatarContainer,
                  {
                    borderColor: colors.purple.bright + '30',
                    backgroundColor: colors.purple.bright + '10',
                  },
                ]}
                onPress={handleImagePicker}
              >
                {avatarUri ? (
                  <Image source={{ uri: avatarUri }} style={styles.avatar} />
                ) : (
                  <View style={styles.avatarPlaceholder}>
                    <Ionicons
                      name="camera"
                      size={32}
                      color={colors.purple.bright}
                    />
                    <Text style={[styles.avatarText, { color: colors.purple.bright }]}>
                      {t('profile.addPhoto')}
                    </Text>
                  </View>
                )}
              </TouchableOpacity>
              
              {avatarUri && (
                <TouchableOpacity
                  style={styles.changeImageButton}
                  onPress={handleImagePicker}
                >
                  <Text style={[styles.changeImageText, { color: colors.purple.bright }]}>
                    {t('profile.changePhoto')}
                  </Text>
                </TouchableOpacity>
              )}
            </View>

            {/* Name Input */}
            <View style={styles.inputSection}>
              <Text style={[styles.inputLabel, { color: theme.colors.text.primary }]}>
                {t('profile.yourName')} *
              </Text>
              <TextInput
                style={[
                  styles.nameInput,
                  {
                    backgroundColor: theme.colors.background.secondary,
                    borderColor: colors.utility.borderLight,
                    color: theme.colors.text.primary,
                  },
                ]}
                value={name}
                onChangeText={setName}
                placeholder={t('profile.namePlaceholder')}
                placeholderTextColor={theme.colors.text.disabled}
                maxLength={50}
                autoFocus
              />
            </View>

            {/* Action Buttons */}
            <View style={styles.actions}>
              <TouchableOpacity
                style={[
                  styles.completeButton,
                  {
                    backgroundColor: colors.purple.bright,
                    opacity: !name.trim() || isLoading ? 0.5 : 1,
                  },
                ]}
                onPress={handleComplete}
                disabled={!name.trim() || isLoading}
              >
                <Text style={styles.completeButtonText}>
                  {isLoading ? t('profile.saving') : t('profile.getStarted')}
                </Text>
              </TouchableOpacity>
            </View>
          </LinearGradient>
        </Animated.View>

        {/* Image Picker Modal */}
        {showImagePicker && (
          <Modal visible={showImagePicker} transparent>
            <View style={styles.overlay}>
              <BlurView intensity={80} style={StyleSheet.absoluteFill} />
              
              <View style={[styles.cropContainer, { backgroundColor: theme.colors.background.elevated }]}>
                <View style={styles.cropHeader}>
                  <TouchableOpacity onPress={handleSkipImage}>
                    <Text style={[styles.cropCancelText, { color: theme.colors.text.secondary }]}>
                      {t('common.cancel')}
                    </Text>
                  </TouchableOpacity>
                  
                  <Text style={[styles.cropTitle, { color: theme.colors.text.primary }]}>
                    {t('profile.cropImage')}
                  </Text>
                  
                  <TouchableOpacity onPress={handleCropComplete}>
                    <Text style={[styles.cropDoneText, { color: colors.purple.bright }]}>
                      {t('common.done')}
                    </Text>
                  </TouchableOpacity>
                </View>

                {selectedImage && (
                  <View style={styles.cropImageContainer}>
                    <Image
                      source={{ uri: selectedImage }}
                      style={styles.cropImage}
                      resizeMode="contain"
                    />
                    <View style={styles.cropOverlay}>
                      <View style={styles.cropFrame} />
                    </View>
                  </View>
                )}

                <Text style={[styles.cropInstructions, { color: theme.colors.text.secondary }]}>
                  {t('profile.cropInstructions')}
                </Text>
              </View>
            </View>
          </Modal>
        )}
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  container: {
    width: Math.min(400, width * 0.9),
    maxHeight: height * 0.8,
  },
  content: {
    borderRadius: 24,
    padding: 32,
    elevation: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.25,
    shadowRadius: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 32,
  },
  title: {
    fontSize: 28,
    fontWeight: '700',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 16,
    textAlign: 'center',
    lineHeight: 24,
  },
  avatarSection: {
    alignItems: 'center',
    marginBottom: 32,
  },
  avatarContainer: {
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 3,
    overflow: 'hidden',
    marginBottom: 12,
  },
  avatar: {
    width: '100%',
    height: '100%',
  },
  avatarPlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarText: {
    fontSize: 12,
    fontWeight: '600',
    marginTop: 4,
  },
  changeImageButton: {
    paddingVertical: 4,
  },
  changeImageText: {
    fontSize: 14,
    fontWeight: '600',
  },
  inputSection: {
    marginBottom: 32,
  },
  inputLabel: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  nameInput: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
  },
  actions: {
    gap: 12,
  },
  completeButton: {
    borderRadius: 12,
    paddingVertical: 16,
    alignItems: 'center',
  },
  completeButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  cropContainer: {
    width: Math.min(400, width * 0.95),
    height: height * 0.8,
    borderRadius: 20,
    overflow: 'hidden',
  },
  cropHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
  },
  cropCancelText: {
    fontSize: 16,
    fontWeight: '500',
  },
  cropTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  cropDoneText: {
    fontSize: 16,
    fontWeight: '600',
  },
  cropImageContainer: {
    flex: 1,
    position: 'relative',
    margin: 20,
  },
  cropImage: {
    width: '100%',
    height: '100%',
  },
  cropOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cropFrame: {
    width: 200,
    height: 200,
    borderWidth: 2,
    borderColor: 'white',
    borderRadius: 100,
    backgroundColor: 'transparent',
  },
  cropInstructions: {
    textAlign: 'center',
    padding: 20,
    fontSize: 14,
    lineHeight: 20,
  },
});
</file>

<file path="src/components/TermsOfServiceModal.tsx">
import React, { useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Animated,
  ScrollView,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';

interface TermsOfServiceModalProps {
  visible: boolean;
  onClose: () => void;
}

export const TermsOfServiceModal: React.FC<TermsOfServiceModalProps> = ({
  visible,
  onClose,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 100,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      fadeAnim.setValue(0);
      scaleAnim.setValue(0.8);
    }
  }, [visible]);

  if (!visible) return null;

  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      statusBarTranslucent
    >
      <View style={styles.overlay}>
        <BlurView intensity={80} style={StyleSheet.absoluteFill} />
        
        <Animated.View
          style={[
            styles.container,
            {
              opacity: fadeAnim,
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <LinearGradient
            colors={[
              theme.colors.background.elevated,
              theme.colors.background.card,
            ]}
            style={styles.content}
          >
            {/* Header */}
            <View style={styles.header}>
              <Text style={[styles.title, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? '利用規約' : 'Terms of Service'}
              </Text>
              <TouchableOpacity onPress={onClose} style={styles.closeButton}>
                <Ionicons name="close" size={24} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            </View>

            <ScrollView showsVerticalScrollIndicator={false} style={styles.scrollView}>
              {/* Effective Date */}
              <View style={styles.section}>
                <Text style={[styles.effectiveDate, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '最終更新日：2024年6月2日' : 'Last updated: June 2, 2024'}
                </Text>
              </View>

              {/* Introduction */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'はじめに' : 'Introduction'}
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' 
                    ? '本利用規約（以下「本規約」）は、TDR Days Team（以下「当チーム」）が提供する「TDR Days」アプリケーション（以下「本アプリ」）の利用条件を定めるものです。本アプリをご利用になる前に、必ず本規約をお読みください。'
                    : 'These Terms of Service ("Terms") define the conditions for using the "TDR Days" application ("App") provided by TDR Days Team ("Team"). Please read these Terms carefully before using the App.'
                  }
                </Text>
              </View>

              {/* Important Notice */}
              <View style={styles.section}>
                <View style={[styles.importantNotice, { backgroundColor: colors.orange[500] + '20', borderColor: colors.orange[500] }]}>
                  <View style={styles.noticeHeader}>
                    <Ionicons name="warning" size={20} color={colors.orange[500]} />
                    <Text style={[styles.noticeTitle, { color: colors.orange[500] }]}>
                      {language === 'ja' ? '重要なお知らせ' : 'Important Notice'}
                    </Text>
                  </View>
                  <Text style={[styles.noticeText, { color: theme.colors.text.primary }]}>
                    {language === 'ja' 
                      ? '本アプリ「TDR Days」は、株式会社オリエンタルランドまたはウォルト・ディズニー・カンパニーの公式アプリケーションではありません。当アプリは個人開発者によって作成された非公式のファンアプリです。'
                      : 'The "TDR Days" app is not an official application of Oriental Land Co., Ltd. or The Walt Disney Company. This app is an unofficial fan app created by individual developers.'
                    }
                  </Text>
                  <Text style={[styles.noticeText, { color: theme.colors.text.primary }]}>
                    {language === 'ja' 
                      ? '東京ディズニーリゾート、ディズニーランド、ディズニーシーは株式会社オリエンタルランドの商標または登録商標です。'
                      : 'Tokyo Disney Resort, Disneyland, and Disney Sea are trademarks or registered trademarks of Oriental Land Co., Ltd.'
                    }
                  </Text>
                </View>
              </View>

              {/* Article 1 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? '第1条（適用）' : 'Article 1 (Application)'}
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 本規約は、ユーザーと当チームとの間の本アプリの利用に関わる一切の関係に適用されるものとします。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. 本アプリをダウンロード、インストール、または使用することにより、ユーザーは本規約に同意したものとみなします。
                </Text>
              </View>

              {/* Article 2 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第2条（利用登録）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 本アプリは利用登録を必要とせず、ダウンロード後すぐにご利用いただけます。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. すべてのデータはユーザーのデバイス内にローカル保存され、外部サーバーには送信されません。
                </Text>
              </View>

              {/* Article 3 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第3条（禁止事項）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  ユーザーは、本アプリの利用にあたり、以下の行為をしてはなりません：
                </Text>
                <Text style={[styles.listItem, { color: theme.colors.text.secondary }]}>
                  • 法令または公序良俗に違反する行為
                </Text>
                <Text style={[styles.listItem, { color: theme.colors.text.secondary }]}>
                  • 犯罪行為に関連する行為
                </Text>
                <Text style={[styles.listItem, { color: theme.colors.text.secondary }]}>
                  • 当チームのサーバーまたはネットワークの機能を破壊したり、妨害したりする行為
                </Text>
                <Text style={[styles.listItem, { color: theme.colors.text.secondary }]}>
                  • 本アプリを逆アセンブル、逆コンパイル、リバースエンジニアリングする行為
                </Text>
                <Text style={[styles.listItem, { color: theme.colors.text.secondary }]}>
                  • その他、当チームが不適切と判断する行為
                </Text>
              </View>

              {/* Article 4 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第4条（個人情報・プライバシー）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 本アプリは個人情報を収集いたしません。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. ユーザーが入力したすべてのデータ（来園記録、写真、メモなど）は、ユーザーのデバイス内にのみ保存されます。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  3. 当チームはユーザーのデータにアクセスすることはできません。
                </Text>
              </View>

              {/* Article 5 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第5条（利用制限・停止）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 当チームは、ユーザーが本規約に違反した場合、事前の通知なくして本アプリの利用を制限することができるものとします。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. 当チームは、本条に基づき当チームが行った行為によりユーザーに生じた損害について、一切の責任を負いません。
                </Text>
              </View>

              {/* Article 6 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第6条（保証の否認・免責事項）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 当チームは、本アプリに事実上または法律上の瑕疵がないことを明示的にも黙示的にも保証しておりません。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. 当チームは、本アプリに起因してユーザーに生じたあらゆる損害について、一切の責任を負いません。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  3. ユーザーは自己の責任において本アプリを利用するものとし、データのバックアップ等は各自で行うものとします。
                </Text>
              </View>

              {/* Article 7 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第7条（アプリの変更・終了）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 当チームは、ユーザーに事前に通知することなく、本アプリの内容を変更し、または本アプリの提供を中止することができるものとします。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. 当チームは、これらによってユーザーに生じた損害について一切の責任を負いません。
                </Text>
              </View>

              {/* Article 8 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第8条（利用規約の変更）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 当チームは、必要と判断した場合には、ユーザーに通知することなくいつでも本規約を変更することができるものとします。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. 本規約の変更後、本アプリの利用を開始した場合には、当該ユーザーは変更後の規約に同意したものとみなします。
                </Text>
              </View>

              {/* Article 9 */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  第9条（準拠法・管轄裁判所）
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  1. 本規約の解釈にあたっては、日本法を準拠法とします。
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  2. 本アプリに関して紛争が生じた場合には、当チームの所在地を管轄する裁判所を専属的管轄裁判所とします。
                </Text>
              </View>

              {/* Contact */}
              <View style={styles.section}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  {language === 'ja' ? 'お問い合わせ' : 'Contact'}
                </Text>
                <Text style={[styles.text, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' 
                    ? '本規約に関するご質問やお問い合わせは、アプリ内のサポート機能からLINEにてご連絡ください。'
                    : 'For questions or inquiries regarding these Terms, please contact us via LINE through the support function in the app.'
                  }
                </Text>
              </View>

              {/* Footer */}
              <View style={styles.footer}>
                <Text style={[styles.footerText, { color: theme.colors.text.disabled }]}>
                  TDR Days Team
                </Text>
                <Text style={[styles.footerText, { color: theme.colors.text.disabled }]}>
                  © 2024 All rights reserved.
                </Text>
              </View>

              {/* Bottom spacing */}
              <View style={{ height: 40 }} />
            </ScrollView>
          </LinearGradient>
        </Animated.View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
  },
  container: {
    width: '95%',
    maxWidth: 600,
    maxHeight: '90%',
  },
  content: {
    borderRadius: 24,
    elevation: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.25,
    shadowRadius: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 24,
    paddingBottom: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
  },
  closeButton: {
    padding: 4,
  },
  scrollView: {
    paddingHorizontal: 24,
  },
  section: {
    marginBottom: 24,
  },
  effectiveDate: {
    fontSize: 12,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 12,
  },
  text: {
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 8,
  },
  listItem: {
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 4,
    marginLeft: 8,
  },
  footer: {
    alignItems: 'center',
    marginTop: 32,
    marginBottom: 16,
  },
  footerText: {
    fontSize: 12,
    textAlign: 'center',
    marginBottom: 4,
  },
  importantNotice: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 16,
  },
  noticeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
    gap: 8,
  },
  noticeTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  noticeText: {
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 8,
  },
});
</file>

<file path="src/services/profileService.ts">
import AsyncStorage from '@react-native-async-storage/async-storage';

const PROFILE_KEY = 'user_profile';

export interface UserProfile {
  name: string;
  avatarUri?: string;
  createdAt: Date;
  updatedAt: Date;
}

export const profileService = {
  async getProfile(): Promise<UserProfile | null> {
    try {
      const profileData = await AsyncStorage.getItem(PROFILE_KEY);
      if (!profileData) return null;
      
      const parsed = JSON.parse(profileData);
      return {
        ...parsed,
        createdAt: new Date(parsed.createdAt),
        updatedAt: new Date(parsed.updatedAt),
      };
    } catch (error) {
      console.error('Error loading profile:', error);
      return null;
    }
  },

  async saveProfile(profile: Omit<UserProfile, 'createdAt' | 'updatedAt'>): Promise<UserProfile> {
    try {
      const existingProfile = await this.getProfile();
      const now = new Date();
      
      const newProfile: UserProfile = {
        ...profile,
        createdAt: existingProfile?.createdAt || now,
        updatedAt: now,
      };

      await AsyncStorage.setItem(PROFILE_KEY, JSON.stringify(newProfile));
      return newProfile;
    } catch (error) {
      console.error('Error saving profile:', error);
      throw error;
    }
  },

  async updateProfile(updates: Partial<Pick<UserProfile, 'name' | 'avatarUri'>>): Promise<UserProfile> {
    try {
      const existingProfile = await this.getProfile();
      if (!existingProfile) {
        throw new Error('No existing profile found');
      }

      const updatedProfile: UserProfile = {
        ...existingProfile,
        ...updates,
        updatedAt: new Date(),
      };

      await AsyncStorage.setItem(PROFILE_KEY, JSON.stringify(updatedProfile));
      return updatedProfile;
    } catch (error) {
      console.error('Error updating profile:', error);
      throw error;
    }
  },

  async deleteProfile(): Promise<void> {
    try {
      await AsyncStorage.removeItem(PROFILE_KEY);
    } catch (error) {
      console.error('Error deleting profile:', error);
      throw error;
    }
  },

  async hasProfile(): Promise<boolean> {
    try {
      const profile = await this.getProfile();
      return profile !== null && profile.name.trim() !== '';
    } catch (error) {
      console.error('Error checking profile existence:', error);
      return false;
    }
  },
};
</file>

<file path="eas.json">
{
  "cli": {
    "version": ">= 16.6.2",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
</file>

<file path="src/components/charts/BarChart.tsx">
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  Dimensions,
  TouchableOpacity,
  ScrollView,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useTheme } from '../../contexts/ThemeContext';
import { colors } from '../../styles/colors';
import { spacing, borderRadius } from '../../styles/theme';

const { width: screenWidth } = Dimensions.get('window');

export interface BarChartData {
  label: string;
  value: number;
  color?: string;
  description?: string;
}

export interface BarChartProps {
  data: BarChartData[];
  title: string;
  orientation?: 'vertical' | 'horizontal';
  maxValue?: number;
  showValues?: boolean;
  showGrid?: boolean;
  barColors?: string[];
  onBarPress?: (item: BarChartData, index: number) => void;
  animationDuration?: number;
  animationDelay?: number;
  height?: number;
}

const AnimatedView = Animated.createAnimatedComponent(View);

export const BarChart: React.FC<BarChartProps> = ({
  data,
  title,
  orientation = 'vertical',
  maxValue,
  showValues = true,
  showGrid = true,
  barColors = [
    colors.purple[500],
    '#3b82f6', // blue
    '#22c55e', // green
    '#facc15', // yellow
    '#ef4444', // red
    '#06b6d4', // cyan
    '#ec4899', // pink
  ],
  onBarPress,
  animationDuration = 800,
  animationDelay = 0,
  height = 250,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  
  // Early return for invalid data
  if (!data || !Array.isArray(data) || data.length === 0) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background.card }]}>
        <LinearGradient colors={['rgba(168, 85, 247, 0.03)', 'rgba(147, 51, 234, 0.02)', 'transparent']} style={styles.gradient}>
          <Text style={[styles.title, { color: theme.colors.text.primary }]}>{title}</Text>
          <Text style={[styles.title, { color: theme.colors.text.secondary, fontSize: 14 }]}>No data available</Text>
        </LinearGradient>
      </View>
    );
  }
  
  // Animation values
  const animatedValues = useRef(
    data.map(() => new Animated.Value(0))
  ).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;

  // Calculate max value with safety checks
  const validValues = data.map(item => item.value).filter(v => typeof v === 'number' && !isNaN(v) && v > 0);
  const chartMaxValue = maxValue || (validValues.length > 0 ? Math.max(...validValues) : 1);
  const chartWidth = screenWidth - spacing[5] * 2 - spacing[5] * 2; // Account for container padding

  useEffect(() => {
    // Reset animations when data changes
    animatedValues.forEach(anim => anim.setValue(0));
    fadeAnim.setValue(0);

    // Start animations
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 400,
        delay: animationDelay,
        useNativeDriver: false,
      }),
      Animated.stagger(
        50,
        animatedValues.map(anim =>
          Animated.timing(anim, {
            toValue: 1,
            duration: animationDuration,
            delay: animationDelay + 200,
            useNativeDriver: false,
          })
        )
      ),
    ]).start();
  }, [data, animationDelay, animationDuration]);

  const renderVerticalBar = (item: BarChartData, index: number) => {
    // Safety checks for item values
    const safeValue = typeof item.value === 'number' && !isNaN(item.value) ? Math.max(0, item.value) : 0;
    
    const barWidth = (chartWidth - spacing[2] * (data.length - 1)) / data.length;
    const maxBarHeight = height - 60; // Account for labels
    const barHeight = chartMaxValue > 0 ? (safeValue / chartMaxValue) * maxBarHeight : 0;
    const color = item.color || barColors[index % barColors.length];

    const animatedHeight = animatedValues[index].interpolate({
      inputRange: [0, 1],
      outputRange: [0, barHeight],
    });

    const animatedOpacity = animatedValues[index].interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: [0, 0.7, 1],
    });

    return (
      <TouchableOpacity
        key={index}
        style={[styles.barContainer, { width: barWidth }]}
        onPress={() => onBarPress?.(item, index)}
        disabled={!onBarPress}
      >
        <View style={[styles.verticalBarWrapper, { height: maxBarHeight }]}>
          {showValues && (
            <Animated.Text
              style={[
                styles.barValue,
                {
                  color: theme.colors.text.primary,
                  opacity: animatedOpacity,
                  marginBottom: spacing[1],
                },
              ]}
            >
              {safeValue.toLocaleString()}
            </Animated.Text>
          )}
          
          <AnimatedView
            style={[
              styles.verticalBar,
              {
                height: animatedHeight,
                backgroundColor: color,
                opacity: animatedOpacity,
              },
            ]}
          >
            <LinearGradient
              colors={[`${color}FF`, `${color}CC`, `${color}99`]}
              style={styles.barGradient}
            />
          </AnimatedView>
        </View>
        
        <Text
          style={[
            styles.barLabel,
            { color: theme.colors.text.secondary },
          ]}
          numberOfLines={2}
        >
          {item.label}
        </Text>
        
        {item.description && (
          <Text
            style={[
              styles.barDescription,
              { color: theme.colors.text.tertiary },
            ]}
            numberOfLines={1}
          >
            {item.description}
          </Text>
        )}
      </TouchableOpacity>
    );
  };

  const renderHorizontalBar = (item: BarChartData, index: number) => {
    // Safety checks for item values
    const safeValue = typeof item.value === 'number' && !isNaN(item.value) ? Math.max(0, item.value) : 0;
    
    const barHeight = 32;
    const maxBarWidth = chartWidth - 100; // Account for labels
    const barWidth = chartMaxValue > 0 ? (safeValue / chartMaxValue) * maxBarWidth : 0;
    const color = item.color || barColors[index % barColors.length];

    const animatedWidth = animatedValues[index].interpolate({
      inputRange: [0, 1],
      outputRange: [0, barWidth],
    });

    const animatedOpacity = animatedValues[index].interpolate({
      inputRange: [0, 0.5, 1],
      outputRange: [0, 0.7, 1],
    });

    return (
      <TouchableOpacity
        key={index}
        style={styles.horizontalBarContainer}
        onPress={() => onBarPress?.(item, index)}
        disabled={!onBarPress}
      >
        <View style={styles.horizontalBarLabelContainer}>
          <Text
            style={[
              styles.horizontalBarLabel,
              { color: theme.colors.text.primary },
            ]}
            numberOfLines={1}
          >
            {item.label}
          </Text>
          {item.description && (
            <Text
              style={[
                styles.horizontalBarDescription,
                { color: theme.colors.text.tertiary },
              ]}
              numberOfLines={1}
            >
              {item.description}
            </Text>
          )}
        </View>
        
        <View style={styles.horizontalBarWrapper}>
          <AnimatedView
            style={[
              styles.horizontalBar,
              {
                width: animatedWidth,
                height: barHeight,
                backgroundColor: color,
                opacity: animatedOpacity,
              },
            ]}
          >
            <LinearGradient
              colors={[`${color}FF`, `${color}CC`, `${color}99`]}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
              style={styles.barGradient}
            />
          </AnimatedView>
          
          {showValues && (
            <Animated.Text
              style={[
                styles.horizontalBarValue,
                {
                  color: theme.colors.text.primary,
                  opacity: animatedOpacity,
                },
              ]}
            >
              {safeValue.toLocaleString()}
            </Animated.Text>
          )}
        </View>
      </TouchableOpacity>
    );
  };

  const renderGrid = () => {
    if (!showGrid || orientation === 'horizontal') return null;

    const gridLines = 5;
    const gridHeight = height - 60;
    const gridStep = gridHeight / gridLines;

    return (
      <View style={[styles.grid, { height: gridHeight }]}>
        {Array.from({ length: gridLines + 1 }).map((_, index) => {
          const value = (chartMaxValue / gridLines) * (gridLines - index);
          return (
            <View
              key={index}
              style={[
                styles.gridLine,
                {
                  top: index * gridStep,
                  borderTopColor: theme.colors.border.primary,
                },
              ]}
            >
              <Text
                style={[
                  styles.gridValue,
                  { color: theme.colors.text.tertiary },
                ]}
              >
                {Math.round(value).toLocaleString()}
              </Text>
            </View>
          );
        })}
      </View>
    );
  };

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: isDark
            ? theme.colors.background.secondary
            : theme.colors.background.elevated,
          opacity: fadeAnim,
        },
      ]}
    >
      <LinearGradient
        colors={[
          'rgba(168, 85, 247, 0.03)',
          'rgba(147, 51, 234, 0.02)',
          'transparent',
        ]}
        style={styles.gradient}
      >
        <Text style={[styles.title, { color: theme.colors.text.primary }]}>
          {title}
        </Text>

        <View style={[styles.chartContainer, { height }]}>
          {renderGrid()}
          
          {orientation === 'vertical' ? (
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.verticalChart}
            >
              <View style={styles.barsContainer}>
                {data.map(renderVerticalBar)}
              </View>
            </ScrollView>
          ) : (
            <ScrollView
              showsVerticalScrollIndicator={false}
              style={styles.horizontalChart}
            >
              <View style={styles.horizontalBarsContainer}>
                {data.map(renderHorizontalBar)}
              </View>
            </ScrollView>
          )}
        </View>
      </LinearGradient>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    marginVertical: spacing[2],
  },
  gradient: {
    padding: spacing[5],
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: spacing[4],
    textAlign: 'center',
  },
  chartContainer: {
    position: 'relative',
  },
  grid: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
  },
  gridLine: {
    position: 'absolute',
    left: 0,
    right: 0,
    borderTopWidth: 1,
    borderTopColor: 'transparent',
    opacity: 0.3,
  },
  gridValue: {
    fontSize: 10,
    position: 'absolute',
    left: -30,
    top: -6,
  },
  verticalChart: {
    flex: 1,
  },
  barsContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    gap: spacing[2],
    paddingHorizontal: spacing[2],
    paddingTop: spacing[4],
  },
  barContainer: {
    alignItems: 'center',
    minWidth: 60,
  },
  verticalBarWrapper: {
    justifyContent: 'flex-end',
    alignItems: 'center',
  },
  verticalBar: {
    borderRadius: borderRadius.md,
    minHeight: 4,
  },
  barGradient: {
    flex: 1,
    borderRadius: borderRadius.md,
  },
  barValue: {
    fontSize: 12,
    fontWeight: '600',
    textAlign: 'center',
  },
  barLabel: {
    fontSize: 12,
    fontWeight: '500',
    textAlign: 'center',
    marginTop: spacing[2],
  },
  barDescription: {
    fontSize: 10,
    textAlign: 'center',
    marginTop: spacing[1],
  },
  horizontalChart: {
    flex: 1,
  },
  horizontalBarsContainer: {
    gap: spacing[3],
    paddingVertical: spacing[2],
  },
  horizontalBarContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[3],
  },
  horizontalBarLabelContainer: {
    width: 80,
  },
  horizontalBarLabel: {
    fontSize: 12,
    fontWeight: '500',
  },
  horizontalBarDescription: {
    fontSize: 10,
    marginTop: spacing[0.5],
  },
  horizontalBarWrapper: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[2],
  },
  horizontalBar: {
    borderRadius: borderRadius.sm,
    minWidth: 4,
  },
  horizontalBarValue: {
    fontSize: 12,
    fontWeight: '600',
    minWidth: 40,
  },
});
</file>

<file path="src/components/charts/HeatMap.tsx">
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  TouchableOpacity,
  ScrollView,
  Dimensions,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useTheme } from '../../contexts/ThemeContext';
import { colors } from '../../styles/colors';
import { spacing, borderRadius } from '../../styles/theme';

const { width: screenWidth } = Dimensions.get('window');

export interface HeatMapData {
  date: Date;
  value: number;
  label?: string;
  description?: string;
}

export interface HeatMapProps {
  data: HeatMapData[];
  title: string;
  color?: string;
  maxValue?: number;
  showWeekdays?: boolean;
  showMonthLabels?: boolean;
  cellSize?: number;
  onCellPress?: (data: HeatMapData) => void;
  animationDuration?: number;
  animationDelay?: number;
  startDate?: Date;
  endDate?: Date;
}

const AnimatedView = Animated.createAnimatedComponent(View);
const AnimatedTouchableOpacity = Animated.createAnimatedComponent(TouchableOpacity);

export const HeatMap: React.FC<HeatMapProps> = ({
  data,
  title,
  color = colors.purple[500],
  maxValue,
  showWeekdays = true,
  showMonthLabels = true,
  cellSize = 16,
  onCellPress,
  animationDuration = 1000,
  animationDelay = 0,
  startDate,
  endDate,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  
  // Animation values
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const cellAnimations = useRef<{ [key: string]: Animated.Value }>({}).current;

  const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const months = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
  ];

  // Calculate date range
  const now = new Date();
  const defaultStartDate = new Date(now.getFullYear(), 0, 1); // Start of year
  const defaultEndDate = new Date(now.getFullYear(), 11, 31); // End of year
  
  const chartStartDate = startDate || defaultStartDate;
  const chartEndDate = endDate || defaultEndDate;

  // Calculate maximum value for intensity
  const chartMaxValue = maxValue || Math.max(...data.map(d => d.value), 1);

  // Create data map for quick lookup
  const dataMap = new Map<string, HeatMapData>();
  data.forEach(item => {
    const dateKey = item.date.toISOString().split('T')[0];
    dataMap.set(dateKey, item);
  });

  useEffect(() => {
    // Initialize cell animations
    const cellKeys = Object.keys(cellAnimations);
    cellKeys.forEach(key => {
      cellAnimations[key].setValue(0);
    });

    // Start animations
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 400,
        delay: animationDelay,
        useNativeDriver: false,
      }),
      Animated.stagger(
        5,
        Object.values(cellAnimations).map(anim =>
          Animated.timing(anim, {
            toValue: 1,
            duration: animationDuration,
            delay: animationDelay + 200,
            useNativeDriver: false,
          })
        )
      ),
    ]).start();
  }, [data, animationDelay, animationDuration]);

  // Generate calendar grid
  const generateCalendarGrid = () => {
    const grid: Array<Array<Date | null>> = [];
    const current = new Date(chartStartDate);
    
    // Start from the first Sunday of the week containing start date
    const startDayOfWeek = current.getDay();
    current.setDate(current.getDate() - startDayOfWeek);

    while (current <= chartEndDate) {
      const week: Array<Date | null> = [];
      
      for (let i = 0; i < 7; i++) {
        if (current >= chartStartDate && current <= chartEndDate) {
          week.push(new Date(current));
        } else {
          week.push(null);
        }
        current.setDate(current.getDate() + 1);
      }
      
      grid.push(week);
    }

    return grid;
  };

  // Get cell intensity based on value
  const getCellIntensity = (date: Date | null) => {
    if (!date) return 0;
    
    const dateKey = date.toISOString().split('T')[0];
    const cellData = dataMap.get(dateKey);
    
    if (!cellData) return 0;
    
    return cellData.value / chartMaxValue;
  };

  // Get cell color based on intensity
  const getCellColor = (intensity: number) => {
    if (intensity === 0) {
      return isDark ? '#1f2937' : '#f3f4f6'; // gray-800 : gray-100
    }
    
    const alpha = Math.max(0.1, intensity);
    return `${color}${Math.round(alpha * 255).toString(16).padStart(2, '0')}`;
  };

  // Get animation value for cell
  const getCellAnimation = (date: Date | null) => {
    if (!date) return new Animated.Value(1);
    
    const dateKey = date.toISOString().split('T')[0];
    
    if (!cellAnimations[dateKey]) {
      cellAnimations[dateKey] = new Animated.Value(0);
    }
    
    return cellAnimations[dateKey];
  };

  // Render calendar cell
  const renderCell = (date: Date | null, weekIndex: number, dayIndex: number) => {
    if (!date) {
      return (
        <View
          key={`empty-${weekIndex}-${dayIndex}`}
          style={[styles.cell, { width: cellSize, height: cellSize }]}
        />
      );
    }

    const dateKey = date.toISOString().split('T')[0];
    const cellData = dataMap.get(dateKey);
    const intensity = getCellIntensity(date);
    const cellColor = getCellColor(intensity);
    const animation = getCellAnimation(date);

    const animatedScale = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0.3, 1],
    });

    const animatedOpacity = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
    });

    return (
      <AnimatedTouchableOpacity
        key={dateKey}
        style={[
          styles.cell,
          {
            width: cellSize,
            height: cellSize,
            backgroundColor: cellColor,
            transform: [{ scale: animatedScale }],
            opacity: animatedOpacity,
          },
        ]}
        onPress={() => cellData && onCellPress?.(cellData)}
        disabled={!cellData || !onCellPress}
        activeOpacity={0.7}
      >
        {cellData && cellData.value > 0 && (
          <View style={styles.cellContent}>
            <Text style={[styles.cellText, { color: intensity > 0.5 ? 'white' : theme.colors.text.primary }]}>
              {date.getDate()}
            </Text>
          </View>
        )}
      </AnimatedTouchableOpacity>
    );
  };

  // Render month labels
  const renderMonthLabels = () => {
    if (!showMonthLabels) return null;

    const grid = generateCalendarGrid();
    const monthLabels: Array<{ month: string; x: number }> = [];
    let currentMonth = -1;
    let weekIndex = 0;

    grid.forEach((week, index) => {
      const firstValidDate = week.find(date => date !== null);
      if (firstValidDate) {
        const month = firstValidDate.getMonth();
        if (month !== currentMonth) {
          monthLabels.push({
            month: months[month],
            x: index * (cellSize + 2),
          });
          currentMonth = month;
        }
      }
    });

    return (
      <View style={styles.monthLabels}>
        {monthLabels.map((label, index) => (
          <Text
            key={index}
            style={[
              styles.monthLabel,
              {
                color: theme.colors.text.secondary,
                left: label.x,
              },
            ]}
          >
            {label.month}
          </Text>
        ))}
      </View>
    );
  };

  // Render weekday labels
  const renderWeekdayLabels = () => {
    if (!showWeekdays) return null;

    return (
      <View style={styles.weekdayLabels}>
        {weekdays.map((day, index) => (
          <Text
            key={day}
            style={[
              styles.weekdayLabel,
              {
                color: theme.colors.text.tertiary,
                height: cellSize,
                lineHeight: cellSize,
              },
            ]}
          >
            {day}
          </Text>
        ))}
      </View>
    );
  };

  // Render intensity legend
  const renderLegend = () => {
    const intensityLevels = [0, 0.25, 0.5, 0.75, 1];

    return (
      <View style={styles.legend}>
        <Text style={[styles.legendLabel, { color: theme.colors.text.tertiary }]}>
          Less
        </Text>
        <View style={styles.legendColors}>
          {intensityLevels.map((intensity, index) => (
            <View
              key={index}
              style={[
                styles.legendCell,
                {
                  backgroundColor: getCellColor(intensity),
                  width: cellSize * 0.8,
                  height: cellSize * 0.8,
                },
              ]}
            />
          ))}
        </View>
        <Text style={[styles.legendLabel, { color: theme.colors.text.tertiary }]}>
          More
        </Text>
      </View>
    );
  };

  const grid = generateCalendarGrid();

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: isDark
            ? theme.colors.background.secondary
            : theme.colors.background.elevated,
          opacity: fadeAnim,
        },
      ]}
    >
      <LinearGradient
        colors={[
          'rgba(168, 85, 247, 0.03)',
          'rgba(147, 51, 234, 0.02)',
          'transparent',
        ]}
        style={styles.gradient}
      >
        <Text style={[styles.title, { color: theme.colors.text.primary }]}>
          {title}
        </Text>

        <View style={styles.chartContainer}>
          {renderMonthLabels()}
          
          <View style={styles.calendarContainer}>
            {renderWeekdayLabels()}
            
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.calendarScroll}
            >
              <View style={styles.calendar}>
                {grid.map((week, weekIndex) => (
                  <View key={weekIndex} style={styles.week}>
                    {week.map((date, dayIndex) => 
                      renderCell(date, weekIndex, dayIndex)
                    )}
                  </View>
                ))}
              </View>
            </ScrollView>
          </View>

          {renderLegend()}
        </View>
      </LinearGradient>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    marginVertical: spacing[2],
  },
  gradient: {
    padding: spacing[5],
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: spacing[4],
    textAlign: 'center',
  },
  chartContainer: {
    gap: spacing[3],
  },
  monthLabels: {
    height: 20,
    position: 'relative',
    marginLeft: 40, // Account for weekday labels
  },
  monthLabel: {
    position: 'absolute',
    fontSize: 12,
    fontWeight: '500',
  },
  calendarContainer: {
    flexDirection: 'row',
  },
  weekdayLabels: {
    width: 40,
    gap: 2,
  },
  weekdayLabel: {
    fontSize: 10,
    textAlign: 'center',
    fontWeight: '500',
  },
  calendarScroll: {
    flex: 1,
  },
  calendar: {
    flexDirection: 'row',
    gap: 2,
  },
  week: {
    gap: 2,
  },
  cell: {
    borderRadius: borderRadius.xs,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cellContent: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cellText: {
    fontSize: 8,
    fontWeight: '600',
  },
  legend: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: spacing[2],
    marginTop: spacing[4],
  },
  legendLabel: {
    fontSize: 12,
  },
  legendColors: {
    flexDirection: 'row',
    gap: 2,
  },
  legendCell: {
    borderRadius: borderRadius.xs,
  },
});
</file>

<file path="src/components/charts/index.ts">
export { StatsCard, type StatsCardProps } from './StatsCard';
export { PieChart, type PieChartProps, type PieChartData } from './PieChart';
export { SimplePieChart, type SimplePieChartProps, type SimplePieChartData } from './SimplePieChart';
export { BarChart, type BarChartProps, type BarChartData } from './BarChart';
export { LineChart, type LineChartProps, type LineChartData } from './LineChart';
export { HeatMap, type HeatMapProps, type HeatMapData } from './HeatMap';
export { TopRankingList, type TopRankingListProps, type RankingItem } from './TopRankingList';
</file>

<file path="src/components/charts/LineChart.tsx">
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  Dimensions,
  TouchableOpacity,
} from 'react-native';
import Svg, { G, Path, Circle, Line, Text as SvgText, Defs, LinearGradient as SvgGradient, Stop } from 'react-native-svg';
import { LinearGradient } from 'expo-linear-gradient';
import { useTheme } from '../../contexts/ThemeContext';
import { colors } from '../../styles/colors';
import { spacing, borderRadius } from '../../styles/theme';

const { width: screenWidth } = Dimensions.get('window');

export interface LineChartData {
  x: string | number;
  y: number;
  label?: string;
}

export interface LineChartProps {
  data: LineChartData[];
  title: string;
  color?: string;
  showDots?: boolean;
  showGrid?: boolean;
  showLabels?: boolean;
  height?: number;
  onPointPress?: (point: LineChartData, index: number) => void;
  animationDuration?: number;
  animationDelay?: number;
  showGradient?: boolean;
  strokeWidth?: number;
}

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedG = Animated.createAnimatedComponent(G);

export const LineChart: React.FC<LineChartProps> = ({
  data,
  title,
  color = colors.purple[500],
  showDots = true,
  showGrid = true,
  showLabels = true,
  height = 250,
  onPointPress,
  animationDuration = 1200,
  animationDelay = 0,
  showGradient = true,
  strokeWidth = 3,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  
  // Early return for invalid data
  if (!data || !Array.isArray(data) || data.length === 0) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background.card }]}>
        <LinearGradient colors={['rgba(168, 85, 247, 0.03)', 'rgba(147, 51, 234, 0.02)', 'transparent']} style={styles.gradient}>
          <Text style={[styles.title, { color: theme.colors.text.primary }]}>{title}</Text>
          <Text style={[styles.title, { color: theme.colors.text.secondary, fontSize: 14 }]}>No data available</Text>
        </LinearGradient>
      </View>
    );
  }
  
  // Animation values
  const pathAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const dotsAnim = useRef(new Animated.Value(0)).current;

  const chartWidth = screenWidth - spacing[5] * 4; // Account for container padding
  const chartHeight = height - 80; // Account for labels and padding
  const padding = 40;

  // Calculate chart bounds with safety checks
  const values = data.map(d => d.y).filter(y => typeof y === 'number' && !isNaN(y));
  const minY = values.length > 0 ? Math.min(...values) : 0;
  const maxY = values.length > 0 ? Math.max(...values) : 0;
  const yRange = maxY - minY || 1;

  useEffect(() => {
    // Reset animations
    pathAnim.setValue(0);
    fadeAnim.setValue(0);
    dotsAnim.setValue(0);

    // Start animations
    Animated.sequence([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 400,
        delay: animationDelay,
        useNativeDriver: false,
      }),
      Animated.timing(pathAnim, {
        toValue: 1,
        duration: animationDuration,
        delay: animationDelay + 200,
        useNativeDriver: false,
      }),
      Animated.timing(dotsAnim, {
        toValue: 1,
        duration: 600,
        delay: animationDelay + 400,
        useNativeDriver: false,
      }),
    ]).start();
  }, [data, animationDelay, animationDuration]);

  // Convert data points to SVG coordinates
  const getPointCoordinates = (index: number, value: number) => {
    // Safety checks for invalid values
    if (typeof value !== 'number' || isNaN(value)) {
      value = 0;
    }
    
    const x = data.length > 1 
      ? padding + (index / (data.length - 1)) * (chartWidth - padding * 2)
      : chartWidth / 2; // Center single point
    const y = padding + ((maxY - value) / yRange) * (chartHeight - padding * 2);
    
    // Ensure coordinates are valid numbers
    return { 
      x: isNaN(x) ? chartWidth / 2 : x, 
      y: isNaN(y) ? chartHeight / 2 : y 
    };
  };

  // Create SVG path for the line
  const createPath = () => {
    if (data.length === 0) return '';

    let path = '';
    data.forEach((point, index) => {
      const { x, y } = getPointCoordinates(index, point.y);
      
      // Safety check for coordinates
      if (isNaN(x) || isNaN(y)) return;
      
      if (index === 0) {
        path += `M ${x} ${y}`;
      } else {
        // Use smooth curves
        const prevPoint = getPointCoordinates(index - 1, data[index - 1].y);
        const controlX = (prevPoint.x + x) / 2;
        
        // Safety check for control point
        if (!isNaN(controlX) && !isNaN(prevPoint.y)) {
          path += ` Q ${controlX} ${prevPoint.y} ${x} ${y}`;
        } else {
          path += ` L ${x} ${y}`;
        }
      }
    });

    return path;
  };

  // Create gradient area path
  const createGradientPath = () => {
    if (data.length === 0) return '';

    let path = createPath();
    
    // Close the path for gradient fill
    const lastPoint = getPointCoordinates(data.length - 1, data[data.length - 1].y);
    const firstPoint = getPointCoordinates(0, data[0].y);
    
    // Safety checks for closing coordinates
    if (!isNaN(lastPoint.x) && !isNaN(firstPoint.x)) {
      path += ` L ${lastPoint.x} ${chartHeight - padding}`;
      path += ` L ${firstPoint.x} ${chartHeight - padding}`;
      path += ' Z';
    }

    return path;
  };

  // Render grid lines
  const renderGrid = () => {
    if (!showGrid) return null;

    const gridLines = 5;
    const yStep = (chartHeight - padding * 2) / gridLines;
    const xStep = (chartWidth - padding * 2) / Math.max(data.length - 1, 1);

    return (
      <G opacity={0.2}>
        {/* Horizontal grid lines */}
        {Array.from({ length: gridLines + 1 }).map((_, index) => {
          const y = padding + index * yStep;
          const value = maxY - (index * yRange) / gridLines;
          
          return (
            <G key={`h-${index}`}>
              <Line
                x1={padding}
                y1={y}
                x2={chartWidth - padding}
                y2={y}
                stroke={isDark ? '#374151' : '#d1d5db'} // gray-700 : gray-300
                strokeWidth={1}
              />
              {showLabels && (
                <SvgText
                  x={padding - 8}
                  y={y + 4}
                  fontSize="10"
                  fill={theme.colors.text.tertiary}
                  textAnchor="end"
                >
                  {Math.round(value).toLocaleString()}
                </SvgText>
              )}
            </G>
          );
        })}

        {/* Vertical grid lines */}
        {data.map((point, index) => {
          const x = padding + index * xStep;
          
          return (
            <G key={`v-${index}`}>
              <Line
                x1={x}
                y1={padding}
                x2={x}
                y2={chartHeight - padding}
                stroke={isDark ? '#374151' : '#d1d5db'} // gray-700 : gray-300
                strokeWidth={1}
              />
              {showLabels && index % Math.ceil(data.length / 6) === 0 && (
                <SvgText
                  x={x}
                  y={chartHeight - padding + 20}
                  fontSize="10"
                  fill={theme.colors.text.tertiary}
                  textAnchor="middle"
                >
                  {point.label || point.x}
                </SvgText>
              )}
            </G>
          );
        })}
      </G>
    );
  };

  // Render data points
  const renderDots = () => {
    if (!showDots) return null;

    return data.map((point, index) => {
      const { x, y } = getPointCoordinates(index, point.y);
      
      return (
        <TouchableOpacity
          key={index}
          onPress={() => onPointPress?.(point, index)}
          disabled={!onPointPress}
        >
          <AnimatedG opacity={dotsAnim}>
            <Circle
              cx={x}
              cy={y}
              r={6}
              fill={color}
              stroke={isDark ? '#111827' : '#f9fafb'} // gray-900 : gray-50
              strokeWidth={2}
            />
            <Circle
              cx={x}
              cy={y}
              r={3}
              fill={isDark ? '#111827' : '#f9fafb'} // gray-900 : gray-50
            />
          </AnimatedG>
        </TouchableOpacity>
      );
    });
  };

  const animatedPathLength = pathAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1000], // Approximate path length
  });

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: isDark
            ? theme.colors.background.secondary
            : theme.colors.background.elevated,
          opacity: fadeAnim,
        },
      ]}
    >
      <LinearGradient
        colors={[
          'rgba(168, 85, 247, 0.03)',
          'rgba(147, 51, 234, 0.02)',
          'transparent',
        ]}
        style={styles.gradient}
      >
        <Text style={[styles.title, { color: theme.colors.text.primary }]}>
          {title}
        </Text>

        <View style={[styles.chartContainer, { height }]}>
          <Svg width={chartWidth} height={chartHeight}>
            <Defs>
              <SvgGradient id="lineGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <Stop offset="0%" stopColor={color} stopOpacity="0.4" />
                <Stop offset="100%" stopColor={color} stopOpacity="0.1" />
              </SvgGradient>
            </Defs>

            {renderGrid()}

            {/* Gradient area */}
            {showGradient && (
              <AnimatedPath
                d={createGradientPath()}
                fill="url(#lineGradient)"
                opacity={pathAnim}
              />
            )}

            {/* Main line */}
            <AnimatedPath
              d={createPath()}
              stroke={color}
              strokeWidth={strokeWidth}
              fill="none"
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeDasharray={[1000]}
              strokeDashoffset={animatedPathLength.interpolate({
                inputRange: [0, 1000],
                outputRange: [1000, 0],
              })}
            />

            {renderDots()}
          </Svg>
        </View>

        {/* Legend */}
        <View style={styles.legend}>
          <View style={styles.legendItem}>
            <View style={[styles.legendColor, { backgroundColor: color }]} />
            <Text style={[styles.legendText, { color: theme.colors.text.secondary }]}>
              {data.length} data points
            </Text>
          </View>
          
          <View style={styles.legendStats}>
            <Text style={[styles.legendStat, { color: theme.colors.text.tertiary }]}>
              Min: {minY.toLocaleString()}
            </Text>
            <Text style={[styles.legendStat, { color: theme.colors.text.tertiary }]}>
              Max: {maxY.toLocaleString()}
            </Text>
            <Text style={[styles.legendStat, { color: theme.colors.text.tertiary }]}>
              Avg: {data.length > 0 ? Math.round(data.reduce((sum, d) => sum + d.y, 0) / data.length).toLocaleString() : '0'}
            </Text>
          </View>
        </View>
      </LinearGradient>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    marginVertical: spacing[2],
  },
  gradient: {
    padding: spacing[5],
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: spacing[4],
    textAlign: 'center',
  },
  chartContainer: {
    alignItems: 'center',
    marginBottom: spacing[4],
  },
  legend: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[2],
  },
  legendColor: {
    width: 12,
    height: 12,
    borderRadius: borderRadius.full,
  },
  legendText: {
    fontSize: 14,
    fontWeight: '500',
  },
  legendStats: {
    flexDirection: 'row',
    gap: spacing[4],
  },
  legendStat: {
    fontSize: 12,
  },
});
</file>

<file path="src/components/charts/PieChart.tsx">
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import Svg, { G, Path, Text as SvgText } from 'react-native-svg';
import { LinearGradient } from 'expo-linear-gradient';
import { useTheme } from '../../contexts/ThemeContext';
import { colors } from '../../styles/colors';
import { spacing, borderRadius } from '../../styles/theme';

export interface PieChartData {
  label: string;
  value: number;
  color: string;
  percentage?: number;
}

export interface PieChartProps {
  data: PieChartData[];
  title: string;
  size?: number;
  innerRadius?: number;
  showPercentages?: boolean;
  showLegend?: boolean;
  onSegmentPress?: (segment: PieChartData, index: number) => void;
  animationDuration?: number;
  animationDelay?: number;
}

export const PieChart: React.FC<PieChartProps> = ({
  data,
  title,
  size = 200,
  innerRadius = 0,
  showPercentages = true,
  showLegend = true,
  onSegmentPress,
  animationDuration = 1000,
  animationDelay = 0,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  
  // Early return for invalid data
  if (!data || !Array.isArray(data) || data.length === 0) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background.card }]}>
        <View style={styles.gradient}>
          <Text style={[styles.title, { color: theme.colors.text.primary }]}>
            {title}
          </Text>
          <Text style={[styles.emptyMessage, { color: theme.colors.text.secondary }]}>
            No data available
          </Text>
        </View>
      </View>
    );
  }
  
  // Removed animation values to prevent interpolation errors

  // Calculate total and percentages with safety checks
  const total = data.reduce((sum, item) => {
    const value = typeof item.value === 'number' && !isNaN(item.value) ? item.value : 0;
    return sum + value;
  }, 0);
  
  const dataWithPercentages = data
    .filter(item => typeof item.value === 'number' && !isNaN(item.value) && item.value > 0)
    .map(item => ({
      ...item,
      value: Math.max(0, item.value), // Ensure positive values
      percentage: total > 0 ? (item.value / total) * 100 : 0,
    }));

  // Removed animation useEffect to avoid interpolation issues

  // Create SVG path for each segment with comprehensive safety checks
  const createPath = (startAngle: number, endAngle: number, radius: number) => {
    try {
      // Safety checks for NaN values and edge cases
      if (isNaN(startAngle) || isNaN(endAngle) || isNaN(radius) || 
          radius <= 0 || !isFinite(startAngle) || !isFinite(endAngle) || !isFinite(radius)) {
        return `M 0 0 L 0 0 Z`; // Return minimal safe path
      }

      // Additional angle validation
      if (Math.abs(endAngle - startAngle) < 0.01) {
        return `M 0 0 L 0 0 Z`; // Too small to render
      }

      const center = size / 2;
      
      // Clamp angles to prevent extreme values
      const clampedStartAngle = Math.max(-720, Math.min(720, startAngle));
      const clampedEndAngle = Math.max(-720, Math.min(720, endAngle));
      
      const startAngleRad = (clampedStartAngle - 90) * (Math.PI / 180);
      const endAngleRad = (clampedEndAngle - 90) * (Math.PI / 180);

      const x1 = center + radius * Math.cos(startAngleRad);
      const y1 = center + radius * Math.sin(startAngleRad);
      const x2 = center + radius * Math.cos(endAngleRad);
      const y2 = center + radius * Math.sin(endAngleRad);

      // Check for NaN and extreme values in calculated coordinates
      if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2) ||
          !isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2) ||
          Math.abs(x1) > 10000 || Math.abs(y1) > 10000 || 
          Math.abs(x2) > 10000 || Math.abs(y2) > 10000) {
        return `M 0 0 L 0 0 Z`;
      }

      const angleDiff = clampedEndAngle - clampedStartAngle;
      const largeArcFlag = Math.abs(angleDiff) <= 180 ? 0 : 1;

      // Format coordinates to avoid floating point precision issues
      const formatCoord = (coord: number) => Math.round(coord * 100) / 100;

      let path = `M ${formatCoord(center)} ${formatCoord(center)} L ${formatCoord(x1)} ${formatCoord(y1)} A ${formatCoord(radius)} ${formatCoord(radius)} 0 ${largeArcFlag} 1 ${formatCoord(x2)} ${formatCoord(y2)} Z`;

      // Add inner radius for donut chart
      if (innerRadius > 0 && !isNaN(innerRadius) && innerRadius < radius) {
        const ix1 = center + innerRadius * Math.cos(startAngleRad);
        const iy1 = center + innerRadius * Math.sin(startAngleRad);
        const ix2 = center + innerRadius * Math.cos(endAngleRad);
        const iy2 = center + innerRadius * Math.sin(endAngleRad);

        // Check for NaN in inner coordinates with additional validations
        if (!isNaN(ix1) && !isNaN(iy1) && !isNaN(ix2) && !isNaN(iy2) &&
            isFinite(ix1) && isFinite(iy1) && isFinite(ix2) && isFinite(iy2)) {
          path = `M ${formatCoord(x1)} ${formatCoord(y1)} A ${formatCoord(radius)} ${formatCoord(radius)} 0 ${largeArcFlag} 1 ${formatCoord(x2)} ${formatCoord(y2)} L ${formatCoord(ix2)} ${formatCoord(iy2)} A ${formatCoord(innerRadius)} ${formatCoord(innerRadius)} 0 ${largeArcFlag} 0 ${formatCoord(ix1)} ${formatCoord(iy1)} Z`;
        }
      }

      return path;
    } catch (error) {
      console.error('Error in createPath:', error);
      return `M 0 0 L 0 0 Z`; // Return safe fallback
    }
  };

  // Calculate positions for percentage labels with safety checks
  const getLabelPosition = (startAngle: number, endAngle: number) => {
    if (isNaN(startAngle) || isNaN(endAngle)) {
      return { x: 0, y: 0 };
    }

    const center = size / 2;
    const middleAngle = (startAngle + endAngle) / 2;
    const labelRadius = (size / 2 - innerRadius) / 2 + innerRadius;
    const angleRad = (middleAngle - 90) * (Math.PI / 180);

    const x = center + labelRadius * Math.cos(angleRad);
    const y = center + labelRadius * Math.sin(angleRad);

    return {
      x: isNaN(x) ? center : x,
      y: isNaN(y) ? center : y,
    };
  };

  // Render segments with safety checks
  const renderSegments = () => {
    if (total <= 0 || dataWithPercentages.length === 0) {
      return null; // Don't render anything if no valid data
    }

    let currentAngle = 0;

    return dataWithPercentages.map((item, index) => {
      // Safety checks for item values
      if (!item || typeof item.value !== 'number' || isNaN(item.value) || item.value <= 0) {
        return null;
      }

      const angle = (item.value / total) * 360;
      
      // Safety check for calculated angle
      if (isNaN(angle) || angle <= 0) {
        return null;
      }

      const startAngle = currentAngle;
      const endAngle = currentAngle + angle;
      
      // Create the segment path (no animation to avoid interpolation issues)
      const segmentPath = createPath(startAngle, endAngle, size / 2);
      
      // Validate path before rendering
      if (!segmentPath || segmentPath.includes('NaN') || segmentPath.includes('Infinity')) {
        console.warn('Invalid path generated, skipping segment:', { startAngle, endAngle, size });
        return null;
      }
      
      // Debug logging for visibility issues
      console.log('PieChart segment:', {
        index,
        item: item.label,
        value: item.value,
        color: item.color,
        angle,
        startAngle,
        endAngle,
        path: segmentPath.substring(0, 50) + '...'
      });

      const labelPos = getLabelPosition(startAngle, endAngle);
      
      currentAngle += angle;

      return (
        <G key={`segment-${index}`}>
          <TouchableOpacity
            onPress={() => onSegmentPress?.(item, index)}
            disabled={!onSegmentPress}
          >
            {/* Simple static path rendering - no animation to avoid interpolation errors */}
            <Path
              d={segmentPath}
              fill={item.color || '#9333ea'}
              stroke="#ffffff"
              strokeWidth={3}
              opacity={1}
            />
          </TouchableOpacity>
          
          {showPercentages && item.percentage > 5 && !isNaN(labelPos.x) && !isNaN(labelPos.y) && (
            <SvgText
              x={labelPos.x}
              y={labelPos.y}
              fontSize="16"
              fontWeight="700"
              fill="#ffffff"
              textAnchor="middle"
              alignmentBaseline="middle"
              stroke="#000000"
              strokeWidth={0.5}
            >
              {item.percentage.toFixed(0)}%
            </SvgText>
          )}
        </G>
      );
    }).filter(Boolean); // Remove null items
  };

  // Render legend
  const renderLegend = () => {
    if (!showLegend) return null;

    return (
      <View style={styles.legend}>
        {dataWithPercentages.map((item, index) => (
          <TouchableOpacity
            key={index}
            style={styles.legendItem}
            onPress={() => onSegmentPress?.(item, index)}
            disabled={!onSegmentPress}
          >
            <View style={[styles.legendColor, { backgroundColor: item.color }]} />
            <View style={styles.legendText}>
              <Text style={[styles.legendLabel, { color: theme.colors.text.primary }]}>
                {item.label}
              </Text>
              <Text style={[styles.legendValue, { color: theme.colors.text.secondary }]}>
                {item.value.toLocaleString()} ({item.percentage.toFixed(1)}%)
              </Text>
            </View>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  return (
    <View
      style={[
        styles.container,
        {
          backgroundColor: isDark
            ? theme.colors.background.secondary
            : theme.colors.background.card,
        },
      ]}
    >
      <LinearGradient
        colors={[
          'rgba(168, 85, 247, 0.03)',
          'rgba(147, 51, 234, 0.02)',
          'transparent',
        ]}
        style={styles.gradient}
      >
        <Text style={[styles.title, { color: theme.colors.text.primary }]}>
          {title}
        </Text>

        <View style={styles.chartContainer}>
          <Svg 
            width={size} 
            height={size}
            viewBox={`0 0 ${size} ${size}`}
          >
            <G>
              {renderSegments()}
            </G>
            
            {/* Center total for donut charts */}
            {innerRadius > 0 && (
              <G>
                <SvgText
                  x={size / 2}
                  y={size / 2 - 8}
                  fontSize="24"
                  fontWeight="700"
                  fill={theme.colors.text.primary}
                  textAnchor="middle"
                  alignmentBaseline="middle"
                >
                  {total.toLocaleString()}
                </SvgText>
                <SvgText
                  x={size / 2}
                  y={size / 2 + 12}
                  fontSize="14"
                  fill={theme.colors.text.secondary}
                  textAnchor="middle"
                  alignmentBaseline="middle"
                >
                  Total
                </SvgText>
              </G>
            )}
          </Svg>
        </View>

        {renderLegend()}
      </LinearGradient>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    marginVertical: spacing[2],
  },
  gradient: {
    padding: spacing[5],
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: spacing[4],
    textAlign: 'center',
  },
  chartContainer: {
    alignItems: 'center',
    marginBottom: spacing[4],
    paddingVertical: spacing[3],
  },
  legend: {
    gap: spacing[3],
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[3],
  },
  legendColor: {
    width: 16,
    height: 16,
    borderRadius: borderRadius.full,
  },
  legendText: {
    flex: 1,
  },
  legendLabel: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: spacing[0.5],
  },
  legendValue: {
    fontSize: 12,
  },
  emptyMessage: {
    fontSize: 14,
    textAlign: 'center',
    marginTop: spacing[4],
  },
});
</file>

<file path="src/components/charts/SimplePieChart.tsx">
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useTheme } from '../../contexts/ThemeContext';
import { colors } from '../../styles/colors';
import { spacing, borderRadius } from '../../styles/theme';

export interface SimplePieChartData {
  label: string;
  value: number;
  color: string;
  percentage?: number;
}

export interface SimplePieChartProps {
  data: SimplePieChartData[];
  title: string;
  size?: number;
  showLegend?: boolean;
  onSegmentPress?: (segment: SimplePieChartData, index: number) => void;
}

export const SimplePieChart: React.FC<SimplePieChartProps> = ({
  data,
  title,
  size = 200,
  showLegend = true,
  onSegmentPress,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  
  // Early return for invalid data
  if (!data || !Array.isArray(data) || data.length === 0) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background.card }]}>
        <LinearGradient
          colors={[
            'rgba(168, 85, 247, 0.03)',
            'rgba(147, 51, 234, 0.02)',
            'transparent',
          ]}
          style={styles.gradient}
        >
          <Text style={[styles.title, { color: theme.colors.text.primary }]}>
            {title}
          </Text>
          <Text style={[styles.emptyMessage, { color: theme.colors.text.secondary }]}>
            No data available
          </Text>
        </LinearGradient>
      </View>
    );
  }

  // Calculate total and percentages
  const total = data.reduce((sum, item) => {
    const value = typeof item.value === 'number' && !isNaN(item.value) ? item.value : 0;
    return sum + value;
  }, 0);
  
  const dataWithPercentages = data
    .filter(item => typeof item.value === 'number' && !isNaN(item.value) && item.value > 0)
    .map(item => ({
      ...item,
      value: Math.max(0, item.value),
      percentage: total > 0 ? (item.value / total) * 100 : 0,
    }));

  // Create pie segments using CSS-like approach
  const renderPieChart = () => {
    const radius = size / 2;
    const segments = [];
    let currentAngle = 0;

    dataWithPercentages.forEach((item, index) => {
      const percentage = item.percentage;
      const angle = (percentage / 100) * 360;
      
      // Use CSS conic-gradient approach with Views
      segments.push(
        <TouchableOpacity
          key={index}
          onPress={() => onSegmentPress?.(item, index)}
          disabled={!onSegmentPress}
          style={[
            styles.segment,
            {
              position: 'absolute',
              width: size,
              height: size,
              borderRadius: size / 2,
              backgroundColor: item.color,
              transform: [
                { rotate: `${currentAngle}deg` },
              ],
            },
          ]}
        >
          {/* Segment slice using clip path simulation */}
          <View
            style={[
              styles.segmentSlice,
              {
                width: size,
                height: size,
                borderRadius: size / 2,
                backgroundColor: item.color,
                // Use overflow hidden to create slice effect
              },
            ]}
          />
        </TouchableOpacity>
      );
      
      currentAngle += angle;
    });

    return segments;
  };

  // Render using simple colored bars instead of complex pie
  const renderSimpleBars = () => {
    return dataWithPercentages.map((item, index) => (
      <TouchableOpacity
        key={index}
        onPress={() => onSegmentPress?.(item, index)}
        disabled={!onSegmentPress}
        style={[
          styles.barContainer,
          {
            backgroundColor: item.color,
            width: `${item.percentage}%`,
            minWidth: 60,
            height: 40,
            marginVertical: 4,
            borderRadius: 8,
            justifyContent: 'center',
            alignItems: 'center',
          },
        ]}
      >
        <Text style={[styles.barText, { color: '#ffffff', fontWeight: '600' }]}>
          {item.label}
        </Text>
        <Text style={[styles.barPercentage, { color: '#ffffff', fontSize: 12 }]}>
          {item.percentage.toFixed(1)}%
        </Text>
      </TouchableOpacity>
    ));
  };

  // Render legend
  const renderLegend = () => {
    if (!showLegend) return null;

    return (
      <View style={styles.legend}>
        {dataWithPercentages.map((item, index) => (
          <TouchableOpacity
            key={index}
            style={styles.legendItem}
            onPress={() => onSegmentPress?.(item, index)}
            disabled={!onSegmentPress}
          >
            <View style={[styles.legendColor, { backgroundColor: item.color }]} />
            <View style={styles.legendText}>
              <Text style={[styles.legendLabel, { color: theme.colors.text.primary }]}>
                {item.label}
              </Text>
              <Text style={[styles.legendValue, { color: theme.colors.text.secondary }]}>
                {item.value.toLocaleString()} ({item.percentage.toFixed(1)}%)
              </Text>
            </View>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  return (
    <View
      style={[
        styles.container,
        {
          backgroundColor: isDark
            ? theme.colors.background.secondary
            : theme.colors.background.card,
        },
      ]}
    >
      <LinearGradient
        colors={[
          'rgba(168, 85, 247, 0.03)',
          'rgba(147, 51, 234, 0.02)',
          'transparent',
        ]}
        style={styles.gradient}
      >
        <Text style={[styles.title, { color: theme.colors.text.primary }]}>
          {title}
        </Text>

        <View style={styles.chartContainer}>
          {/* Use simple horizontal bars instead of complex pie chart */}
          <View style={styles.barsContainer}>
            {renderSimpleBars()}
          </View>
        </View>

        {renderLegend()}
      </LinearGradient>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    marginVertical: spacing[2],
  },
  gradient: {
    padding: spacing[5],
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: spacing[4],
    textAlign: 'center',
  },
  chartContainer: {
    alignItems: 'center',
    marginBottom: spacing[4],
    paddingVertical: spacing[3],
  },
  barsContainer: {
    width: '100%',
    alignItems: 'flex-start',
  },
  barContainer: {
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
  },
  barText: {
    fontSize: 14,
    fontWeight: '600',
  },
  barPercentage: {
    fontSize: 12,
    marginTop: 2,
  },
  segment: {
    // For potential future pie implementation
  },
  segmentSlice: {
    // For potential future pie implementation
  },
  legend: {
    gap: spacing[3],
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[3],
  },
  legendColor: {
    width: 16,
    height: 16,
    borderRadius: borderRadius.full,
  },
  legendText: {
    flex: 1,
  },
  legendLabel: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: spacing[0.5],
  },
  legendValue: {
    fontSize: 12,
  },
  emptyMessage: {
    fontSize: 14,
    textAlign: 'center',
    marginTop: spacing[4],
  },
});
</file>

<file path="src/components/charts/StatsCard.tsx">
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  TouchableOpacity,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../../contexts/ThemeContext';
import { colors } from '../../styles/colors';
import { spacing, borderRadius } from '../../styles/theme';

export interface StatsCardProps {
  title: string;
  value: string | number;
  previousValue?: string | number;
  icon: keyof typeof Ionicons.glyphMap;
  color?: string;
  trend?: 'up' | 'down' | 'neutral';
  subtitle?: string;
  onPress?: () => void;
  animationDelay?: number;
}

export const StatsCard: React.FC<StatsCardProps> = ({
  title,
  value,
  previousValue,
  icon,
  color = colors.purple[500],
  trend,
  subtitle,
  onPress,
  animationDelay = 0,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  
  // Animation values
  const scaleAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(30)).current;

  useEffect(() => {
    const animation = Animated.parallel([
      Animated.timing(scaleAnim, {
        toValue: 1,
        duration: 600,
        delay: animationDelay,
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 400,
        delay: animationDelay + 100,
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 500,
        delay: animationDelay + 50,
        useNativeDriver: true,
      }),
    ]);

    animation.start();
  }, [animationDelay]);

  // Calculate percentage change
  const calculateChange = () => {
    if (!previousValue || !value) return null;
    
    const current = typeof value === 'string' ? parseFloat(value) || 0 : value;
    const previous = typeof previousValue === 'string' ? parseFloat(previousValue) || 0 : previousValue;
    
    if (previous === 0) return null;
    
    const change = ((current - previous) / previous) * 100;
    return {
      percentage: Math.abs(change).toFixed(1),
      direction: change > 0 ? 'up' : change < 0 ? 'down' : 'neutral',
    };
  };

  const change = calculateChange();
  const trendDirection = trend || change?.direction || 'neutral';

  const getTrendColor = () => {
    switch (trendDirection) {
      case 'up':
        return colors.semantic.success.main;
      case 'down':
        return colors.semantic.error.main;
      default:
        return theme.colors.text.tertiary;
    }
  };

  const getTrendIcon = () => {
    switch (trendDirection) {
      case 'up':
        return 'trending-up';
      case 'down':
        return 'trending-down';
      default:
        return 'remove';
    }
  };

  const CardContent = () => (
    <LinearGradient
      colors={[
        `${color}08`,
        `${color}04`,
        'transparent'
      ]}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 1 }}
      style={styles.gradient}
    >
      <View style={styles.header}>
        <View style={[styles.iconContainer, { backgroundColor: `${color}15` }]}>
          <Ionicons
            name={icon}
            size={24}
            color={color}
          />
        </View>
        
        {(change || trend) && (
          <View style={[styles.trendContainer, { backgroundColor: `${getTrendColor()}15` }]}>
            <Ionicons
              name={getTrendIcon()}
              size={12}
              color={getTrendColor()}
            />
            {change && (
              <Text style={[styles.trendText, { color: getTrendColor() }]}>
                {change.percentage}%
              </Text>
            )}
          </View>
        )}
      </View>

      <Animated.View style={{ transform: [{ translateY: slideAnim }] }}>
        <Text style={[styles.value, { color: theme.colors.text.primary }]}>
          {typeof value === 'number' ? value.toLocaleString() : value}
        </Text>
        
        <Text style={[styles.title, { color: theme.colors.text.secondary }]}>
          {title}
        </Text>
        
        {subtitle && (
          <Text style={[styles.subtitle, { color: theme.colors.text.tertiary }]}>
            {subtitle}
          </Text>
        )}
      </Animated.View>
    </LinearGradient>
  );

  const cardStyle = [
    styles.container,
    {
      backgroundColor: isDark
        ? theme.colors.background.secondary
        : theme.colors.background.elevated,
    },
  ];

  if (onPress) {
    return (
      <Animated.View
        style={[
          cardStyle,
          {
            transform: [{ scale: scaleAnim }],
            opacity: fadeAnim,
          },
        ]}
      >
        <TouchableOpacity
          onPress={onPress}
          style={styles.touchable}
          activeOpacity={0.7}
        >
          <CardContent />
        </TouchableOpacity>
      </Animated.View>
    );
  }

  return (
    <Animated.View
      style={[
        cardStyle,
        {
          transform: [{ scale: scaleAnim }],
          opacity: fadeAnim,
        },
      ]}
    >
      <CardContent />
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    minHeight: 140,
  },
  touchable: {
    flex: 1,
  },
  gradient: {
    flex: 1,
    padding: spacing[4],
    justifyContent: 'space-between',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: spacing[3],
  },
  iconContainer: {
    width: 48,
    height: 48,
    borderRadius: borderRadius.xl,
    justifyContent: 'center',
    alignItems: 'center',
  },
  trendContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[2],
    paddingVertical: spacing[1],
    borderRadius: borderRadius.pill,
    gap: spacing[1],
  },
  trendText: {
    fontSize: 11,
    fontWeight: '600',
  },
  value: {
    fontSize: 32,
    fontWeight: '700',
    marginBottom: spacing[1],
    lineHeight: 36,
  },
  title: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: spacing[0.5],
  },
  subtitle: {
    fontSize: 12,
    fontWeight: '400',
  },
});
</file>

<file path="src/components/charts/TopRankingList.tsx">
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  TouchableOpacity,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../../contexts/ThemeContext';
import { colors } from '../../styles/colors';
import { spacing, borderRadius } from '../../styles/theme';

export interface RankingItem {
  id: string;
  name: string;
  value: number;
  subtitle?: string;
  description?: string;
  color?: string;
  icon?: keyof typeof Ionicons.glyphMap;
  trend?: 'up' | 'down' | 'neutral';
  badge?: string;
}

export interface TopRankingListProps {
  data: RankingItem[];
  title: string;
  maxValue?: number;
  showProgress?: boolean;
  showTrend?: boolean;
  showIcons?: boolean;
  limit?: number;
  onItemPress?: (item: RankingItem, index: number) => void;
  animationDuration?: number;
  animationDelay?: number;
  colors?: string[];
}

// Default color palette with additional colors
const defaultColorPalette = [
  colors.purple[500],
  '#3b82f6', // blue
  '#22c55e', // green
  '#facc15', // yellow
  '#ef4444', // red
  '#06b6d4', // cyan
  '#ec4899', // pink
  '#f59e0b', // amber
  '#8b5cf6', // violet
  '#10b981', // emerald
];

const AnimatedView = Animated.createAnimatedComponent(View);
const AnimatedTouchableOpacity = Animated.createAnimatedComponent(TouchableOpacity);

export const TopRankingList: React.FC<TopRankingListProps> = ({
  data,
  title,
  maxValue,
  showProgress = true,
  showTrend = true,
  showIcons = true,
  limit = 10,
  onItemPress,
  animationDuration = 600,
  animationDelay = 0,
  colors: customColors = defaultColorPalette,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  
  // Animation values
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const displayData = data.slice(0, limit);
  const itemAnimations = useRef<Animated.Value[]>([]).current;
  
  // Ensure animation array matches data length
  if (itemAnimations.length !== displayData.length) {
    itemAnimations.length = 0;
    displayData.forEach(() => {
      itemAnimations.push(new Animated.Value(0));
    });
  }

  const chartMaxValue = maxValue || (data.length > 0 ? Math.max(...data.map(item => item?.value || 0), 1) : 1);

  useEffect(() => {
    // Reset animations
    fadeAnim.setValue(0);
    itemAnimations.forEach(anim => anim.setValue(0));

    // Start animations
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 400,
        delay: animationDelay,
        useNativeDriver: false,
      }),
      Animated.stagger(
        80,
        itemAnimations.map(anim =>
          Animated.timing(anim, {
            toValue: 1,
            duration: animationDuration,
            delay: animationDelay + 200,
            useNativeDriver: false,
          })
        )
      ),
    ]).start();
  }, [data, limit, animationDelay, animationDuration]);

  // Get ranking position styles
  const getRankingStyles = (index: number) => {
    const position = index + 1;
    
    switch (position) {
      case 1:
        return {
          backgroundColor: '#ffd700', // gold
          textColor: colors.text.dark.primary,
          icon: 'trophy',
          size: 'large',
        };
      case 2:
        return {
          backgroundColor: '#94a3b8', // gray-400
          textColor: colors.text.dark.primary,
          icon: 'medal',
          size: 'medium',
        };
      case 3:
        return {
          backgroundColor: '#cd7c0f', // bronze
          textColor: colors.text.dark.primary,
          icon: 'medal',
          size: 'medium',
        };
      default:
        return {
          backgroundColor: theme.colors.background.elevated,
          textColor: theme.colors.text.primary,
          icon: 'bar-chart',
          size: 'small',
        };
    }
  };

  // Get progress bar width
  const getProgressWidth = (value: number) => {
    if (!value || !chartMaxValue || chartMaxValue === 0) return 0;
    return Math.min(100, Math.max(0, (value / chartMaxValue) * 100));
  };

  // Get trend icon and color
  const getTrendInfo = (trend?: 'up' | 'down' | 'neutral') => {
    switch (trend) {
      case 'up':
        return {
          icon: 'trending-up' as keyof typeof Ionicons.glyphMap,
          color: colors.semantic.success.main,
        };
      case 'down':
        return {
          icon: 'trending-down' as keyof typeof Ionicons.glyphMap,
          color: colors.semantic.error.main,
        };
      default:
        return {
          icon: 'remove' as keyof typeof Ionicons.glyphMap,
          color: theme.colors.text.tertiary,
        };
    }
  };

  // Render ranking item
  const renderItem = (item: RankingItem, index: number) => {
    if (!item || index >= itemAnimations.length) {
      return null;
    }
    
    const rankingStyle = getRankingStyles(index);
    const itemColor = item.color || customColors[index % customColors.length];
    const progressWidth = getProgressWidth(item.value || 0);
    const trendInfo = getTrendInfo(item.trend);
    
    const animatedOpacity = itemAnimations[index].interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
    });

    const animatedTranslateX = itemAnimations[index].interpolate({
      inputRange: [0, 1],
      outputRange: [50, 0],
    });

    const animatedProgressWidth = itemAnimations[index].interpolate({
      inputRange: [0, 1],
      outputRange: [0, progressWidth],
    });

    const ItemContent = () => (
      <View style={styles.itemContent}>
        {/* Ranking number and icon */}
        <View style={styles.rankingContainer}>
          <LinearGradient
            colors={
              index < 3
                ? [rankingStyle.backgroundColor, `${rankingStyle.backgroundColor}CC`]
                : [itemColor, `${itemColor}CC`]
            }
            style={[
              styles.rankingBadge,
              rankingStyle.size === 'large' && styles.rankingBadgeLarge,
              rankingStyle.size === 'medium' && styles.rankingBadgeMedium,
            ]}
          >
            {showIcons && index < 3 ? (
              <Ionicons
                name={rankingStyle.icon as keyof typeof Ionicons.glyphMap}
                size={rankingStyle.size === 'large' ? 20 : 16}
                color={rankingStyle.textColor}
              />
            ) : (
              <Text
                style={[
                  styles.rankingNumber,
                  {
                    color: index < 3 ? rankingStyle.textColor : colors.text.dark.primary,
                    fontSize: rankingStyle.size === 'large' ? 16 : 14,
                  },
                ]}
              >
                {index + 1}
              </Text>
            )}
          </LinearGradient>
        </View>

        {/* Item details */}
        <View style={styles.itemDetails}>
          <View style={styles.itemHeader}>
            <Text
              style={[
                styles.itemName,
                {
                  color: theme.colors.text.primary,
                  fontSize: index < 3 ? 16 : 15,
                  fontWeight: index < 3 ? '600' : '500',
                },
              ]}
              numberOfLines={1}
            >
              {item.name}
            </Text>
            
            {item.badge && (
              <View style={[styles.badge, { backgroundColor: `${itemColor}20` }]}>
                <Text style={[styles.badgeText, { color: itemColor }]}>
                  {item.badge}
                </Text>
              </View>
            )}
          </View>

          {item.subtitle && (
            <Text
              style={[styles.itemSubtitle, { color: theme.colors.text.secondary }]}
              numberOfLines={1}
            >
              {item.subtitle}
            </Text>
          )}

          {item.description && (
            <Text
              style={[styles.itemDescription, { color: theme.colors.text.tertiary }]}
              numberOfLines={1}
            >
              {item.description}
            </Text>
          )}

          {/* Progress bar */}
          {showProgress && (
            <View style={styles.progressContainer}>
              <View
                style={[
                  styles.progressTrack,
                  { backgroundColor: isDark ? colors.gray[700] : colors.gray[200] },
                ]}
              >
                <AnimatedView
                  style={[
                    styles.progressBar,
                    {
                      backgroundColor: itemColor,
                      width: animatedProgressWidth.interpolate({
                        inputRange: [0, 100],
                        outputRange: ['0%', '100%'],
                      }),
                    },
                  ]}
                />
              </View>
              
              <Text style={[styles.progressValue, { color: theme.colors.text.secondary }]}>
                {item.value.toLocaleString()}
              </Text>
            </View>
          )}
        </View>

        {/* Trend and value */}
        <View style={styles.itemMeta}>
          {showTrend && item.trend && (
            <View style={styles.trendContainer}>
              <Ionicons
                name={trendInfo.icon}
                size={14}
                color={trendInfo.color}
              />
            </View>
          )}
          
          {!showProgress && (
            <Text
              style={[
                styles.itemValue,
                {
                  color: theme.colors.text.primary,
                  fontSize: index < 3 ? 18 : 16,
                  fontWeight: index < 3 ? '700' : '600',
                },
              ]}
            >
              {item.value.toLocaleString()}
            </Text>
          )}
        </View>
      </View>
    );

    if (onItemPress) {
      return (
        <AnimatedTouchableOpacity
          key={item.id}
          style={[
            styles.itemContainer,
            {
              backgroundColor: isDark
                ? theme.colors.background.elevated
                : theme.colors.background.primary,
              opacity: animatedOpacity,
              transform: [{ translateX: animatedTranslateX }],
            },
          ]}
          onPress={() => onItemPress(item, index)}
          activeOpacity={0.7}
        >
          <ItemContent />
        </AnimatedTouchableOpacity>
      );
    }

    return (
      <AnimatedView
        key={item.id}
        style={[
          styles.itemContainer,
          {
            backgroundColor: isDark
              ? theme.colors.background.elevated
              : theme.colors.background.primary,
            opacity: animatedOpacity,
            transform: [{ translateX: animatedTranslateX }],
          },
        ]}
      >
        <ItemContent />
      </AnimatedView>
    );
  };

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: isDark
            ? theme.colors.background.secondary
            : theme.colors.background.elevated,
          opacity: fadeAnim,
        },
      ]}
    >
      <LinearGradient
        colors={[
          'rgba(168, 85, 247, 0.03)',
          'rgba(147, 51, 234, 0.02)',
          'transparent',
        ]}
        style={styles.gradient}
      >
        <Text style={[styles.title, { color: theme.colors.text.primary }]}>
          {title}
        </Text>

        <View style={styles.listContainer}>
          <View style={styles.list}>
            {displayData.map(renderItem).filter(Boolean)}
          </View>
        </View>
      </LinearGradient>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    marginVertical: spacing[2],
  },
  gradient: {
    flex: 1,
    padding: spacing[5],
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: spacing[4],
    textAlign: 'center',
  },
  listContainer: {
    // Fixed height container instead of flex for non-scrollable content
  },
  list: {
    gap: spacing[3],
  },
  itemContainer: {
    borderRadius: borderRadius.xl,
    padding: spacing[4],
  },
  itemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[3],
  },
  rankingContainer: {
    alignItems: 'center',
  },
  rankingBadge: {
    width: 32,
    height: 32,
    borderRadius: borderRadius.full,
    justifyContent: 'center',
    alignItems: 'center',
  },
  rankingBadgeLarge: {
    width: 40,
    height: 40,
  },
  rankingBadgeMedium: {
    width: 36,
    height: 36,
  },
  rankingNumber: {
    fontSize: 14,
    fontWeight: '700',
  },
  itemDetails: {
    flex: 1,
    gap: spacing[1],
  },
  itemHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[2],
  },
  itemName: {
    flex: 1,
    fontSize: 15,
    fontWeight: '500',
  },
  badge: {
    paddingHorizontal: spacing[2],
    paddingVertical: spacing[0.5],
    borderRadius: borderRadius.pill,
  },
  badgeText: {
    fontSize: 10,
    fontWeight: '600',
  },
  itemSubtitle: {
    fontSize: 12,
    fontWeight: '500',
  },
  itemDescription: {
    fontSize: 11,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[2],
    marginTop: spacing[1],
  },
  progressTrack: {
    flex: 1,
    height: 6,
    borderRadius: borderRadius.pill,
    overflow: 'hidden',
  },
  progressBar: {
    height: '100%',
    borderRadius: borderRadius.pill,
  },
  progressValue: {
    fontSize: 12,
    fontWeight: '600',
    minWidth: 40,
    textAlign: 'right',
  },
  itemMeta: {
    alignItems: 'center',
    gap: spacing[1],
  },
  trendContainer: {
    padding: spacing[1],
  },
  itemValue: {
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'right',
    minWidth: 50,
  },
});
</file>

<file path="src/components/layouts/GridLayout.tsx">
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  ViewStyle,
  FlatList,
  Dimensions,
  ListRenderItem,
  FlatListProps,
  StyleSheet,
} from 'react-native';
import { useColumns, useResponsive } from '../../hooks/useResponsive';
import Animated, {
  useAnimatedStyle,
  withSpring,
  interpolate,
  useSharedValue,
  useAnimatedReaction,
  runOnJS,
} from 'react-native-reanimated';

interface GridLayoutProps<T = any> extends Omit<FlatListProps<T>, 'renderItem' | 'numColumns'> {
  data: T[];
  renderItem: (item: T, index: number) => ReactNode;
  columns?: Partial<Record<'mobile' | 'mobileL' | 'tablet' | 'laptop' | 'desktop' | 'desktopL' | 'ultraWide', number>>;
  spacing?: number;
  animated?: boolean;
  staggered?: boolean;
  aspectRatio?: number;
  style?: ViewStyle;
}

export function GridLayout<T = any>({
  data,
  renderItem,
  columns: customColumns,
  spacing,
  animated = true,
  staggered = false,
  aspectRatio,
  style,
  ...flatListProps
}: GridLayoutProps<T>) {
  const { columns, gutter } = useColumns(customColumns);
  const { dimensions, animationDuration } = useResponsive();
  
  const gridSpacing = spacing !== undefined ? spacing : gutter;
  const animationProgress = useSharedValue(0);

  // Calculate item dimensions
  const itemDimensions = useMemo(() => {
    const availableWidth = dimensions.width - (gridSpacing * (columns + 1));
    const itemWidth = availableWidth / columns;
    const itemHeight = aspectRatio ? itemWidth / aspectRatio : undefined;
    
    return { width: itemWidth, height: itemHeight };
  }, [dimensions.width, columns, gridSpacing, aspectRatio]);

  // Animate on column change
  useAnimatedReaction(
    () => columns,
    (current, previous) => {
      if (previous !== undefined && current !== previous) {
        animationProgress.value = 0;
        animationProgress.value = withSpring(1, {
          damping: 20,
          stiffness: 90,
        });
      }
    }
  );

  const renderGridItem: ListRenderItem<T> = ({ item, index }) => {
    const content = renderItem(item, index);
    
    if (!animated) {
      return (
        <View
          style={[
            styles.gridItem,
            {
              width: itemDimensions.width,
              height: itemDimensions.height,
              marginLeft: gridSpacing / 2,
              marginRight: gridSpacing / 2,
              marginBottom: gridSpacing,
            },
          ]}
        >
          {content}
        </View>
      );
    }

    return (
      <AnimatedGridItem
        index={index}
        width={itemDimensions.width}
        height={itemDimensions.height}
        spacing={gridSpacing}
        staggered={staggered}
        animationProgress={animationProgress}
        duration={animationDuration()}
      >
        {content}
      </AnimatedGridItem>
    );
  };

  return (
    <FlatList
      data={data}
      renderItem={renderGridItem}
      numColumns={columns}
      key={`grid-${columns}`} // Force re-render on column change
      columnWrapperStyle={columns > 1 ? styles.row : undefined}
      contentContainerStyle={[
        {
          paddingHorizontal: gridSpacing / 2,
          paddingTop: gridSpacing,
        },
        flatListProps.contentContainerStyle,
      ]}
      style={[styles.container, style]}
      showsVerticalScrollIndicator={false}
      {...flatListProps}
    />
  );
}

// Animated Grid Item Component
interface AnimatedGridItemProps {
  children: ReactNode;
  index: number;
  width: number;
  height?: number;
  spacing: number;
  staggered: boolean;
  animationProgress: Animated.SharedValue<number>;
  duration: number;
}

const AnimatedGridItem: React.FC<AnimatedGridItemProps> = ({
  children,
  index,
  width,
  height,
  spacing,
  staggered,
  animationProgress,
  duration,
}) => {
  const delay = staggered ? index * 50 : 0;
  
  const animatedStyle = useAnimatedStyle(() => {
    const progress = animationProgress.value;
    
    const scale = interpolate(
      progress,
      [0, 1],
      [0.8, 1]
    );
    
    const opacity = interpolate(
      progress,
      [0, 1],
      [0, 1]
    );
    
    const translateY = interpolate(
      progress,
      [0, 1],
      [20, 0]
    );

    return {
      transform: [
        { scale: withSpring(scale, { damping: 15 }) },
        { translateY: withSpring(translateY, { damping: 15 }) },
      ],
      opacity: withSpring(opacity),
    };
  });

  return (
    <Animated.View
      style={[
        styles.gridItem,
        {
          width,
          height,
          marginLeft: spacing / 2,
          marginRight: spacing / 2,
          marginBottom: spacing,
        },
        animatedStyle,
      ]}
    >
      {children}
    </Animated.View>
  );
};

// Masonry Grid Layout for variable height items
interface MasonryGridLayoutProps<T = any> {
  data: T[];
  renderItem: (item: T, index: number) => ReactNode;
  columns?: Partial<Record<'mobile' | 'mobileL' | 'tablet' | 'laptop' | 'desktop' | 'desktopL' | 'ultraWide', number>>;
  spacing?: number;
  style?: ViewStyle;
}

export function MasonryGridLayout<T = any>({
  data,
  renderItem,
  columns: customColumns,
  spacing,
  style,
}: MasonryGridLayoutProps<T>) {
  const { columns, gutter } = useColumns(customColumns);
  const { dimensions } = useResponsive();
  
  const gridSpacing = spacing !== undefined ? spacing : gutter;

  // Distribute items across columns
  const columnData = useMemo(() => {
    const cols: T[][] = Array(columns).fill(null).map(() => []);
    
    data.forEach((item, index) => {
      const columnIndex = index % columns;
      cols[columnIndex].push(item);
    });
    
    return cols;
  }, [data, columns]);

  const columnWidth = useMemo(() => {
    const availableWidth = dimensions.width - (gridSpacing * (columns + 1));
    return availableWidth / columns;
  }, [dimensions.width, columns, gridSpacing]);

  return (
    <View style={[styles.masonryContainer, style]}>
      <View style={[styles.row, { marginHorizontal: -gridSpacing / 2 }]}>
        {columnData.map((columnItems, columnIndex) => (
          <View
            key={`column-${columnIndex}`}
            style={{
              width: columnWidth,
              marginHorizontal: gridSpacing / 2,
            }}
          >
            {columnItems.map((item, index) => {
              const originalIndex = index * columns + columnIndex;
              return (
                <View
                  key={`item-${originalIndex}`}
                  style={{ marginBottom: gridSpacing }}
                >
                  {renderItem(item, originalIndex)}
                </View>
              );
            })}
          </View>
        ))}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  row: {
    flexDirection: 'row',
  },
  gridItem: {
    overflow: 'hidden',
  },
  masonryContainer: {
    flex: 1,
  },
});

export default GridLayout;
</file>

<file path="src/components/layouts/index.ts">
// Responsive Layout Components Export
export {
  ResponsiveContainer,
  ResponsiveSection,
  ResponsiveRow,
  ResponsiveColumn,
} from './ResponsiveContainer';

export {
  GridLayout,
  MasonryGridLayout,
} from './GridLayout';

export {
  SidebarLayout,
  SidebarItem,
  SidebarSection,
} from './SidebarLayout';

export {
  TabletNavigation,
  FloatingTabBar,
  SplitViewNavigation,
} from './TabletNavigation';

// Export all layouts as default
export default {
  ResponsiveContainer,
  ResponsiveSection,
  ResponsiveRow,
  ResponsiveColumn,
  GridLayout,
  MasonryGridLayout,
  SidebarLayout,
  SidebarItem,
  SidebarSection,
  TabletNavigation,
  FloatingTabBar,
  SplitViewNavigation,
};
</file>

<file path="src/components/layouts/ResponsiveContainer.tsx">
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  ViewStyle,
  ScrollViewProps,
  Animated,
} from 'react-native';
import { useResponsive } from '../../hooks/useResponsive';
import { useTheme } from '../../contexts/ThemeContext';

interface ResponsiveContainerProps extends Omit<ScrollViewProps, 'style'> {
  children: ReactNode;
  maxWidth?: number;
  padding?: boolean;
  scroll?: boolean;
  center?: boolean;
  fullHeight?: boolean;
  style?: ViewStyle;
  animated?: boolean;
  contentContainerStyle?: ViewStyle;
}

export const ResponsiveContainer: React.FC<ResponsiveContainerProps> = ({
  children,
  maxWidth,
  padding = true,
  scroll = true,
  center = true,
  fullHeight = false,
  style,
  animated = false,
  contentContainerStyle,
  ...scrollViewProps
}) => {
  const {
    dimensions,
    breakpoint,
    gridConfig,
    containerWidth,
    safeAreaPadding,
    rSpacing,
  } = useResponsive();
  const { theme } = useTheme();

  const containerStyles = useMemo<ViewStyle>(() => {
    const baseStyles: ViewStyle = {
      flex: fullHeight ? 1 : undefined,
      width: '100%',
      maxWidth: maxWidth || containerWidth,
      alignSelf: center ? 'center' : undefined,
    };

    if (padding) {
      baseStyles.paddingHorizontal = gridConfig.margin;
      baseStyles.paddingTop = safeAreaPadding.top;
      baseStyles.paddingBottom = safeAreaPadding.bottom;
    }

    return baseStyles;
  }, [
    fullHeight,
    maxWidth,
    containerWidth,
    center,
    padding,
    gridConfig.margin,
    safeAreaPadding,
  ]);

  const contentStyles = useMemo<ViewStyle>(() => {
    return {
      flexGrow: scroll ? 1 : undefined,
      paddingBottom: scroll && padding ? rSpacing(16) : undefined,
      ...contentContainerStyle,
    };
  }, [scroll, padding, rSpacing, contentContainerStyle]);

  const Container = animated ? Animated.View : View;
  const ScrollContainer = animated ? Animated.ScrollView : ScrollView;

  if (!scroll) {
    return (
      <Container style={[containerStyles, style]}>
        {children}
      </Container>
    );
  }

  return (
    <ScrollContainer
      style={[styles.scrollView, { backgroundColor: theme.colors.background.primary }]}
      contentContainerStyle={[containerStyles, contentStyles]}
      showsVerticalScrollIndicator={false}
      keyboardShouldPersistTaps="handled"
      {...scrollViewProps}
    >
      {children}
    </ScrollContainer>
  );
};

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
  },
});

// Responsive Section Component
interface ResponsiveSectionProps {
  children: ReactNode;
  style?: ViewStyle;
  spacing?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
}

export const ResponsiveSection: React.FC<ResponsiveSectionProps> = ({
  children,
  style,
  spacing = 'md',
}) => {
  const { rSpacing } = useResponsive();
  
  const spacingValues = {
    xs: 8,
    sm: 16,
    md: 24,
    lg: 32,
    xl: 48,
  };

  return (
    <View
      style={[
        {
          marginBottom: rSpacing(spacingValues[spacing]),
        },
        style,
      ]}
    >
      {children}
    </View>
  );
};

// Responsive Row Component
interface ResponsiveRowProps {
  children: ReactNode;
  style?: ViewStyle;
  wrap?: boolean;
  spacing?: number;
  align?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justify?: 'flex-start' | 'center' | 'flex-end' | 'space-between' | 'space-around' | 'space-evenly';
}

export const ResponsiveRow: React.FC<ResponsiveRowProps> = ({
  children,
  style,
  wrap = true,
  spacing,
  align = 'stretch',
  justify = 'flex-start',
}) => {
  const { gridConfig } = useResponsive();
  
  const gap = spacing !== undefined ? spacing : gridConfig.gutter;

  return (
    <View
      style={[
        {
          flexDirection: 'row',
          flexWrap: wrap ? 'wrap' : 'nowrap',
          alignItems: align,
          justifyContent: justify,
          marginHorizontal: -gap / 2,
        },
        style,
      ]}
    >
      {React.Children.map(children, (child, index) => (
        <View
          key={index}
          style={{
            paddingHorizontal: gap / 2,
            marginBottom: wrap ? gap : 0,
          }}
        >
          {child}
        </View>
      ))}
    </View>
  );
};

// Responsive Column Component
interface ResponsiveColumnProps {
  children: ReactNode;
  style?: ViewStyle;
  span?: number;
  offset?: number;
}

export const ResponsiveColumn: React.FC<ResponsiveColumnProps> = ({
  children,
  style,
  span = 1,
  offset = 0,
}) => {
  const { dimensions, gridConfig } = useResponsive();
  
  const calculateColumnWidth = (columns: number) => {
    const availableWidth = dimensions.width - (gridConfig.margin * 2);
    const totalGutters = (gridConfig.columns - 1) * gridConfig.gutter;
    const columnWidth = (availableWidth - totalGutters) / gridConfig.columns;
    return Math.floor(columnWidth * columns + gridConfig.gutter * (columns - 1));
  };
  
  const width = calculateColumnWidth(span);
  const marginLeft = offset > 0 ? calculateColumnWidth(offset) + gridConfig.gutter : 0;

  return (
    <View
      style={[
        {
          width,
          marginLeft,
        },
        style,
      ]}
    >
      {children}
    </View>
  );
};

export default ResponsiveContainer;
</file>

<file path="src/components/layouts/SidebarLayout.tsx">
import React, { useState, useRef, ReactNode } from 'react';
import {
  View,
  StyleSheet,
  TouchableOpacity,
  Text,
  ScrollView,
  ViewStyle,
  Platform,
} from 'react-native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  withTiming,
  interpolate,
  runOnJS,
} from 'react-native-reanimated';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../../contexts/ThemeContext';
import { useAdaptiveLayout, useResponsive } from '../../hooks/useResponsive';
import { LinearGradient } from 'expo-linear-gradient';

interface SidebarLayoutProps {
  children: ReactNode;
  sidebarContent: ReactNode;
  headerContent?: ReactNode;
  style?: ViewStyle;
}

export const SidebarLayout: React.FC<SidebarLayoutProps> = ({
  children,
  sidebarContent,
  headerContent,
  style,
}) => {
  const { theme } = useTheme();
  const { shouldShowSidebar, isCompact } = useAdaptiveLayout();
  const { dimensions, rSpacing, animationDuration } = useResponsive();
  
  const [isCollapsed, setIsCollapsed] = useState(false);
  const sidebarAnimation = useSharedValue(shouldShowSidebar ? 1 : 0);
  const contentAnimation = useSharedValue(1);

  const sidebarWidth = theme.dimensions.sidebar.width;
  const collapsedWidth = theme.dimensions.sidebar.collapsedWidth;
  const headerHeight = theme.dimensions.header.height;

  React.useEffect(() => {
    sidebarAnimation.value = withSpring(shouldShowSidebar && !isCollapsed ? 1 : 0, {
      damping: 20,
      stiffness: 90,
    });
    
    contentAnimation.value = withSpring(1, {
      damping: 20,
      stiffness: 90,
    });
  }, [shouldShowSidebar, isCollapsed]);

  const toggleSidebar = () => {
    setIsCollapsed(!isCollapsed);
  };

  const sidebarStyle = useAnimatedStyle(() => {
    const width = interpolate(
      sidebarAnimation.value,
      [0, 1],
      [collapsedWidth, sidebarWidth]
    );

    const translateX = interpolate(
      sidebarAnimation.value,
      [0, 1],
      [-(sidebarWidth - collapsedWidth), 0]
    );

    return {
      width,
      transform: [{ translateX }],
    };
  });

  const contentStyle = useAnimatedStyle(() => {
    const marginLeft = shouldShowSidebar
      ? interpolate(
          sidebarAnimation.value,
          [0, 1],
          [collapsedWidth, sidebarWidth]
        )
      : 0;

    const scale = interpolate(
      contentAnimation.value,
      [0, 1],
      [0.95, 1]
    );

    return {
      marginLeft,
      transform: [{ scale }],
    };
  });

  if (!shouldShowSidebar) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background.primary }, style]}>
        {headerContent && (
          <View
            style={[
              styles.header,
              {
                height: headerHeight,
                backgroundColor: theme.colors.background.elevated,
                borderBottomColor: theme.colors.border.default,
              },
            ]}
          >
            {headerContent}
          </View>
        )}
        <View style={styles.content}>{children}</View>
      </View>
    );
  }

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background.primary }, style]}>
      {/* Sidebar */}
      <Animated.View
        style={[
          styles.sidebar,
          {
            backgroundColor: theme.colors.background.elevated,
            borderRightColor: theme.colors.border.default,
            zIndex: theme.zIndex.sticky,
          },
          sidebarStyle,
        ]}
      >
        <LinearGradient
          colors={[
            theme.colors.gradients.purple.start,
            theme.colors.gradients.purple.middle,
            theme.colors.gradients.purple.end,
          ]}
          style={styles.sidebarGradient}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        />
        
        <View style={styles.sidebarHeader}>
          <TouchableOpacity
            onPress={toggleSidebar}
            style={[
              styles.toggleButton,
              {
                backgroundColor: theme.colors.background.primary + '20',
              },
            ]}
          >
            <Ionicons
              name={isCollapsed ? 'chevron-forward' : 'chevron-back'}
              size={24}
              color={theme.colors.text.inverse}
            />
          </TouchableOpacity>
        </View>
        
        <ScrollView
          style={styles.sidebarContent}
          showsVerticalScrollIndicator={false}
          contentContainerStyle={{ paddingBottom: rSpacing(32) }}
        >
          {sidebarContent}
        </ScrollView>
      </Animated.View>

      {/* Main Content */}
      <Animated.View style={[styles.mainContent, contentStyle]}>
        {headerContent && (
          <View
            style={[
              styles.header,
              {
                height: headerHeight,
                backgroundColor: theme.colors.background.elevated,
                borderBottomColor: theme.colors.border.default,
              },
            ]}
          >
            {headerContent}
          </View>
        )}
        <View style={styles.content}>{children}</View>
      </Animated.View>
    </View>
  );
};

// Sidebar Item Component
interface SidebarItemProps {
  icon: string;
  label: string;
  onPress: () => void;
  active?: boolean;
  collapsed?: boolean;
}

export const SidebarItem: React.FC<SidebarItemProps> = ({
  icon,
  label,
  onPress,
  active = false,
  collapsed = false,
}) => {
  const { theme } = useTheme();
  const { rSpacing, rFontSize } = useResponsive();

  return (
    <TouchableOpacity
      onPress={onPress}
      style={[
        styles.sidebarItem,
        {
          backgroundColor: active
            ? theme.colors.purple[500] + '20'
            : 'transparent',
          paddingVertical: rSpacing(12),
          paddingHorizontal: rSpacing(16),
        },
      ]}
    >
      <View style={styles.sidebarItemContent}>
        <Ionicons
          name={icon as any}
          size={24}
          color={active ? theme.colors.purple[400] : theme.colors.text.secondary}
        />
        {!collapsed && (
          <Text
            style={[
              styles.sidebarItemLabel,
              {
                color: active ? theme.colors.purple[400] : theme.colors.text.primary,
                fontSize: rFontSize(16),
                marginLeft: rSpacing(12),
              },
            ]}
            numberOfLines={1}
          >
            {label}
          </Text>
        )}
      </View>
      {active && (
        <View
          style={[
            styles.activeIndicator,
            {
              backgroundColor: theme.colors.purple[500],
            },
          ]}
        />
      )}
    </TouchableOpacity>
  );
};

// Sidebar Section Component
interface SidebarSectionProps {
  title: string;
  children: ReactNode;
  collapsed?: boolean;
}

export const SidebarSection: React.FC<SidebarSectionProps> = ({
  title,
  children,
  collapsed = false,
}) => {
  const { theme } = useTheme();
  const { rSpacing, rFontSize } = useResponsive();

  if (collapsed) {
    return <View style={{ marginVertical: rSpacing(8) }}>{children}</View>;
  }

  return (
    <View style={[styles.sidebarSection, { marginBottom: rSpacing(24) }]}>
      <Text
        style={[
          styles.sidebarSectionTitle,
          {
            color: theme.colors.text.tertiary,
            fontSize: rFontSize(12),
            paddingHorizontal: rSpacing(16),
            marginBottom: rSpacing(8),
          },
        ]}
      >
        {title.toUpperCase()}
      </Text>
      {children}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
  },
  sidebar: {
    position: 'absolute',
    left: 0,
    top: 0,
    bottom: 0,
    borderRightWidth: 1,
    overflow: 'hidden',
    ...Platform.select({
      web: {
        position: 'fixed' as any,
      },
    }),
  },
  sidebarGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 200,
    opacity: 0.1,
  },
  sidebarHeader: {
    padding: 16,
    alignItems: 'flex-end',
  },
  toggleButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sidebarContent: {
    flex: 1,
  },
  sidebarSection: {},
  sidebarSectionTitle: {
    fontWeight: '600',
    letterSpacing: 0.5,
  },
  sidebarItem: {
    position: 'relative',
    borderRadius: 8,
    marginHorizontal: 8,
    marginVertical: 2,
  },
  sidebarItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  sidebarItemLabel: {
    flex: 1,
    fontWeight: '500',
  },
  activeIndicator: {
    position: 'absolute',
    left: 0,
    top: '20%',
    bottom: '20%',
    width: 3,
    borderRadius: 2,
  },
  mainContent: {
    flex: 1,
  },
  header: {
    borderBottomWidth: 1,
    justifyContent: 'center',
  },
  content: {
    flex: 1,
  },
});

export default SidebarLayout;
</file>

<file path="src/components/layouts/TabletNavigation.tsx">
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  Dimensions,
  ViewStyle,
  Platform,
} from 'react-native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  withTiming,
  interpolate,
} from 'react-native-reanimated';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { useTheme } from '../../contexts/ThemeContext';
import { useResponsive, useAdaptiveLayout } from '../../hooks/useResponsive';

interface TabletNavigationProps {
  tabs: Array<{
    key: string;
    label: string;
    icon: string;
    component: React.ComponentType<any>;
  }>;
  activeTab?: string;
  onTabChange?: (tabKey: string) => void;
  style?: ViewStyle;
}

export const TabletNavigation: React.FC<TabletNavigationProps> = ({
  tabs,
  activeTab: controlledActiveTab,
  onTabChange,
  style,
}) => {
  const { theme } = useTheme();
  const { dimensions, rSpacing, rFontSize, breakpoint } = useResponsive();
  const { navigationPosition } = useAdaptiveLayout();
  
  const [activeTab, setActiveTab] = useState(controlledActiveTab || tabs[0]?.key);
  const scrollViewRef = useRef<ScrollView>(null);
  const tabRefs = useRef<Record<string, View | null>>({});
  
  const indicatorPosition = useSharedValue(0);
  const indicatorWidth = useSharedValue(0);

  const isTopNavigation = navigationPosition === 'top';
  const navigationHeight = theme.dimensions.navigation.height;

  const handleTabPress = (tabKey: string, index: number) => {
    const newTab = tabKey;
    setActiveTab(newTab);
    onTabChange?.(newTab);

    // Animate indicator
    const tabRef = tabRefs.current[tabKey];
    if (tabRef) {
      tabRef.measure((x, y, width, height, pageX, pageY) => {
        indicatorPosition.value = withSpring(pageX, {
          damping: 20,
          stiffness: 90,
        });
        indicatorWidth.value = withSpring(width, {
          damping: 20,
          stiffness: 90,
        });
      });
    }

    // Scroll to tab if needed
    if (scrollViewRef.current) {
      scrollViewRef.current.scrollTo({
        x: index * 150 - dimensions.width / 2 + 75,
        animated: true,
      });
    }
  };

  const indicatorStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: indicatorPosition.value }],
      width: indicatorWidth.value,
    };
  });

  const activeTabData = tabs.find(tab => tab.key === activeTab);
  const ActiveComponent = activeTabData?.component;

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background.primary }, style]}>
      {/* Navigation Bar */}
      <View
        style={[
          styles.navigationBar,
          isTopNavigation ? styles.topNavigation : styles.bottomNavigation,
          {
            height: navigationHeight,
            backgroundColor: Platform.OS === 'ios' ? 'transparent' : theme.colors.background.elevated,
            borderColor: theme.colors.border.default,
          },
        ]}
      >
        {Platform.OS === 'ios' ? (
          <BlurView
            intensity={95}
            tint={theme.mode === 'dark' ? 'dark' : 'light'}
            style={StyleSheet.absoluteFillObject}
          />
        ) : null}
        
        <ScrollView
          ref={scrollViewRef}
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={[
            styles.tabsContainer,
            { paddingHorizontal: rSpacing(16) },
          ]}
        >
          {tabs.map((tab, index) => (
            <TouchableOpacity
              key={tab.key}
              ref={(ref) => (tabRefs.current[tab.key] = ref as any)}
              onPress={() => handleTabPress(tab.key, index)}
              style={[
                styles.tab,
                {
                  paddingHorizontal: rSpacing(20),
                  paddingVertical: rSpacing(12),
                },
              ]}
            >
              <View style={styles.tabContent}>
                <Ionicons
                  name={tab.icon as any}
                  size={24}
                  color={
                    activeTab === tab.key
                      ? theme.colors.purple[500]
                      : theme.colors.text.secondary
                  }
                />
                <Text
                  style={[
                    styles.tabLabel,
                    {
                      color:
                        activeTab === tab.key
                          ? theme.colors.purple[500]
                          : theme.colors.text.secondary,
                      fontSize: rFontSize(14),
                      marginLeft: rSpacing(8),
                    },
                  ]}
                >
                  {tab.label}
                </Text>
              </View>
            </TouchableOpacity>
          ))}
        </ScrollView>

        {/* Active Tab Indicator */}
        <Animated.View
          style={[
            styles.indicator,
            isTopNavigation ? styles.indicatorTop : styles.indicatorBottom,
            indicatorStyle,
          ]}
        >
          <LinearGradient
            colors={[
              theme.colors.gradients.purple.start,
              theme.colors.gradients.purple.end,
            ]}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
            style={styles.indicatorGradient}
          />
        </Animated.View>
      </View>

      {/* Content */}
      <View style={[styles.content, isTopNavigation && { paddingTop: navigationHeight }]}>
        {ActiveComponent && <ActiveComponent />}
      </View>
    </View>
  );
};

// Floating Tab Bar for tablets
interface FloatingTabBarProps {
  tabs: Array<{
    key: string;
    label: string;
    icon: string;
  }>;
  activeTab: string;
  onTabChange: (tabKey: string) => void;
}

export const FloatingTabBar: React.FC<FloatingTabBarProps> = ({
  tabs,
  activeTab,
  onTabChange,
}) => {
  const { theme } = useTheme();
  const { rSpacing, rFontSize } = useResponsive();

  return (
    <View style={[styles.floatingContainer, { bottom: rSpacing(32) }]}>
      <View
        style={[
          styles.floatingBar,
          {
            backgroundColor: theme.colors.background.elevated,
            borderColor: theme.colors.border.default,
            paddingHorizontal: rSpacing(8),
            paddingVertical: rSpacing(4),
          },
        ]}
      >
        {tabs.map((tab) => {
          const isActive = activeTab === tab.key;
          return (
            <TouchableOpacity
              key={tab.key}
              onPress={() => onTabChange(tab.key)}
              style={[
                styles.floatingTab,
                {
                  backgroundColor: isActive
                    ? theme.colors.purple[500]
                    : 'transparent',
                  paddingHorizontal: rSpacing(16),
                  paddingVertical: rSpacing(10),
                },
              ]}
            >
              <Ionicons
                name={tab.icon as any}
                size={22}
                color={isActive ? '#FFFFFF' : theme.colors.text.secondary}
              />
              {isActive && (
                <Text
                  style={[
                    styles.floatingTabLabel,
                    {
                      color: '#FFFFFF',
                      fontSize: rFontSize(13),
                      marginLeft: rSpacing(6),
                    },
                  ]}
                >
                  {tab.label}
                </Text>
              )}
            </TouchableOpacity>
          );
        })}
      </View>
    </View>
  );
};

// Split View Navigation for larger tablets
interface SplitViewNavigationProps {
  masterView: React.ReactNode;
  detailView: React.ReactNode;
  masterWidth?: number;
}

export const SplitViewNavigation: React.FC<SplitViewNavigationProps> = ({
  masterView,
  detailView,
  masterWidth = 320,
}) => {
  const { theme } = useTheme();
  const { dimensions } = useResponsive();
  const [isMasterCollapsed, setIsMasterCollapsed] = useState(false);
  
  const masterAnimation = useSharedValue(1);
  
  const toggleMaster = () => {
    setIsMasterCollapsed(!isMasterCollapsed);
    masterAnimation.value = withSpring(isMasterCollapsed ? 1 : 0, {
      damping: 20,
      stiffness: 90,
    });
  };
  
  const masterStyle = useAnimatedStyle(() => {
    const width = interpolate(
      masterAnimation.value,
      [0, 1],
      [0, masterWidth]
    );
    
    return { width };
  });

  return (
    <View style={styles.splitContainer}>
      <Animated.View
        style={[
          styles.masterView,
          {
            backgroundColor: theme.colors.background.secondary,
            borderRightColor: theme.colors.border.default,
          },
          masterStyle,
        ]}
      >
        {masterView}
      </Animated.View>
      
      <View style={styles.detailView}>
        <TouchableOpacity
          onPress={toggleMaster}
          style={[
            styles.toggleMasterButton,
            {
              backgroundColor: theme.colors.background.elevated,
              borderColor: theme.colors.border.default,
            },
          ]}
        >
          <Ionicons
            name={isMasterCollapsed ? 'chevron-forward' : 'chevron-back'}
            size={20}
            color={theme.colors.text.primary}
          />
        </TouchableOpacity>
        {detailView}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  navigationBar: {
    position: 'absolute',
    left: 0,
    right: 0,
    zIndex: 100,
    overflow: 'hidden',
  },
  topNavigation: {
    top: 0,
    borderBottomWidth: 1,
  },
  bottomNavigation: {
    bottom: 0,
    borderTopWidth: 1,
  },
  tabsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  tab: {
    marginHorizontal: 4,
    borderRadius: 8,
  },
  tabContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  tabLabel: {
    fontWeight: '600',
  },
  indicator: {
    position: 'absolute',
    height: 3,
  },
  indicatorTop: {
    bottom: 0,
  },
  indicatorBottom: {
    top: 0,
  },
  indicatorGradient: {
    flex: 1,
    borderRadius: 2,
  },
  content: {
    flex: 1,
  },
  
  // Floating Tab Bar
  floatingContainer: {
    position: 'absolute',
    left: 0,
    right: 0,
    alignItems: 'center',
    zIndex: 100,
  },
  floatingBar: {
    flexDirection: 'row',
    borderRadius: 24,
    borderWidth: 1,
  },
  floatingTab: {
    flexDirection: 'row',
    alignItems: 'center',
    borderRadius: 20,
    marginHorizontal: 4,
  },
  floatingTabLabel: {
    fontWeight: '600',
  },
  
  // Split View
  splitContainer: {
    flex: 1,
    flexDirection: 'row',
  },
  masterView: {
    borderRightWidth: 1,
  },
  detailView: {
    flex: 1,
    position: 'relative',
  },
  toggleMasterButton: {
    position: 'absolute',
    left: 16,
    top: 16,
    width: 36,
    height: 36,
    borderRadius: 18,
    borderWidth: 1,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10,
  },
});

export default TabletNavigation;
</file>

<file path="src/components/ActionModal.tsx">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Modal,
  Alert,
  TextInput,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { useActions } from '../hooks/useActions';
import { TimelineAction, ActionCategory, ParkType, ParkArea } from '../types/models';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { AreaPicker } from './AreaPicker';
import { LocationSelector } from './LocationSelector';
import { PhotoManager } from './PhotoManager';
import { ValidationFeedback } from './ValidationFeedback';

interface ActionModalProps {
  visible: boolean;
  onClose: () => void;
  visitId: string;
  parkType: ParkType;
  action?: TimelineAction;
  onSave?: (action: TimelineAction) => void;
}

interface FormData {
  category: ActionCategory;
  area: ParkArea | '';
  locationName: string;
  customTitle: string;
  time: Date;
  notes: string;
  photos: string[];
  waitTime?: number;
  duration?: number;
}

interface FormErrors {
  category?: string;
  area?: string;
  locationName?: string;
  time?: string;
}

const getCategoryOptions = (language: string) => [
  { 
    value: ActionCategory.ATTRACTION, 
    label: language === 'ja' ? 'アトラクション' : 'Attraction', 
    icon: 'rocket' 
  },
  { 
    value: ActionCategory.RESTAURANT, 
    label: language === 'ja' ? 'レストラン' : 'Restaurant', 
    icon: 'restaurant' 
  },
  { 
    value: ActionCategory.SHOW, 
    label: language === 'ja' ? 'ショー/パレード' : 'Show/Parade', 
    icon: 'musical-notes' 
  },
  { 
    value: ActionCategory.GREETING, 
    label: language === 'ja' ? 'グリーティング' : 'Character Greeting', 
    icon: 'hand-left' 
  },
  { 
    value: ActionCategory.SHOPPING, 
    label: language === 'ja' ? 'ショッピング' : 'Shopping', 
    icon: 'bag' 
  },
  { 
    value: ActionCategory.CUSTOM, 
    label: language === 'ja' ? 'カスタム' : 'Custom', 
    icon: 'create' 
  },
];

export const ActionModal: React.FC<ActionModalProps> = ({
  visible,
  onClose,
  visitId,
  parkType,
  action,
  onSave,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const { createAction, updateAction } = useActions();
  
  const categoryOptions = getCategoryOptions(language);
  
  const [formData, setFormData] = useState<FormData>({
    category: ActionCategory.ATTRACTION,
    area: '',
    locationName: '',
    customTitle: '',
    time: new Date(),
    notes: '',
    photos: [],
    waitTime: undefined,
    duration: undefined,
  });
  
  const [errors, setErrors] = useState<FormErrors>({});
  const [isLoading, setIsLoading] = useState(false);
  const [showTimePicker, setShowTimePicker] = useState(false);

  useEffect(() => {
    if (action) {
      setFormData({
        category: action.category,
        area: action.area,
        locationName: action.locationName || '',
        customTitle: action.customTitle || '',
        time: new Date(action.time),
        notes: action.notes || '',
        photos: action.photos.map(p => p.uri),
        waitTime: action.waitTime,
        duration: action.duration,
      });
    } else {
      setFormData({
        category: ActionCategory.ATTRACTION,
        area: '',
        locationName: '',
        customTitle: '',
        time: new Date(),
        notes: '',
        photos: [],
        waitTime: undefined,
        duration: undefined,
      });
    }
    setErrors({});
  }, [action, visible]);

  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};

    if (!formData.category) {
      newErrors.category = language === 'ja' ? 'カテゴリを選択してください' : 'Please select a category';
    }

    if (!formData.area) {
      newErrors.area = language === 'ja' ? 'エリアを選択してください' : 'Please select an area';
    }

    // Location is only required for ATTRACTION, RESTAURANT, SHOW, and SHOPPING
    const requiresLocation = [
      ActionCategory.ATTRACTION,
      ActionCategory.RESTAURANT,
      ActionCategory.SHOW,
      ActionCategory.SHOPPING
    ].includes(formData.category);

    if (requiresLocation && !formData.locationName.trim()) {
      newErrors.locationName = language === 'ja' ? '施設名を入力してください' : 'Please enter a facility name';
    }

    // For CUSTOM category, either locationName or customTitle is required
    if (formData.category === ActionCategory.CUSTOM && 
        !formData.locationName.trim() && 
        !formData.customTitle.trim()) {
      newErrors.locationName = language === 'ja' ? 'タイトルまたは施設名を入力してください' : 'Please enter a title or facility name';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSave = async () => {
    if (!validateForm()) {
      return;
    }

    setIsLoading(true);
    
    try {
      const actionData: Omit<TimelineAction, 'id' | 'createdAt' | 'updatedAt'> = {
        visitId,
        category: formData.category,
        area: formData.area as ParkArea,
        locationName: formData.locationName.trim() || undefined,
        customTitle: formData.customTitle.trim() || undefined,
        time: formData.time,
        notes: formData.notes.trim() || undefined,
        photos: formData.photos.map((uri, index) => ({
          id: `photo-${Date.now()}-${index}`,
          uri,
        })),
        waitTime: formData.waitTime,
        duration: formData.duration,
      };

      let savedAction: TimelineAction;
      
      if (action) {
        savedAction = await updateAction(action.id, actionData);
      } else {
        savedAction = await createAction(actionData);
      }

      onSave?.(savedAction);
      onClose();
    } catch (error) {
      Alert.alert(
        language === 'ja' ? 'エラー' : 'Error',
        language === 'ja' ? 'アクションの保存に失敗しました' : 'Failed to save action'
      );
    } finally {
      setIsLoading(false);
    }
  };

  const handleTimeChange = (event: any, selectedTime?: Date) => {
    setShowTimePicker(Platform.OS === 'ios');
    if (selectedTime) {
      setFormData(prev => ({ ...prev, time: selectedTime }));
    }
  };

  const getCategoryIcon = (category: ActionCategory): string => {
    const option = categoryOptions.find(opt => opt.value === category);
    return option?.icon || 'ellipse';
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
      onRequestClose={onClose}
    >
      <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
        {/* Header */}
        <View style={[styles.header, { borderBottomColor: theme.colors.border }]}>
          <TouchableOpacity
            onPress={onClose}
            style={styles.headerButton}
          >
            <Ionicons name="close" size={24} color={theme.colors.text.primary} />
          </TouchableOpacity>
          
          <Text style={[styles.headerTitle, { color: theme.colors.text.primary }]}>
            {action 
              ? (language === 'ja' ? 'アクション編集' : 'Edit Action') 
              : (language === 'ja' ? 'アクション追加' : 'Add Action')
            }
          </Text>
          
          <TouchableOpacity
            onPress={handleSave}
            disabled={isLoading}
            style={[
              styles.headerButton,
              { opacity: isLoading ? 0.5 : 1 }
            ]}
          >
            <Text style={[styles.saveText, { color: colors.blue[500] }]}>
              {language === 'ja' ? '保存' : 'Save'}
            </Text>
          </TouchableOpacity>
        </View>

        <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
          {/* Category Selection */}
          <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? 'カテゴリ' : 'Category'}
            </Text>
            
            <View style={styles.categoryGrid}>
              {categoryOptions.map((option) => {
                const isSelected = formData.category === option.value;
                return (
                  <TouchableOpacity
                    key={option.value}
                    style={[
                      styles.categoryOption,
                      {
                        backgroundColor: isSelected 
                          ? colors.blue[500] + '20'
                          : theme.colors.background.secondary,
                        borderColor: isSelected 
                          ? colors.blue[500]
                          : theme.colors.border,
                      }
                    ]}
                    onPress={() => setFormData(prev => ({ 
                      ...prev, 
                      category: option.value,
                      area: '', // Reset area when category changes
                      locationName: '', // Reset location when category changes
                      customTitle: '' // Reset custom title when category changes
                    }))}
                  >
                    <Ionicons 
                      name={option.icon as any} 
                      size={20} 
                      color={isSelected ? colors.blue[500] : theme.colors.text.secondary}
                    />
                    <Text style={[
                      styles.categoryLabel,
                      { 
                        color: isSelected ? colors.blue[500] : theme.colors.text.primary,
                        fontWeight: isSelected ? '600' : '400'
                      }
                    ]}>
                      {option.label}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
            
            {errors.category && (
              <ValidationFeedback 
                validation={{
                  isValid: false,
                  errors: [errors.category],
                  warnings: []
                }}
              />
            )}
          </View>

          {/* Area Selection */}
          <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? 'エリア' : 'Area'}
            </Text>
            
            <AreaPicker
              parkType={parkType}
              selectedArea={formData.area}
              onAreaSelect={(area) => setFormData(prev => ({ 
                ...prev, 
                area,
                locationName: '', // Reset location when area changes
                customTitle: '' // Reset custom title when area changes
              }))}
            />
            
            {errors.area && (
              <ValidationFeedback 
                validation={{
                  isValid: false,
                  errors: [errors.area],
                  warnings: []
                }}
              />
            )}
          </View>

          {/* Location Selection - Only for categories that require specific locations */}
          {formData.area && [ActionCategory.ATTRACTION, ActionCategory.RESTAURANT, ActionCategory.SHOW, ActionCategory.SHOPPING].includes(formData.category) && (
            <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? '施設名' : 'Facility Name'}
              </Text>
              
              <LocationSelector
                category={formData.category}
                parkType={parkType}
                area={formData.area as ParkArea}
                selectedLocation={formData.locationName}
                onLocationSelect={(locationName) => 
                  setFormData(prev => ({ ...prev, locationName }))
                }
                onCustomLocation={(locationName) => 
                  setFormData(prev => ({ ...prev, locationName }))
                }
              />
              
              {errors.locationName && (
                <ValidationFeedback 
                  validation={{
                    isValid: false,
                    errors: [errors.locationName],
                    warnings: []
                  }}
                />
              )}
            </View>
          )}

          {/* Custom Title for CUSTOM category */}
          {formData.category === ActionCategory.CUSTOM && formData.area && (
            <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? 'タイトル' : 'Title'}
              </Text>
              
              <TextInput
                style={[
                  styles.titleInput,
                  {
                    backgroundColor: theme.colors.background.secondary,
                    borderColor: theme.colors.border,
                    color: theme.colors.text.primary,
                  }
                ]}
                value={formData.customTitle}
                onChangeText={(text) => setFormData(prev => ({ ...prev, customTitle: text }))}
                placeholder={language === 'ja' ? 'カスタムアクションのタイトルを入力...' : 'Enter custom action title...'}
                placeholderTextColor={theme.colors.text.secondary}
              />
              
              {errors.locationName && (
                <ValidationFeedback 
                  validation={{
                    isValid: false,
                    errors: [errors.locationName],
                    warnings: []
                  }}
                />
              )}
            </View>
          )}

          {/* Optional Location for GREETING and CUSTOM */}
          {formData.area && [ActionCategory.GREETING, ActionCategory.CUSTOM].includes(formData.category) && (
            <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                {formData.category === ActionCategory.GREETING 
                  ? (language === 'ja' ? 'グリーティング場所（任意）' : 'Greeting Location (Optional)') 
                  : (language === 'ja' ? '場所（任意）' : 'Location (Optional)')
                }
              </Text>
              
              <TextInput
                style={[
                  styles.titleInput,
                  {
                    backgroundColor: theme.colors.background.secondary,
                    borderColor: theme.colors.border,
                    color: theme.colors.text.primary,
                  }
                ]}
                value={formData.locationName}
                onChangeText={(text) => setFormData(prev => ({ ...prev, locationName: text }))}
                placeholder={formData.category === ActionCategory.GREETING 
                  ? (language === 'ja' ? 'グリーティング場所を入力...' : 'Enter greeting location...')
                  : (language === 'ja' ? '場所を入力...' : 'Enter location...')
                }
                placeholderTextColor={theme.colors.text.secondary}
              />
            </View>
          )}

          {/* Time Selection */}
          <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? '時刻' : 'Time'}
            </Text>
            
            <TouchableOpacity
              style={[styles.timeButton, { borderColor: theme.colors.border }]}
              onPress={() => setShowTimePicker(true)}
            >
              <Ionicons name="time" size={20} color={theme.colors.text.secondary} />
              <Text style={[styles.timeText, { color: theme.colors.text.primary }]}>
                {formData.time.toLocaleTimeString(language === 'ja' ? 'ja-JP' : 'en-US', { 
                  hour: '2-digit', 
                  minute: '2-digit' 
                })}
              </Text>
              <Ionicons name="chevron-down" size={16} color={theme.colors.text.secondary} />
            </TouchableOpacity>
            
            {showTimePicker && (
              <DateTimePicker
                value={formData.time}
                mode="time"
                is24Hour={true}
                display="default"
                onChange={handleTimeChange}
              />
            )}
          </View>

          {/* Additional Fields for Attractions */}
          {formData.category === ActionCategory.ATTRACTION && (
            <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? '詳細情報' : 'Additional Information'}
              </Text>
              
              <View style={styles.inputRow}>
                <View style={styles.inputHalf}>
                  <Text style={[styles.inputLabel, { color: theme.colors.text.secondary }]}>
                    {language === 'ja' ? '待ち時間（分）' : 'Wait Time (minutes)'}
                  </Text>
                  <TextInput
                    style={[
                      styles.textInput,
                      {
                        backgroundColor: theme.colors.background.secondary,
                        borderColor: theme.colors.border,
                        color: theme.colors.text.primary,
                      }
                    ]}
                    value={formData.waitTime?.toString() || ''}
                    onChangeText={(text) => {
                      const number = parseInt(text) || undefined;
                      setFormData(prev => ({ ...prev, waitTime: number }));
                    }}
                    keyboardType="numeric"
                    placeholder="0"
                    placeholderTextColor={theme.colors.text.secondary}
                  />
                </View>
                
                <View style={styles.inputHalf}>
                  <Text style={[styles.inputLabel, { color: theme.colors.text.secondary }]}>
                    {language === 'ja' ? '体験時間（分）' : 'Duration (minutes)'}
                  </Text>
                  <TextInput
                    style={[
                      styles.textInput,
                      {
                        backgroundColor: theme.colors.background.secondary,
                        borderColor: theme.colors.border,
                        color: theme.colors.text.primary,
                      }
                    ]}
                    value={formData.duration?.toString() || ''}
                    onChangeText={(text) => {
                      const number = parseInt(text) || undefined;
                      setFormData(prev => ({ ...prev, duration: number }));
                    }}
                    keyboardType="numeric"
                    placeholder="0"
                    placeholderTextColor={theme.colors.text.secondary}
                  />
                </View>
              </View>
            </View>
          )}


          {/* Notes */}
          <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? 'メモ' : 'Notes'}
            </Text>
            
            <TextInput
              style={[
                styles.notesInput,
                {
                  backgroundColor: theme.colors.background.secondary,
                  borderColor: theme.colors.border,
                  color: theme.colors.text.primary,
                }
              ]}
              value={formData.notes}
              onChangeText={(text) => setFormData(prev => ({ ...prev, notes: text }))}
              placeholder={language === 'ja' ? 'メモを入力...' : 'Enter notes...'}
              placeholderTextColor={theme.colors.text.secondary}
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />
          </View>

          {/* Photos */}
          <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? '写真' : 'Photos'}
            </Text>
            
            <PhotoManager
              photos={formData.photos}
              onPhotosChange={(photos) => setFormData(prev => ({ ...prev, photos }))}
              maxPhotos={10}
            />
          </View>
        </ScrollView>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
    borderBottomWidth: 1,
  },
  headerButton: {
    padding: spacing[2],
    minWidth: 60,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '600',
    flex: 1,
    textAlign: 'center',
  },
  saveText: {
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },
  content: {
    flex: 1,
  },
  section: {
    margin: spacing[4],
    marginBottom: spacing[2],
    borderRadius: borderRadius.lg,
    padding: spacing[4],
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: spacing[3],
  },
  categoryGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing[2],
  },
  categoryOption: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.md,
    borderWidth: 1,
    minWidth: '47%',
  },
  categoryLabel: {
    fontSize: 14,
    marginLeft: spacing[2],
  },
  timeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    borderRadius: borderRadius.md,
    borderWidth: 1,
  },
  timeText: {
    fontSize: 16,
    flex: 1,
    marginLeft: spacing[2],
  },
  inputRow: {
    flexDirection: 'row',
    gap: spacing[3],
  },
  inputHalf: {
    flex: 1,
  },
  inputLabel: {
    fontSize: 14,
    marginBottom: spacing[2],
  },
  textInput: {
    borderWidth: 1,
    borderRadius: borderRadius.md,
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    fontSize: 16,
  },
  ratingContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: spacing[2],
  },
  star: {
    marginHorizontal: spacing[1],
  },
  notesInput: {
    borderWidth: 1,
    borderRadius: borderRadius.md,
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    fontSize: 16,
    minHeight: 100,
  },
  titleInput: {
    borderWidth: 1,
    borderRadius: borderRadius.md,
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    fontSize: 16,
  },
});
</file>

<file path="src/components/AreaPicker.tsx">
import React, { useState, useMemo } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  TextInput,
  Animated,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { ParkArea, LandArea, SeaArea, ParkType } from '../types/models';

interface AreaPickerProps {
  parkType: ParkType;
  selectedArea?: ParkArea | '';
  onAreaSelect?: (area: ParkArea) => void;
  onSelect?: (area: ParkArea) => void;
  disabled?: boolean;
  style?: any;
}

interface AreaOption {
  value: ParkArea;
  label: string;
  emoji: string;
}

export const AreaPicker: React.FC<AreaPickerProps> = ({
  parkType,
  selectedArea,
  onAreaSelect,
  onSelect,
  disabled = false,
  style,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const [isOpen, setIsOpen] = useState(false);
  const [searchText, setSearchText] = useState('');

  // Area translation function
  const getAreaLabel = (area: ParkArea): string => {
    if (language === 'ja') {
      return area;
    }
    
    // English translations
    switch (area) {
      // Disneyland areas
      case LandArea.WORLD_BAZAAR:
        return 'World Bazaar';
      case LandArea.ADVENTURELAND:
        return 'Adventureland';
      case LandArea.WESTERNLAND:
        return 'Westernland';
      case LandArea.CRITTER_COUNTRY:
        return 'Critter Country';
      case LandArea.FANTASYLAND:
        return 'Fantasyland';
      case LandArea.TOONTOWN:
        return 'Toontown';
      case LandArea.TOMORROWLAND:
        return 'Tomorrowland';
      
      // DisneySea areas
      case SeaArea.MEDITERRANEAN_HARBOR:
        return 'Mediterranean Harbor';
      case SeaArea.AMERICAN_WATERFRONT:
        return 'American Waterfront';
      case SeaArea.PORT_DISCOVERY:
        return 'Port Discovery';
      case SeaArea.LOST_RIVER_DELTA:
        return 'Lost River Delta';
      case SeaArea.ARABIAN_COAST:
        return 'Arabian Coast';
      case SeaArea.MERMAID_LAGOON:
        return 'Mermaid Lagoon';
      case SeaArea.MYSTERIOUS_ISLAND:
        return 'Mysterious Island';
      case SeaArea.FANTASY_SPRINGS:
        return 'Fantasy Springs';
      
      default:
        return area;
    }
  };

  // Area options for both parks
  const landAreas: AreaOption[] = [
    { value: LandArea.WORLD_BAZAAR, label: getAreaLabel(LandArea.WORLD_BAZAAR), emoji: '🏪' },
    { value: LandArea.ADVENTURELAND, label: getAreaLabel(LandArea.ADVENTURELAND), emoji: '🌴' },
    { value: LandArea.WESTERNLAND, label: getAreaLabel(LandArea.WESTERNLAND), emoji: '🤠' },
    { value: LandArea.CRITTER_COUNTRY, label: getAreaLabel(LandArea.CRITTER_COUNTRY), emoji: '🐻' },
    { value: LandArea.FANTASYLAND, label: getAreaLabel(LandArea.FANTASYLAND), emoji: '🏰' },
    { value: LandArea.TOONTOWN, label: getAreaLabel(LandArea.TOONTOWN), emoji: '🎭' },
    { value: LandArea.TOMORROWLAND, label: getAreaLabel(LandArea.TOMORROWLAND), emoji: '🚀' },
  ];

  const seaAreas: AreaOption[] = [
    { value: SeaArea.MEDITERRANEAN_HARBOR, label: getAreaLabel(SeaArea.MEDITERRANEAN_HARBOR), emoji: '🏛️' },
    { value: SeaArea.AMERICAN_WATERFRONT, label: getAreaLabel(SeaArea.AMERICAN_WATERFRONT), emoji: '🗽' },
    { value: SeaArea.PORT_DISCOVERY, label: getAreaLabel(SeaArea.PORT_DISCOVERY), emoji: '🔬' },
    { value: SeaArea.LOST_RIVER_DELTA, label: getAreaLabel(SeaArea.LOST_RIVER_DELTA), emoji: '🏺' },
    { value: SeaArea.ARABIAN_COAST, label: getAreaLabel(SeaArea.ARABIAN_COAST), emoji: '🕌' },
    { value: SeaArea.MERMAID_LAGOON, label: getAreaLabel(SeaArea.MERMAID_LAGOON), emoji: '🧜‍♀️' },
    { value: SeaArea.MYSTERIOUS_ISLAND, label: getAreaLabel(SeaArea.MYSTERIOUS_ISLAND), emoji: '🌋' },
    { value: SeaArea.FANTASY_SPRINGS, label: getAreaLabel(SeaArea.FANTASY_SPRINGS), emoji: '❄️' },
  ];

  const areas = parkType === ParkType.LAND ? landAreas : seaAreas;

  // Filter areas based on search text
  const filteredAreas = useMemo(() => {
    if (!searchText) return areas;
    return areas.filter(area => 
      area.label.toLowerCase().includes(searchText.toLowerCase())
    );
  }, [areas, searchText]);

  const selectedAreaOption = areas.find(area => area.value === selectedArea);

  const handleAreaSelect = (area: ParkArea) => {
    onSelect?.(area);
    onAreaSelect?.(area);
    setIsOpen(false);
    setSearchText('');
  };

  const handleToggleOpen = () => {
    if (disabled) return;
    setIsOpen(!isOpen);
    if (!isOpen) {
      setSearchText('');
    }
  };

  return (
    <View style={[styles.container, style]}>
      {/* Dropdown Button */}
      <TouchableOpacity
        style={[
          styles.dropdownButton,
          {
            backgroundColor: theme.colors.background.secondary,
            borderColor: theme.colors.border,
            opacity: disabled ? 0.6 : 1,
          }
        ]}
        onPress={handleToggleOpen}
        disabled={disabled}
      >
        <View style={styles.dropdownContent}>
          {selectedAreaOption ? (
            <View style={styles.selectedContent}>
              <Text style={styles.selectedEmoji}>{selectedAreaOption.emoji}</Text>
              <Text style={[styles.selectedText, { color: theme.colors.text.primary }]}>
                {selectedAreaOption.label}
              </Text>
            </View>
          ) : (
            <Text style={[styles.placeholderText, { color: theme.colors.text.secondary }]}>
              {language === 'ja' ? 'エリアを選択してください' : 'Please select an area'}
            </Text>
          )}
        </View>
        <Ionicons 
          name={isOpen ? "chevron-up" : "chevron-down"} 
          size={20} 
          color={theme.colors.text.secondary} 
        />
      </TouchableOpacity>

      {/* Dropdown List */}
      {isOpen && (
        <View style={[styles.dropdownList, { backgroundColor: theme.colors.background.card }]}>
          {/* Search Input */}
          <View style={[styles.searchContainer, { backgroundColor: theme.colors.background.secondary }]}>
            <Ionicons name="search" size={16} color={theme.colors.text.secondary} />
            <TextInput
              style={[styles.searchInput, { color: theme.colors.text.primary }]}
              value={searchText}
              onChangeText={setSearchText}
              placeholder={language === 'ja' ? 'エリアを検索...' : 'Search areas...'}
              placeholderTextColor={theme.colors.text.secondary}
            />
            {searchText.length > 0 && (
              <TouchableOpacity
                onPress={() => setSearchText('')}
                style={styles.clearButton}
              >
                <Ionicons name="close-circle" size={16} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            )}
          </View>

          {/* Area Options */}
          <ScrollView 
            style={styles.optionsList} 
            contentContainerStyle={styles.optionsContent}
            showsVerticalScrollIndicator={true}
            nestedScrollEnabled={true}
            keyboardShouldPersistTaps="handled"
          >
            {filteredAreas.map((area, index) => {
              const isSelected = selectedArea === area.value;
              return (
                <TouchableOpacity
                  key={area.value}
                  style={[
                    styles.optionItem,
                    {
                      backgroundColor: isSelected 
                        ? colors.blue[500] + '20'
                        : 'transparent',
                    }
                  ]}
                  onPress={() => handleAreaSelect(area.value)}
                  activeOpacity={0.7}
                >
                  <Text style={styles.optionEmoji}>{area.emoji}</Text>
                  <Text style={[
                    styles.optionText,
                    { 
                      color: isSelected ? colors.blue[500] : theme.colors.text.primary,
                      fontWeight: isSelected ? '600' : '400'
                    }
                  ]}>
                    {area.label}
                  </Text>
                  {isSelected && (
                    <Ionicons name="checkmark" size={16} color={colors.blue[500]} />
                  )}
                </TouchableOpacity>
              );
            })}
            
            {filteredAreas.length === 0 && (
              <View style={styles.noResults}>
                <Text style={[styles.noResultsText, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '検索結果が見つかりません' : 'No search results found'}
                </Text>
              </View>
            )}
          </ScrollView>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'relative',
  },
  dropdownButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    borderRadius: borderRadius.md,
    borderWidth: 1,
    minHeight: 48,
  },
  dropdownContent: {
    flex: 1,
  },
  selectedContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectedEmoji: {
    fontSize: 18,
    marginRight: spacing[2],
  },
  selectedText: {
    fontSize: 16,
    fontWeight: '500',
  },
  placeholderText: {
    fontSize: 16,
  },
  dropdownList: {
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    zIndex: 1000,
    borderRadius: borderRadius.md,
    borderWidth: 1,
    borderColor: 'rgba(0, 0, 0, 0.1)',
    maxHeight: 280,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.1)',
  },
  searchInput: {
    flex: 1,
    fontSize: 14,
    marginLeft: spacing[2],
    paddingVertical: spacing[1],
  },
  clearButton: {
    padding: spacing[1],
  },
  optionsList: {
    flex: 1,
    maxHeight: 200,
  },
  optionsContent: {
    paddingBottom: spacing[2],
  },
  optionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.05)',
  },
  optionEmoji: {
    fontSize: 16,
    marginRight: spacing[2],
    width: 20,
  },
  optionText: {
    fontSize: 15,
    flex: 1,
  },
  noResults: {
    paddingVertical: spacing[4],
    alignItems: 'center',
  },
  noResultsText: {
    fontSize: 14,
  },
});
</file>

<file path="src/components/CalendarPicker.tsx">
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions,
  Animated,
} from 'react-native';
import { Calendar, DateData } from 'react-native-calendars';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';

const { width } = Dimensions.get('window');

interface CalendarPickerProps {
  selectedDate?: string;
  onDateSelect: (date: string) => void;
  minDate?: string;
  maxDate?: string;
}

export const CalendarPicker: React.FC<CalendarPickerProps> = ({
  selectedDate,
  onDateSelect,
  minDate,
  maxDate,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const isDark = theme.mode === 'dark';
  const [calendarVisible, setCalendarVisible] = useState(false);
  const [slideAnim] = useState(new Animated.Value(0));

  const toggleCalendar = () => {
    if (calendarVisible) {
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start(() => setCalendarVisible(false));
    } else {
      setCalendarVisible(true);
      Animated.timing(slideAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
    }
  };

  const handleDayPress = (day: DateData) => {
    onDateSelect(day.dateString);
    toggleCalendar();
  };

  const getTodayInJST = () => {
    const now = new Date();
    const jstOffset = 9 * 60; // JST is UTC+9
    const jstTime = new Date(now.getTime() + (jstOffset * 60 * 1000));
    return jstTime.toISOString().split('T')[0];
  };

  const getTomorrowInJST = () => {
    const now = new Date();
    const jstOffset = 9 * 60; // JST is UTC+9
    const jstTime = new Date(now.getTime() + (jstOffset * 60 * 1000));
    jstTime.setDate(jstTime.getDate() + 1);
    return jstTime.toISOString().split('T')[0];
  };

  const formatDisplayDate = (dateString?: string) => {
    if (!dateString) {
      return language === 'ja' ? '日付を選択' : 'Select Date';
    }
    
    const todayJST = getTodayInJST();
    const tomorrowJST = getTomorrowInJST();
    
    if (dateString === todayJST) {
      return language === 'ja' ? '今日' : 'Today';
    } else if (dateString === tomorrowJST) {
      return language === 'ja' ? '明日' : 'Tomorrow';
    } else {
      const date = new Date(dateString);
      const locale = language === 'ja' ? 'ja-JP' : 'en-US';
      return date.toLocaleDateString(locale, {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        weekday: 'short',
      });
    }
  };

  const calendarTheme = {
    backgroundColor: 'transparent',
    calendarBackground: 'transparent',
    textSectionTitleColor: colors.purple[400],
    textSectionTitleDisabledColor: theme.colors.text.secondary,
    selectedDayBackgroundColor: colors.purple[500],
    selectedDayTextColor: colors.utility.white,
    todayTextColor: colors.purple[600],
    dayTextColor: theme.colors.text.primary,
    textDisabledColor: theme.colors.text.secondary,
    dotColor: colors.purple[500],
    selectedDotColor: colors.utility.white,
    arrowColor: colors.purple[500],
    disabledArrowColor: theme.colors.text.secondary,
    monthTextColor: theme.colors.text.primary,
    indicatorColor: colors.purple[500],
    textDayFontFamily: 'System',
    textMonthFontFamily: 'System',
    textDayHeaderFontFamily: 'System',
    textDayFontWeight: '500',
    textMonthFontWeight: '700',
    textDayHeaderFontWeight: '600',
    textDayFontSize: 16,
    textMonthFontSize: 20,
    textDayHeaderFontSize: 14,
    'stylesheet.calendar.header': {
      week: {
        marginTop: spacing[2],
        flexDirection: 'row',
        justifyContent: 'space-around',
        paddingHorizontal: spacing[3],
      },
      header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingHorizontal: spacing[4],
        paddingVertical: spacing[3],
        backgroundColor: 'rgba(147, 51, 234, 0.1)',
        borderRadius: borderRadius.xl,
        marginBottom: spacing[4],
      },
    },
    'stylesheet.day.basic': {
      base: {
        width: 36,
        height: 36,
        alignItems: 'center',
        justifyContent: 'center',
        borderRadius: 18,
        marginVertical: spacing[1],
      },
      selected: {
        backgroundColor: colors.purple[500],
        borderRadius: 18,
        shadowColor: colors.purple[500],
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
        elevation: 8,
      },
      today: {
        backgroundColor: 'rgba(147, 51, 234, 0.2)',
        borderRadius: 18,
      },
    },
  };

  return (
    <View style={styles.container}>
      {/* Date Selector Button */}
      <TouchableOpacity
        onPress={toggleCalendar}
        style={[
          styles.dateButton,
          {
            backgroundColor: isDark
              ? theme.colors.background.secondary
              : theme.colors.background.elevated,
          },
        ]}
        activeOpacity={0.8}
      >
        <LinearGradient
          colors={
            selectedDate
              ? ['rgba(168, 85, 247, 0.1)', 'rgba(147, 51, 234, 0.1)']
              : ['transparent', 'transparent']
          }
          style={styles.dateButtonGradient}
        >
          <View style={styles.dateButtonContent}>
            <Ionicons
              name="calendar"
              size={24}
              color={selectedDate ? colors.purple[500] : theme.colors.text.secondary}
            />
            <Text
              style={[
                styles.dateButtonText,
                {
                  color: selectedDate
                    ? colors.purple[600]
                    : theme.colors.text.secondary,
                  fontWeight: selectedDate ? '600' : '500',
                },
              ]}
            >
              {formatDisplayDate(selectedDate)}
            </Text>
            <Ionicons
              name={calendarVisible ? 'chevron-up' : 'chevron-down'}
              size={20}
              color={theme.colors.text.secondary}
            />
          </View>
        </LinearGradient>
      </TouchableOpacity>

      {/* Calendar Modal */}
      {calendarVisible && (
        <Animated.View
          style={[
            styles.calendarContainer,
            {
              opacity: slideAnim,
              transform: [
                {
                  translateY: slideAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [-20, 0],
                  }),
                },
                {
                  scale: slideAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.95, 1],
                  }),
                },
              ],
            },
          ]}
        >
          <View style={[
            styles.calendarWrapper,
            {
              backgroundColor: colors.background.card,
              borderColor: colors.utility.border,
            }
          ]}>
            <View style={styles.calendarHeader}>
              <Text style={[styles.calendarTitle, { color: theme.colors.text.primary }]}>
                {language === 'ja' ? '日付を選択' : 'Select Date'}
              </Text>
              <TouchableOpacity
                onPress={toggleCalendar}
                style={styles.calendarCloseButton}
              >
                <Ionicons name="close" size={24} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            </View>
              <Calendar
                style={styles.calendar}
                theme={calendarTheme}
                current={selectedDate || new Date().toISOString().split('T')[0]}
                onDayPress={handleDayPress}
                markedDates={
                  selectedDate
                    ? {
                        [selectedDate]: {
                          selected: true,
                          disableTouchEvent: false,
                          selectedColor: colors.purple[500],
                          selectedTextColor: colors.utility.white,
                        },
                      }
                    : undefined
                }
                minDate={minDate}
                maxDate={maxDate}
                enableSwipeMonths={true}
                hideArrows={false}
                hideExtraDays={true}
                disableMonthChange={false}
                firstDay={0}
                hideDayNames={false}
                showWeekNumbers={false}
                disableArrowLeft={false}
                disableArrowRight={false}
                disableAllTouchEventsForDisabledDays={true}
                renderArrow={(direction) => (
                  <View style={styles.arrowContainer}>
                    <Ionicons
                      name={
                        direction === 'left' ? 'chevron-back' : 'chevron-forward'
                      }
                      size={24}
                      color={colors.purple[500]}
                    />
                  </View>
                )}
              />
          </View>
        </Animated.View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: spacing[4],
    zIndex: 1000,
  },
  dateButton: {
    borderRadius: borderRadius.xl,
    borderWidth: 1,
    borderColor: colors.utility.border,
    backgroundColor: colors.background.card,
    shadowColor: colors.effects.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 1,
    shadowRadius: 4,
    elevation: 2,
  },
  dateButtonGradient: {
    padding: spacing[4],
  },
  dateButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  dateButtonText: {
    fontSize: 16,
    flex: 1,
    marginLeft: spacing[3],
    textAlign: 'left',
  },
  calendarContainer: {
    position: 'absolute',
    top: 70,
    left: 0,
    right: 0,
    zIndex: 1001,
  },
  calendarWrapper: {
    borderRadius: borderRadius['2xl'],
    borderWidth: 1,
    shadowColor: colors.effects.shadowMedium,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 1,
    shadowRadius: 12,
    elevation: 8,
  },
  calendarHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: spacing[5],
    paddingTop: spacing[4],
    paddingBottom: spacing[3],
    borderBottomWidth: 1,
    borderBottomColor: colors.utility.borderLight,
  },
  calendarTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  calendarCloseButton: {
    padding: spacing[2],
    borderRadius: borderRadius.md,
    backgroundColor: colors.background.tertiary,
  },
  calendar: {
    backgroundColor: 'transparent',
    paddingHorizontal: spacing[3],
    paddingBottom: spacing[4],
  },
  arrowContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(147, 51, 234, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
});
</file>

<file path="src/components/CategoryForm.tsx">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  Switch,
  Alert,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
// import DateTimePicker from '@react-native-community/datetimepicker'; // Removed dependency
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { ActionCategory } from '../types/models';

interface CategoryFormData {
  // Common fields
  time: Date;
  duration: string;
  notes: string;
  rating: number;
  
  // Attraction-specific
  waitTime: string;
  fastPass: boolean;
  
  // Restaurant-specific
  mealType: 'BREAKFAST' | 'LUNCH' | 'DINNER' | 'SNACK';
  reservationMade: boolean;
  partySize: string;
  
  // Shopping-specific
  purchaseAmount: string;
  purchasedItems: string;
  
  // Show/Greeting-specific
  performerNames: string;
  showTime: string;
  meetingDuration: string;
}

interface CategoryFormProps {
  category: ActionCategory;
  formData: Partial<CategoryFormData>;
  onFormDataChange: (data: Partial<CategoryFormData>) => void;
  visitDate: Date;
  style?: any;
}

export const CategoryForm: React.FC<CategoryFormProps> = ({
  category,
  formData,
  onFormDataChange,
  visitDate,
  style,
}) => {
  const { theme } = useTheme();
  const [showTimePicker, setShowTimePicker] = useState(false);

  const getCategoryColor = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return colors.purple[500];
      case ActionCategory.RESTAURANT:
        return colors.orange[500];
      case ActionCategory.SHOW:
        return colors.pink[500];
      case ActionCategory.GREETING:
        return colors.yellow[500];
      case ActionCategory.SHOPPING:
        return colors.green[500];
      default:
        return colors.gray[500];
    }
  };

  const getCategoryIcon = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      default:
        return 'calendar';
    }
  };

  const updateFormData = (updates: Partial<CategoryFormData>) => {
    onFormDataChange({ ...formData, ...updates });
  };

  const renderStarRating = () => {
    return (
      <View style={styles.inputGroup}>
        <Text style={[styles.label, { color: theme.colors.text.primary }]}>
          Rating
        </Text>
        <View style={styles.starContainer}>
          {[1, 2, 3, 4, 5].map(star => (
            <TouchableOpacity
              key={star}
              onPress={() => updateFormData({ 
                rating: formData.rating === star ? 0 : star 
              })}
              style={styles.starButton}
            >
              <Ionicons
                name={star <= (formData.rating || 0) ? 'star' : 'star-outline'}
                size={24}
                color={colors.yellow[500]}
              />
            </TouchableOpacity>
          ))}
        </View>
      </View>
    );
  };

  const renderTimeInput = () => (
    <View style={styles.inputGroup}>
      <Text style={[styles.label, { color: theme.colors.text.primary }]}>
        Time *
      </Text>
      <TouchableOpacity
        style={[
          styles.input,
          styles.timeInput,
          {
            backgroundColor: theme.colors.background.elevated,
            borderColor: theme.colors.border,
          },
        ]}
        onPress={() => setShowTimePicker(true)}
      >
        <Text style={[styles.timeText, { color: theme.colors.text.primary }]}>
          {(formData.time || visitDate).toLocaleTimeString('ja-JP', {
            hour: '2-digit',
            minute: '2-digit',
          })}
        </Text>
        <Ionicons name="time-outline" size={20} color={theme.colors.text.secondary} />
      </TouchableOpacity>
    </View>
  );

  const renderDurationInput = () => (
    <View style={styles.inputGroup}>
      <Text style={[styles.label, { color: theme.colors.text.primary }]}>
        Duration (minutes)
      </Text>
      <TextInput
        style={[
          styles.input,
          {
            backgroundColor: theme.colors.background.elevated,
            color: theme.colors.text.primary,
            borderColor: theme.colors.border,
          },
        ]}
        value={formData.duration || ''}
        onChangeText={(text) => updateFormData({ duration: text })}
        placeholder="30"
        placeholderTextColor={theme.colors.text.tertiary}
        keyboardType="numeric"
      />
    </View>
  );

  const renderNotesInput = () => (
    <View style={styles.inputGroup}>
      <Text style={[styles.label, { color: theme.colors.text.primary }]}>
        Notes
      </Text>
      <TextInput
        style={[
          styles.input,
          styles.notesInput,
          {
            backgroundColor: theme.colors.background.elevated,
            color: theme.colors.text.primary,
            borderColor: theme.colors.border,
          },
        ]}
        value={formData.notes || ''}
        onChangeText={(text) => updateFormData({ notes: text })}
        placeholder="Add your thoughts about this experience..."
        placeholderTextColor={theme.colors.text.tertiary}
        multiline
        numberOfLines={3}
        textAlignVertical="top"
      />
    </View>
  );

  const renderAttractionFields = () => (
    <>
      <View style={styles.rowContainer}>
        <View style={[styles.inputGroup, styles.halfWidth]}>
          <Text style={[styles.label, { color: theme.colors.text.primary }]}>
            Wait Time (min)
          </Text>
          <TextInput
            style={[
              styles.input,
              {
                backgroundColor: theme.colors.background.elevated,
                color: theme.colors.text.primary,
                borderColor: theme.colors.border,
              },
            ]}
            value={formData.waitTime || ''}
            onChangeText={(text) => updateFormData({ waitTime: text })}
            placeholder="15"
            placeholderTextColor={theme.colors.text.tertiary}
            keyboardType="numeric"
          />
        </View>

        <View style={[styles.inputGroup, styles.halfWidth]}>
          <Text style={[styles.label, { color: theme.colors.text.primary }]}>
            Fast Pass
          </Text>
          <View style={styles.switchContainer}>
            <Switch
              value={formData.fastPass || false}
              onValueChange={(value) => updateFormData({ fastPass: value })}
              trackColor={{ 
                false: theme.colors.background.elevated, 
                true: getCategoryColor(category) 
              }}
              thumbColor={formData.fastPass ? 'white' : theme.colors.text.tertiary}
            />
            <Text style={[styles.switchLabel, { color: theme.colors.text.secondary }]}>
              {formData.fastPass ? 'Used' : 'None'}
            </Text>
          </View>
        </View>
      </View>
    </>
  );

  const renderRestaurantFields = () => (
    <>
      <View style={styles.inputGroup}>
        <Text style={[styles.label, { color: theme.colors.text.primary }]}>
          Meal Type
        </Text>
        <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.chipContainer}>
          {['BREAKFAST', 'LUNCH', 'DINNER', 'SNACK'].map(type => (
            <TouchableOpacity
              key={type}
              style={[
                styles.chip,
                {
                  backgroundColor: formData.mealType === type
                    ? getCategoryColor(category)
                    : theme.colors.background.elevated,
                  borderColor: formData.mealType === type
                    ? getCategoryColor(category)
                    : theme.colors.border,
                },
              ]}
              onPress={() => updateFormData({ mealType: type as any })}
            >
              <Text
                style={[
                  styles.chipText,
                  {
                    color: formData.mealType === type
                      ? 'white'
                      : theme.colors.text.primary,
                  },
                ]}
              >
                {type}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>

      <View style={styles.rowContainer}>
        <View style={[styles.inputGroup, styles.halfWidth]}>
          <Text style={[styles.label, { color: theme.colors.text.primary }]}>
            Party Size
          </Text>
          <TextInput
            style={[
              styles.input,
              {
                backgroundColor: theme.colors.background.elevated,
                color: theme.colors.text.primary,
                borderColor: theme.colors.border,
              },
            ]}
            value={formData.partySize || ''}
            onChangeText={(text) => updateFormData({ partySize: text })}
            placeholder="2"
            placeholderTextColor={theme.colors.text.tertiary}
            keyboardType="numeric"
          />
        </View>

        <View style={[styles.inputGroup, styles.halfWidth]}>
          <Text style={[styles.label, { color: theme.colors.text.primary }]}>
            Reservation
          </Text>
          <View style={styles.switchContainer}>
            <Switch
              value={formData.reservationMade || false}
              onValueChange={(value) => updateFormData({ reservationMade: value })}
              trackColor={{ 
                false: theme.colors.background.elevated, 
                true: getCategoryColor(category) 
              }}
              thumbColor={formData.reservationMade ? 'white' : theme.colors.text.tertiary}
            />
            <Text style={[styles.switchLabel, { color: theme.colors.text.secondary }]}>
              {formData.reservationMade ? 'Made' : 'Walk-in'}
            </Text>
          </View>
        </View>
      </View>
    </>
  );

  const renderShoppingFields = () => (
    <>
      <View style={styles.inputGroup}>
        <Text style={[styles.label, { color: theme.colors.text.primary }]}>
          Purchase Amount (¥)
        </Text>
        <TextInput
          style={[
            styles.input,
            {
              backgroundColor: theme.colors.background.elevated,
              color: theme.colors.text.primary,
              borderColor: theme.colors.border,
            },
          ]}
          value={formData.purchaseAmount || ''}
          onChangeText={(text) => updateFormData({ purchaseAmount: text })}
          placeholder="0"
          placeholderTextColor={theme.colors.text.tertiary}
          keyboardType="numeric"
        />
      </View>

      <View style={styles.inputGroup}>
        <Text style={[styles.label, { color: theme.colors.text.primary }]}>
          Items Purchased
        </Text>
        <TextInput
          style={[
            styles.input,
            styles.notesInput,
            {
              backgroundColor: theme.colors.background.elevated,
              color: theme.colors.text.primary,
              borderColor: theme.colors.border,
            },
          ]}
          value={formData.purchasedItems || ''}
          onChangeText={(text) => updateFormData({ purchasedItems: text })}
          placeholder="T-shirt, Keychain, etc. (separate with commas)"
          placeholderTextColor={theme.colors.text.tertiary}
          multiline
          numberOfLines={2}
          textAlignVertical="top"
        />
      </View>
    </>
  );

  const renderShowGreetingFields = () => (
    <>
      <View style={styles.inputGroup}>
        <Text style={[styles.label, { color: theme.colors.text.primary }]}>
          {category === ActionCategory.SHOW ? 'Show Time' : 'Meeting Duration (min)'}
        </Text>
        <TextInput
          style={[
            styles.input,
            {
              backgroundColor: theme.colors.background.elevated,
              color: theme.colors.text.primary,
              borderColor: theme.colors.border,
            },
          ]}
          value={category === ActionCategory.SHOW ? (formData.showTime || '') : (formData.meetingDuration || '')}
          onChangeText={(text) => updateFormData(
            category === ActionCategory.SHOW 
              ? { showTime: text } 
              : { meetingDuration: text }
          )}
          placeholder={category === ActionCategory.SHOW ? "14:30 Show" : "5"}
          placeholderTextColor={theme.colors.text.tertiary}
          keyboardType={category === ActionCategory.GREETING ? "numeric" : "default"}
        />
      </View>

      <View style={styles.inputGroup}>
        <Text style={[styles.label, { color: theme.colors.text.primary }]}>
          {category === ActionCategory.SHOW ? 'Performers' : 'Characters Met'}
        </Text>
        <TextInput
          style={[
            styles.input,
            {
              backgroundColor: theme.colors.background.elevated,
              color: theme.colors.text.primary,
              borderColor: theme.colors.border,
            },
          ]}
          value={formData.performerNames || ''}
          onChangeText={(text) => updateFormData({ performerNames: text })}
          placeholder="Mickey Mouse, Minnie Mouse (separate with commas)"
          placeholderTextColor={theme.colors.text.tertiary}
          multiline
        />
      </View>
    </>
  );

  const renderCategorySpecificFields = () => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return renderAttractionFields();
      case ActionCategory.RESTAURANT:
        return renderRestaurantFields();
      case ActionCategory.SHOPPING:
        return renderShoppingFields();
      case ActionCategory.SHOW:
      case ActionCategory.GREETING:
        return renderShowGreetingFields();
      default:
        return null;
    }
  };

  return (
    <ScrollView 
      style={[styles.container, style]}
      showsVerticalScrollIndicator={false}
      keyboardShouldPersistTaps="handled"
    >
      <View style={styles.header}>
        <LinearGradient
          colors={[getCategoryColor(category), `${getCategoryColor(category)}80`]}
          style={styles.headerGradient}
        >
          <Ionicons
            name={getCategoryIcon(category) as any}
            size={24}
            color="white"
          />
          <Text style={styles.headerTitle}>
            {category.charAt(0) + category.slice(1).toLowerCase()} Details
          </Text>
        </LinearGradient>
      </View>

      <View style={styles.content}>
        {renderTimeInput()}
        {renderDurationInput()}
        {renderCategorySpecificFields()}
        {renderStarRating()}
        {renderNotesInput()}
      </View>

      {/* Time Picker Modal - Functionality disabled due to removed dependency */}
      {showTimePicker && (
        <View style={styles.timePickerPlaceholder}>
          <Text style={[styles.placeholderText, { color: theme.colors.text.secondary }]}>
            Time picker functionality is unavailable
          </Text>
          <TouchableOpacity
            style={[styles.placeholderButton, { backgroundColor: colors.purple[500] }]}
            onPress={() => setShowTimePicker(false)}
          >
            <Text style={styles.placeholderButtonText}>Close</Text>
          </TouchableOpacity>
        </View>
      )}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    marginBottom: spacing[4],
  },
  headerGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: spacing[4],
    borderRadius: borderRadius.lg,
    margin: spacing[4],
    marginBottom: 0,
  },
  headerTitle: {
    color: 'white',
    fontSize: 18,
    fontWeight: '700',
    marginLeft: spacing[2],
  },
  content: {
    paddingHorizontal: spacing[4],
  },
  inputGroup: {
    marginBottom: spacing[4],
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: spacing[2],
  },
  input: {
    borderWidth: 1,
    borderRadius: borderRadius.lg,
    padding: spacing[3],
    fontSize: 16,
    fontWeight: '500',
  },
  timeInput: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  timeText: {
    fontSize: 16,
    fontWeight: '500',
  },
  notesInput: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  rowContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: spacing[4],
  },
  halfWidth: {
    width: '48%',
    marginBottom: 0,
  },
  switchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: spacing[1],
  },
  switchLabel: {
    marginLeft: spacing[2],
    fontSize: 14,
    fontWeight: '500',
  },
  chipContainer: {
    marginTop: spacing[1],
  },
  chip: {
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.lg,
    borderWidth: 1,
    marginRight: spacing[2],
  },
  chipText: {
    fontSize: 14,
    fontWeight: '600',
  },
  starContainer: {
    flexDirection: 'row',
    marginTop: spacing[1],
  },
  starButton: {
    padding: spacing[1],
    marginRight: spacing[1],
  },
  timePickerPlaceholder: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  placeholderText: {
    fontSize: 16,
    marginBottom: spacing[4],
  },
  placeholderButton: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.lg,
  },
  placeholderButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});
</file>

<file path="src/components/CompanionManager.tsx">
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  Alert,
  Animated,
  Dimensions,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { Companion } from '../types/models';

const { width } = Dimensions.get('window');

interface CompanionManagerProps {
  companions: Companion[];
  selectedCompanionIds: string[];
  onCompanionToggle: (companionId: string) => void;
  onCompanionCreate: (name: string) => Promise<void>;
  onCompanionDelete?: (companionId: string) => Promise<void>;
  isCreating?: boolean;
}

export const CompanionManager: React.FC<CompanionManagerProps> = ({
  companions,
  selectedCompanionIds,
  onCompanionToggle,
  onCompanionCreate,
  onCompanionDelete,
  isCreating = false,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const isDark = theme.mode === 'dark';
  
  const [showAddForm, setShowAddForm] = useState(false);
  const [newCompanionName, setNewCompanionName] = useState('');
  const [isAdding, setIsAdding] = useState(false);
  
  const slideAnim = useRef(new Animated.Value(0)).current;
  const scaleAnims = useRef(new Map<string, Animated.Value>()).current;

  // Initialize scale animations for companions
  React.useEffect(() => {
    companions.forEach(companion => {
      if (!scaleAnims.has(companion.id)) {
        scaleAnims.set(companion.id, new Animated.Value(1));
      }
    });
  }, [companions]);

  const toggleAddForm = () => {
    if (showAddForm) {
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start(() => {
        setShowAddForm(false);
        setNewCompanionName('');
      });
    } else {
      setShowAddForm(true);
      Animated.timing(slideAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
    }
  };

  const handleAddCompanion = async () => {
    if (!newCompanionName.trim()) {
      Alert.alert(
        language === 'ja' ? 'エラー' : 'Error',
        language === 'ja' ? '同行者の名前を入力してください' : 'Please enter a companion name'
      );
      return;
    }

    setIsAdding(true);
    try {
      await onCompanionCreate(newCompanionName.trim());
      setNewCompanionName('');
      toggleAddForm();
    } catch (error) {
      Alert.alert(
        language === 'ja' ? 'エラー' : 'Error',
        language === 'ja' ? '同行者の追加に失敗しました' : 'Failed to add companion'
      );
    } finally {
      setIsAdding(false);
    }
  };

  const handleCompanionToggle = (companionId: string) => {
    const scaleAnim = scaleAnims.get(companionId);
    if (scaleAnim) {
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          useNativeDriver: true,
          tension: 300,
          friction: 10,
        }),
      ]).start();
    }
    onCompanionToggle(companionId);
  };

  const handleDeleteCompanion = (companion: Companion) => {
    Alert.alert(
      'Delete Companion',
      `Are you sure you want to delete "${companion.name}"? This will remove them from all visits.`,
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            if (onCompanionDelete) {
              try {
                await onCompanionDelete(companion.id);
              } catch (error) {
                Alert.alert('Error', 'Failed to delete companion');
              }
            }
          },
        },
      ]
    );
  };

  const getAvatarColor = (name: string) => {
    const colors = [
      '#ff6b6b', '#4ecdc4', '#45b7b8', '#96ceb4', '#feca57',
      '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43',
      '#10ac84', '#ee5a6f', '#c44569', '#f8b500', '#778beb',
    ];
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash) % colors.length];
  };

  const renderCompanionItem = ({ item: companion }: { item: Companion }) => {
    const isSelected = selectedCompanionIds.includes(companion.id);
    const scaleAnim = scaleAnims.get(companion.id) || new Animated.Value(1);
    const avatarColor = getAvatarColor(companion.name);

    return (
      <Animated.View
        style={[
          styles.companionItemContainer,
          { transform: [{ scale: scaleAnim }] },
        ]}
      >
        <TouchableOpacity
          activeOpacity={0.8}
          onPress={() => handleCompanionToggle(companion.id)}
          style={[
            styles.companionItem,
            {
              backgroundColor: isDark
                ? isSelected
                  ? 'rgba(147, 51, 234, 0.3)'
                  : theme.colors.background.secondary
                : isSelected
                ? 'rgba(147, 51, 234, 0.1)'
                : theme.colors.background.elevated,
            },
          ]}
        >
          <LinearGradient
            colors={
              isSelected
                ? ['rgba(147, 51, 234, 0.2)', 'rgba(168, 85, 247, 0.1)']
                : ['transparent', 'transparent']
            }
            style={styles.companionGradient}
          >
            <View style={styles.companionContent}>
              {/* Avatar */}
              <View
                style={[
                  styles.avatar,
                  {
                    backgroundColor: isSelected ? colors.purple[500] : avatarColor,
                  },
                ]}
              >
                <Text
                  style={[
                    styles.avatarText,
                    {
                      color: isSelected
                        ? colors.utility.white
                        : colors.text.primary,
                    },
                  ]}
                >
                  {companion.name.charAt(0).toUpperCase()}
                </Text>
              </View>

              {/* Name and Details */}
              <View style={styles.companionInfo}>
                <Text
                  style={[
                    styles.companionName,
                    {
                      color: isSelected
                        ? colors.purple[600]
                        : theme.colors.text.primary,
                      fontWeight: isSelected ? '600' : '500',
                    },
                  ]}
                >
                  {companion.name}
                </Text>
                {companion.visitIds.length > 0 && (
                  <Text
                    style={[
                      styles.visitCount,
                      { color: theme.colors.text.secondary },
                    ]}
                  >
                    {companion.visitIds.length} visit{companion.visitIds.length !== 1 ? 's' : ''}
                  </Text>
                )}
              </View>

              {/* Selection Indicator */}
              <View style={styles.selectionArea}>
                {isSelected ? (
                  <View style={styles.selectedIndicator}>
                    <Ionicons
                      name="checkmark-circle"
                      size={24}
                      color={colors.purple[500]}
                    />
                  </View>
                ) : (
                  <View
                    style={[
                      styles.unselectedIndicator,
                      {
                        borderColor: theme.colors.text.secondary,
                      },
                    ]}
                  />
                )}
              </View>

              {/* Delete Button */}
              {onCompanionDelete && (
                <TouchableOpacity
                  style={styles.deleteButton}
                  onPress={() => handleDeleteCompanion(companion)}
                  hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                >
                  <Ionicons
                    name="trash-outline"
                    size={18}
                    color={theme.colors.text.secondary}
                  />
                </TouchableOpacity>
              )}
            </View>
          </LinearGradient>
        </TouchableOpacity>
      </Animated.View>
    );
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
          {language === 'ja' ? '一緒に行く人は？' : 'Who are you going with?'}
        </Text>
        <TouchableOpacity
          onPress={toggleAddForm}
          style={[
            styles.addButton,
            {
              backgroundColor: colors.purple[500],
            },
          ]}
          disabled={isCreating}
        >
          <Ionicons
            name={showAddForm ? 'close' : 'add'}
            size={20}
            color={colors.utility.white}
          />
        </TouchableOpacity>
      </View>

      {/* Add Form */}
      {showAddForm && (
        <Animated.View
          style={[
            styles.addFormContainer,
            {
              opacity: slideAnim,
              transform: [
                {
                  translateY: slideAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [-20, 0],
                  }),
                },
              ],
            },
          ]}
        >
          <BlurView
            intensity={60}
            style={[
              styles.addFormBlur,
              {
                backgroundColor: isDark
                  ? 'rgba(30, 30, 30, 0.8)'
                  : 'rgba(255, 255, 255, 0.8)',
              },
            ]}
          >
            <LinearGradient
              colors={[
                'rgba(147, 51, 234, 0.1)',
                'rgba(168, 85, 247, 0.05)',
              ]}
              style={styles.addFormGradient}
            >
              <View style={styles.addFormContent}>
                <TextInput
                  style={[
                    styles.nameInput,
                    {
                      color: theme.colors.text.primary,
                      backgroundColor: isDark
                        ? 'rgba(255, 255, 255, 0.1)'
                        : 'rgba(0, 0, 0, 0.05)',
                    },
                  ]}
                  placeholder={language === 'ja' ? '一緒に行く人の名前を入力' : 'Enter companion name'}
                  placeholderTextColor={theme.colors.text.secondary}
                  value={newCompanionName}
                  onChangeText={setNewCompanionName}
                  autoFocus
                  maxLength={50}
                />
                
                <View style={styles.addFormActions}>
                  <TouchableOpacity
                    onPress={toggleAddForm}
                    style={[
                      styles.formButton,
                      styles.cancelButton,
                      {
                        backgroundColor: theme.colors.background.secondary,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.formButtonText,
                        { color: theme.colors.text.secondary },
                      ]}
                    >
                      {language === 'ja' ? 'キャンセル' : 'Cancel'}
                    </Text>
                  </TouchableOpacity>
                  
                  <TouchableOpacity
                    onPress={handleAddCompanion}
                    disabled={isAdding || !newCompanionName.trim()}
                    style={[
                      styles.formButton,
                      styles.saveButton,
                      {
                        backgroundColor: colors.purple[500],
                        opacity: isAdding || !newCompanionName.trim() ? 0.5 : 1,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.formButtonText,
                        { color: colors.utility.white },
                      ]}
                    >
                      {isAdding 
                        ? (language === 'ja' ? '追加中...' : 'Adding...') 
                        : (language === 'ja' ? '追加' : 'Add')
                      }
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </LinearGradient>
          </BlurView>
        </Animated.View>
      )}

      {/* Companions List */}
      {companions.length > 0 ? (
        <View style={styles.listContainer}>
          {companions.map((companion, index) => (
            <View key={companion.id}>
              {renderCompanionItem({ item: companion, index })}
              {index < companions.length - 1 && <View style={{ height: spacing[3] }} />}
            </View>
          ))}
        </View>
      ) : (
        <View style={styles.emptyState}>
          <Ionicons
            name="people-outline"
            size={48}
            color={theme.colors.text.secondary}
          />
          <Text
            style={[
              styles.emptyStateText,
              { color: theme.colors.text.secondary },
            ]}
          >
            {language === 'ja' ? '同行者がまだいません' : 'No companions yet'}
          </Text>
          <Text
            style={[
              styles.emptyStateSubtext,
              { color: theme.colors.text.secondary },
            ]}
          >
            {language === 'ja' ? '一緒に行った友達や家族を追加しましょう' : 'Add friends or family members you went with'}
          </Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: spacing[6],
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[4],
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
  },
  addButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
  },
  addFormContainer: {
    marginBottom: spacing[4],
  },
  addFormBlur: {
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  addFormGradient: {
    padding: spacing[4],
  },
  addFormContent: {
    gap: spacing[3],
  },
  nameInput: {
    fontSize: 16,
    padding: spacing[3],
    borderRadius: borderRadius.lg,
    borderWidth: 1,
    borderColor: 'rgba(147, 51, 234, 0.2)',
  },
  addFormActions: {
    flexDirection: 'row',
    gap: spacing[3],
  },
  formButton: {
    flex: 1,
    padding: spacing[3],
    borderRadius: borderRadius.lg,
    alignItems: 'center',
  },
  cancelButton: {},
  saveButton: {},
  formButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  listContainer: {
    paddingBottom: spacing[4],
  },
  companionItemContainer: {
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  companionItem: {
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  companionGradient: {
    padding: spacing[4],
  },
  companionContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: spacing[3],
  },
  avatarText: {
    fontSize: 18,
    fontWeight: '600',
  },
  companionInfo: {
    flex: 1,
  },
  companionName: {
    fontSize: 16,
    marginBottom: spacing[1],
  },
  visitCount: {
    fontSize: 14,
  },
  selectionArea: {
    marginRight: spacing[2],
  },
  selectedIndicator: {
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  unselectedIndicator: {
    width: 20,
    height: 20,
    borderRadius: 10,
    borderWidth: 2,
  },
  deleteButton: {
    padding: spacing[2],
  },
  emptyState: {
    alignItems: 'center',
    paddingVertical: spacing[8],
    gap: spacing[3],
  },
  emptyStateText: {
    fontSize: 18,
    fontWeight: '600',
  },
  emptyStateSubtext: {
    fontSize: 14,
    textAlign: 'center',
    lineHeight: 20,
    paddingHorizontal: spacing[4],
  },
});
</file>

<file path="src/components/LocationSelector.tsx">
import React, { useState, useMemo } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  TextInput,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { ActionCategory, ParkType, ParkArea } from '../types/models';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import {
  PRESET_ATTRACTIONS_BY_AREA,
  PRESET_RESTAURANTS_BY_AREA,
  PRESET_SHOPS_BY_AREA,
  PRESET_GREETING_BY_AREA,
} from '../constants/presets';

interface LocationSelectorProps {
  category: ActionCategory;
  parkType: ParkType;
  area: ParkArea;
  selectedLocation: string;
  onLocationSelect: (locationName: string) => void;
  onCustomLocation?: (locationName: string) => void;
}

export const LocationSelector: React.FC<LocationSelectorProps> = ({
  category,
  parkType,
  area,
  selectedLocation,
  onLocationSelect,
  onCustomLocation,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const [searchText, setSearchText] = useState('');
  const [isOpen, setIsOpen] = useState(false);

  const presetLocations = useMemo(() => {
    const parkKey = parkType === ParkType.LAND ? 'land' : 'sea';
    
    let locations: string[] = [];
    
    switch (category) {
      case ActionCategory.ATTRACTION:
        locations = PRESET_ATTRACTIONS_BY_AREA[parkKey]?.[area] || [];
        break;
      case ActionCategory.RESTAURANT:
        locations = PRESET_RESTAURANTS_BY_AREA[parkKey]?.[area] || [];
        break;
      case ActionCategory.SHOPPING:
        locations = PRESET_SHOPS_BY_AREA[parkKey]?.[area] || [];
        break;
      case ActionCategory.GREETING:
        locations = PRESET_GREETING_BY_AREA[parkKey]?.[area] || [];
        break;
      case ActionCategory.SHOW:
        // Shows don't have specific presets, allow custom input
        locations = [];
        break;
      default:
        locations = [];
    }
    
    return locations;
  }, [category, parkType, area]);

  const filteredLocations = useMemo(() => {
    if (!searchText) return presetLocations;
    
    return presetLocations.filter(location =>
      location.toLowerCase().includes(searchText.toLowerCase())
    );
  }, [presetLocations, searchText]);

  const handleLocationSelect = (location: string) => {
    onLocationSelect(location);
    setIsOpen(false);
    setSearchText('');
  };

  const handleCustomSubmit = () => {
    if (searchText.trim()) {
      onCustomLocation?.(searchText.trim());
      onLocationSelect(searchText.trim());
      setSearchText('');
      setIsOpen(false);
    }
  };

  const handleToggleOpen = () => {
    setIsOpen(!isOpen);
    if (!isOpen) {
      setSearchText('');
    }
  };

  const getCategoryIcon = (category: ActionCategory): string => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      default:
        return 'location';
    }
  };

  const getCategoryName = (category: ActionCategory): string => {
    if (language === 'ja') {
      switch (category) {
        case ActionCategory.ATTRACTION:
          return 'アトラクション';
        case ActionCategory.RESTAURANT:
          return 'レストラン';
        case ActionCategory.SHOW:
          return 'ショー';
        case ActionCategory.GREETING:
          return 'グリーティング';
        case ActionCategory.SHOPPING:
          return 'ショッピング';
        default:
          return '施設';
      }
    } else {
      switch (category) {
        case ActionCategory.ATTRACTION:
          return 'Attraction';
        case ActionCategory.RESTAURANT:
          return 'Restaurant';
        case ActionCategory.SHOW:
          return 'Show';
        case ActionCategory.GREETING:
          return 'Greeting';
        case ActionCategory.SHOPPING:
          return 'Shopping';
        default:
          return 'Facility';
      }
    }
  };

  return (
    <View style={styles.container}>
      {/* Dropdown Button */}
      <TouchableOpacity
        style={[
          styles.dropdownButton,
          {
            backgroundColor: theme.colors.background.secondary,
            borderColor: theme.colors.border,
          }
        ]}
        onPress={handleToggleOpen}
      >
        <View style={styles.dropdownContent}>
          <Ionicons 
            name={getCategoryIcon(category) as any} 
            size={18} 
            color={theme.colors.text.secondary}
            style={styles.categoryIcon}
          />
          {selectedLocation ? (
            <Text style={[styles.selectedText, { color: theme.colors.text.primary }]}>
              {selectedLocation}
            </Text>
          ) : (
            <Text style={[styles.placeholderText, { color: theme.colors.text.secondary }]}>
              {language === 'ja' ? `${getCategoryName(category)}を選択してください` : `Please select a ${getCategoryName(category).toLowerCase()}`}
            </Text>
          )}
        </View>
        <Ionicons 
          name={isOpen ? "chevron-up" : "chevron-down"} 
          size={20} 
          color={theme.colors.text.secondary} 
        />
      </TouchableOpacity>

      {/* Dropdown List */}
      {isOpen && (
        <View style={[styles.dropdownList, { backgroundColor: theme.colors.background.card }]}>
          {/* Search Input */}
          <View style={[styles.searchContainer, { backgroundColor: theme.colors.background.secondary }]}>
            <Ionicons name="search" size={16} color={theme.colors.text.secondary} />
            <TextInput
              style={[styles.searchInput, { color: theme.colors.text.primary }]}
              value={searchText}
              onChangeText={setSearchText}
              placeholder={language === 'ja' ? `${getCategoryName(category)}を検索または入力...` : `Search or enter ${getCategoryName(category).toLowerCase()}...`}
              placeholderTextColor={theme.colors.text.secondary}
              onSubmitEditing={handleCustomSubmit}
              returnKeyType="done"
            />
            {searchText.length > 0 && (
              <TouchableOpacity
                onPress={() => setSearchText('')}
                style={styles.clearButton}
              >
                <Ionicons name="close-circle" size={16} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            )}
          </View>

          {/* Location Options */}
          <ScrollView 
            style={styles.optionsList} 
            contentContainerStyle={styles.optionsContent}
            showsVerticalScrollIndicator={true}
            nestedScrollEnabled={true}
            keyboardShouldPersistTaps="handled"
          >
            {/* Preset Locations */}
            {filteredLocations.map((location, index) => {
              const isSelected = selectedLocation === location;
              return (
                <TouchableOpacity
                  key={`preset-${location}-${index}`}
                  style={[
                    styles.optionItem,
                    {
                      backgroundColor: isSelected 
                        ? colors.blue[500] + '20'
                        : 'transparent',
                    }
                  ]}
                  onPress={() => handleLocationSelect(location)}
                  activeOpacity={0.7}
                >
                  <Ionicons 
                    name="business" 
                    size={16} 
                    color={isSelected ? colors.blue[500] : theme.colors.text.secondary}
                    style={styles.optionIcon}
                  />
                  <Text style={[
                    styles.optionText,
                    { 
                      color: isSelected ? colors.blue[500] : theme.colors.text.primary,
                      fontWeight: isSelected ? '600' : '400'
                    }
                  ]}>
                    {location}
                  </Text>
                  {isSelected && (
                    <Ionicons name="checkmark" size={16} color={colors.blue[500]} />
                  )}
                </TouchableOpacity>
              );
            })}
            
            {/* Custom Location Option */}
            {searchText.length > 0 && (
              <TouchableOpacity
                style={[
                  styles.optionItem,
                  styles.customOption,
                  { backgroundColor: colors.green[500] + '10' }
                ]}
                onPress={handleCustomSubmit}
                activeOpacity={0.7}
              >
                <Ionicons 
                  name="add-circle-outline" 
                  size={16} 
                  color={colors.green[500]}
                  style={styles.optionIcon}
                />
                <Text style={[styles.optionText, { color: colors.green[500], fontWeight: '600' }]}>
                  {language === 'ja' ? `「${searchText}」を追加` : `Add "${searchText}"`}
                </Text>
              </TouchableOpacity>
            )}
            
            {/* No Results */}
            {filteredLocations.length === 0 && searchText.length === 0 && presetLocations.length === 0 && (
              <View style={styles.noResults}>
                <Text style={[styles.noResultsText, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? 'このカテゴリには定型の施設がありません' : 'No preset facilities for this category'}
                </Text>
                <Text style={[styles.noResultsSubtext, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '上の検索欄に施設名を入力してください' : 'Please enter a facility name in the search field above'}
                </Text>
              </View>
            )}
            
            {filteredLocations.length === 0 && searchText.length > 0 && (
              <View style={styles.noResults}>
                <Text style={[styles.noResultsText, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? `「${searchText}」に一致する施設が見つかりません` : `No facilities found matching "${searchText}"`}
                </Text>
                <Text style={[styles.noResultsSubtext, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '新しい施設として追加するには上の緑色のオプションをタップしてください' : 'Tap the green option above to add as a new facility'}
                </Text>
              </View>
            )}
          </ScrollView>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'relative',
  },
  dropdownButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    borderRadius: borderRadius.md,
    borderWidth: 1,
    minHeight: 48,
  },
  dropdownContent: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
  },
  categoryIcon: {
    marginRight: spacing[2],
  },
  selectedText: {
    fontSize: 16,
    fontWeight: '500',
  },
  placeholderText: {
    fontSize: 16,
  },
  dropdownList: {
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    zIndex: 1000,
    borderRadius: borderRadius.md,
    borderWidth: 1,
    borderColor: 'rgba(0, 0, 0, 0.1)',
    maxHeight: 320,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.1)',
  },
  searchInput: {
    flex: 1,
    fontSize: 14,
    marginLeft: spacing[2],
    paddingVertical: spacing[1],
  },
  clearButton: {
    padding: spacing[1],
  },
  optionsList: {
    flex: 1,
    maxHeight: 240,
  },
  optionsContent: {
    paddingBottom: spacing[2],
  },
  optionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[3],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.05)',
  },
  optionIcon: {
    marginRight: spacing[2],
    width: 16,
  },
  optionText: {
    fontSize: 15,
    flex: 1,
  },
  customOption: {
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 0, 0, 0.1)',
  },
  noResults: {
    paddingVertical: spacing[4],
    paddingHorizontal: spacing[3],
    alignItems: 'center',
  },
  noResultsText: {
    fontSize: 14,
    textAlign: 'center',
    marginBottom: spacing[1],
  },
  noResultsSubtext: {
    fontSize: 12,
    textAlign: 'center',
    lineHeight: 16,
  },
});
</file>

<file path="src/components/ParkSelector.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions,
  Animated,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons, FontAwesome5 } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { ParkType } from '../types/models';

const { width } = Dimensions.get('window');
const CARD_WIDTH = (width - 20 * 2 - 16) / 2;

interface ParkOption {
  type: ParkType;
  name: string;
  fullName: string;
  icon: string;
  color: string[];
  description: string;
}

const getParkOptions = (language: string): ParkOption[] => [
  {
    type: ParkType.LAND,
    name: language === 'ja' ? 'ディズニーランド' : 'Disneyland',
    fullName: language === 'ja' ? '東京ディズニーランド' : 'Tokyo Disneyland',
    icon: 'fort-awesome',
    color: ['#ff6b6b', '#ee5a52', '#ff8787'],
    description: language === 'ja' ? '夢と魔法の王国' : 'The magical kingdom where dreams come true',
  },
  {
    type: ParkType.SEA,
    name: language === 'ja' ? 'ディズニーシー' : 'DisneySea',
    fullName: language === 'ja' ? '東京ディズニーシー' : 'Tokyo DisneySea',
    icon: 'globe',
    color: ['#4ecdc4', '#45b7b8', '#6c5ce7'],
    description: language === 'ja' ? '冒険とイマジネーションの海' : 'Discover the wonders of adventure and imagination',
  },
];

interface ParkSelectorProps {
  selectedPark?: ParkType;
  onParkSelect: (park: ParkType) => void;
}

export const ParkSelector: React.FC<ParkSelectorProps> = ({
  selectedPark,
  onParkSelect,
}) => {
  const { theme } = useTheme();
  const { language } = useLanguage();
  const isDark = theme.mode === 'dark';
  
  const parkOptions = getParkOptions(language);
  
  // Animation refs for each card
  const landScaleAnim = useRef(new Animated.Value(1)).current;
  const seaScaleAnim = useRef(new Animated.Value(1)).current;
  const landGlowAnim = useRef(new Animated.Value(0)).current;
  const seaGlowAnim = useRef(new Animated.Value(0)).current;
  const selectionAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    // Animate selection state
    Animated.spring(selectionAnim, {
      toValue: selectedPark ? 1 : 0,
      useNativeDriver: false,
      tension: 100,
      friction: 8,
    }).start();

    // Animate glow based on selection
    if (selectedPark === ParkType.LAND) {
      Animated.parallel([
        Animated.timing(landGlowAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: false,
        }),
        Animated.timing(seaGlowAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: false,
        }),
      ]).start();
    } else if (selectedPark === ParkType.SEA) {
      Animated.parallel([
        Animated.timing(seaGlowAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: false,
        }),
        Animated.timing(landGlowAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: false,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(landGlowAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: false,
        }),
        Animated.timing(seaGlowAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: false,
        }),
      ]).start();
    }
  }, [selectedPark]);

  const handleParkSelect = (parkType: ParkType) => {
    // Haptic feedback would go here
    onParkSelect(parkType);
    
    // Create ripple effect
    const scaleAnim = parkType === ParkType.LAND ? landScaleAnim : seaScaleAnim;
    
    Animated.sequence([
      Animated.timing(scaleAnim, {
        toValue: 0.95,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        useNativeDriver: true,
        tension: 300,
        friction: 10,
      }),
    ]).start();
  };

  const renderParkCard = (park: ParkOption) => {
    const isSelected = selectedPark === park.type;
    const scaleAnim = park.type === ParkType.LAND ? landScaleAnim : seaScaleAnim;
    const glowAnim = park.type === ParkType.LAND ? landGlowAnim : seaGlowAnim;

    return (
      <Animated.View
        key={park.type}
        style={[
          styles.cardContainer,
          {
            transform: [{ scale: scaleAnim }],
          },
        ]}
      >
        <TouchableOpacity
          activeOpacity={0.8}
          onPress={() => handleParkSelect(park.type)}
          style={styles.card}
        >
          {/* Glow Effect */}
          <Animated.View
            style={[
              styles.glowEffect,
              {
                opacity: glowAnim,
                shadowColor: park.color[1],
              },
            ]}
          />

          {/* Card Background */}
          <View
            style={[
              styles.cardBackground,
              {
                backgroundColor: isDark
                  ? isSelected
                    ? colors.background.secondary
                    : colors.background.tertiary
                  : isSelected
                  ? colors.utility.white
                  : colors.background.card,
                borderWidth: isSelected ? 2 : 1,
                borderColor: isSelected ? park.color[1] : colors.utility.borderLight,
              },
            ]}
          >
            <LinearGradient
              colors={
                isSelected
                  ? [...park.color, 'rgba(255, 255, 255, 0.1)']
                  : ['transparent', 'transparent', 'transparent']
              }
              style={styles.cardGradient}
            >
              {/* Header */}
              <View style={styles.cardHeader}>
                <View
                  style={[
                    styles.iconContainer,
                    {
                      backgroundColor: isSelected
                        ? 'rgba(255, 255, 255, 0.2)'
                        : `${park.color[1]}20`,
                    },
                  ]}
                >
                  <FontAwesome5
                    name={park.icon as any}
                    size={28}
                    color={isSelected ? colors.utility.white : park.color[1]}
                  />
                </View>
                
                {/* Checkbox - always visible */}
                <View style={styles.checkboxContainer}>
                  <Animated.View
                    style={[
                      styles.checkbox,
                      {
                        backgroundColor: isSelected 
                          ? park.color[1] 
                          : 'transparent',
                        borderColor: isSelected 
                          ? park.color[1] 
                          : theme.colors.text.tertiary,
                        transform: [
                          {
                            scale: selectionAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [1, 1.1],
                            }),
                          },
                        ],
                      },
                    ]}
                  >
                    {isSelected && (
                      <Animated.View
                        style={[
                          styles.checkmark,
                          {
                            opacity: selectionAnim,
                            transform: [
                              {
                                scale: selectionAnim.interpolate({
                                  inputRange: [0, 1],
                                  outputRange: [0.5, 1],
                                }),
                              },
                            ],
                          },
                        ]}
                      >
                        <Ionicons
                          name="checkmark"
                          size={16}
                          color={colors.utility.white}
                        />
                      </Animated.View>
                    )}
                  </Animated.View>
                </View>
              </View>

              {/* Content */}
              <View style={styles.cardContent}>
                <Text
                  style={[
                    styles.parkName,
                    {
                      color: isSelected
                        ? colors.text.dark.primary
                        : theme.colors.text.primary,
                    },
                  ]}
                >
                  {park.name}
                </Text>
                
                <Text
                  style={[
                    styles.parkDescription,
                    {
                      color: isSelected
                        ? colors.text.dark.secondary
                        : theme.colors.text.secondary,
                    },
                  ]}
                >
                  {park.description}
                </Text>

              </View>

              {/* Floating Elements */}
              {isSelected && (
                <Animated.View
                  style={[
                    styles.floatingElements,
                    {
                      opacity: selectionAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0, 0.6],
                      }),
                    },
                  ]}
                >
                  {[...Array(3)].map((_, index) => (
                    <Animated.View
                      key={index}
                      style={[
                        styles.floatingDot,
                        {
                          backgroundColor: colors.text.dark.primary,
                          transform: [
                            {
                              translateY: selectionAnim.interpolate({
                                inputRange: [0, 1],
                                outputRange: [0, -10 - index * 5],
                              }),
                            },
                          ],
                        },
                      ]}
                    />
                  ))}
                </Animated.View>
              )}
            </LinearGradient>
          </View>
        </TouchableOpacity>
      </Animated.View>
    );
  };

  return (
    <View style={styles.container}>
      <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
        {language === 'ja' ? 'パークを選択' : 'Select a Park'}
      </Text>
      <Text style={[styles.sectionSubtitle, { color: theme.colors.text.secondary }]}>
        {language === 'ja' ? '魔法の一日をどちらで始めますか？' : 'Where will you start your magical day?'}
      </Text>
      
      <View style={styles.cardsContainer}>
        {parkOptions.map(renderParkCard)}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 8,
    textAlign: 'center',
  },
  sectionSubtitle: {
    fontSize: 16,
    marginBottom: 20,
    textAlign: 'center',
  },
  cardsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 16,
  },
  cardContainer: {
    flex: 1,
    height: 240,
  },
  card: {
    flex: 1,
    borderRadius: 16,
    overflow: 'hidden',
  },
  glowEffect: {
    position: 'absolute',
    top: -10,
    left: -10,
    right: -10,
    bottom: -10,
    borderRadius: 24,
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 20,
    elevation: 20,
  },
  cardBackground: {
    flex: 1,
    borderRadius: 16,
    overflow: 'hidden',
    shadowColor: colors.effects.shadowMedium,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  cardGradient: {
    flex: 1,
    padding: 16,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkboxContainer: {
    padding: 4,
  },
  checkbox: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkmark: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  cardContent: {
    flex: 1,
    justifyContent: 'space-between',
  },
  parkName: {
    fontSize: 20,
    fontWeight: '700',
    marginBottom: 8,
  },
  parkDescription: {
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 12,
  },
  floatingElements: {
    position: 'absolute',
    top: 12,
    right: 12,
    gap: 4,
  },
  floatingDot: {
    width: 4,
    height: 4,
    borderRadius: 2,
    opacity: 0.6,
  },
});
</file>

<file path="src/components/PhotoEditor.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Image,
  Dimensions,
  Modal,
  ActivityIndicator,
  Alert,
  Animated,
  PanResponder,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
// import Slider from '@react-native-community/slider'; // Removed dependency
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { photoService, PhotoMetadata, PHOTO_FILTERS } from '../services/photoService';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface PhotoEditorProps {
  photo: PhotoMetadata;
  visible: boolean;
  onClose: () => void;
  onSave: (editedPhoto: PhotoMetadata) => void;
}

type EditMode = 'none' | 'crop' | 'filter' | 'adjust' | 'rotate';

interface EditState {
  brightness: number;
  contrast: number;
  saturation: number;
  rotation: number;
  currentFilter: string;
  cropData?: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
}

export const PhotoEditor: React.FC<PhotoEditorProps> = ({
  photo,
  visible,
  onClose,
  onSave,
}) => {
  const { theme } = useTheme();
  const [editMode, setEditMode] = useState<EditMode>('none');
  const [isProcessing, setIsProcessing] = useState(false);
  const [previewUri, setPreviewUri] = useState(photo.uri);
  const [hasChanges, setHasChanges] = useState(false);
  
  // Edit state
  const [editState, setEditState] = useState<EditState>({
    brightness: 0,
    contrast: 0,
    saturation: 0,
    rotation: 0,
    currentFilter: 'original',
  });
  
  // Animation values
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(screenHeight)).current;
  
  // Crop state
  const [cropMode, setCropMode] = useState(false);
  const cropViewRef = useRef<View>(null);
  const cropX = useRef(new Animated.Value(50)).current;
  const cropY = useRef(new Animated.Value(50)).current;
  const cropWidth = useRef(new Animated.Value(screenWidth - 100)).current;
  const cropHeight = useRef(new Animated.Value(screenWidth - 100)).current;

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(slideAnim, {
          toValue: 0,
          tension: 100,
          friction: 10,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible]);

  const handleClose = () => {
    if (hasChanges) {
      Alert.alert(
        'Discard Changes?',
        'You have unsaved changes. Are you sure you want to close?',
        [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'Discard',
            style: 'destructive',
            onPress: () => {
              resetEdits();
              animateClose();
            },
          },
        ]
      );
    } else {
      animateClose();
    }
  };

  const animateClose = () => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: screenHeight,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start(() => {
      onClose();
    });
  };

  const resetEdits = () => {
    setEditState({
      brightness: 0,
      contrast: 0,
      saturation: 0,
      rotation: 0,
      currentFilter: 'original',
    });
    setPreviewUri(photo.uri);
    setHasChanges(false);
    setEditMode('none');
  };

  const applyFilter = async (filterId: string) => {
    setIsProcessing(true);
    try {
      const filter = PHOTO_FILTERS.find(f => f.id === filterId);
      if (filter) {
        const filtered = await photoService.applyFilter(photo.uri, filter);
        setPreviewUri(filtered);
        setEditState({ ...editState, currentFilter: filterId });
        setHasChanges(true);
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to apply filter');
    } finally {
      setIsProcessing(false);
    }
  };

  const adjustBrightness = async (value: number) => {
    setEditState({ ...editState, brightness: value });
    setHasChanges(true);
    // Note: Actual brightness adjustment would be applied on save
  };

  const adjustContrast = async (value: number) => {
    setEditState({ ...editState, contrast: value });
    setHasChanges(true);
    // Note: Actual contrast adjustment would be applied on save
  };

  const adjustSaturation = async (value: number) => {
    setEditState({ ...editState, saturation: value });
    setHasChanges(true);
    // Note: Actual saturation adjustment would be applied on save
  };

  const rotatePhoto = async (degrees: number) => {
    setIsProcessing(true);
    try {
      const newRotation = (editState.rotation + degrees) % 360;
      const rotated = await photoService.rotatePhoto(previewUri, degrees);
      setPreviewUri(rotated);
      setEditState({ ...editState, rotation: newRotation });
      setHasChanges(true);
    } catch (error) {
      Alert.alert('Error', 'Failed to rotate photo');
    } finally {
      setIsProcessing(false);
    }
  };

  const applyCrop = async () => {
    if (!editState.cropData) return;
    
    setIsProcessing(true);
    try {
      const cropped = await photoService.cropPhoto(previewUri, {
        originX: editState.cropData.x,
        originY: editState.cropData.y,
        width: editState.cropData.width,
        height: editState.cropData.height,
      });
      setPreviewUri(cropped);
      setCropMode(false);
      setHasChanges(true);
    } catch (error) {
      Alert.alert('Error', 'Failed to crop photo');
    } finally {
      setIsProcessing(false);
    }
  };

  const saveEdits = async () => {
    setIsProcessing(true);
    try {
      // Create edited photo metadata
      const editedPhoto: PhotoMetadata = {
        ...photo,
        uri: previewUri,
        editHistory: [
          ...(photo.editHistory || []),
          {
            id: photoService.generatePhotoId(),
            type: 'filter',
            params: editState,
            timestamp: new Date(),
          },
        ],
      };
      
      onSave(editedPhoto);
      animateClose();
    } catch (error) {
      Alert.alert('Error', 'Failed to save edits');
    } finally {
      setIsProcessing(false);
    }
  };

  const renderToolbar = () => (
    <View style={[styles.toolbar, { backgroundColor: theme.colors.background.elevated }]}>
      <TouchableOpacity
        style={[styles.toolButton, editMode === 'crop' && styles.toolButtonActive]}
        onPress={() => setEditMode(editMode === 'crop' ? 'none' : 'crop')}
      >
        <MaterialCommunityIcons name="crop" size={24} color={theme.colors.text.primary} />
        <Text style={[styles.toolButtonText, { color: theme.colors.text.secondary }]}>
          Crop
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.toolButton, editMode === 'filter' && styles.toolButtonActive]}
        onPress={() => setEditMode(editMode === 'filter' ? 'none' : 'filter')}
      >
        <Ionicons name="color-filter" size={24} color={theme.colors.text.primary} />
        <Text style={[styles.toolButtonText, { color: theme.colors.text.secondary }]}>
          Filter
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.toolButton, editMode === 'adjust' && styles.toolButtonActive]}
        onPress={() => setEditMode(editMode === 'adjust' ? 'none' : 'adjust')}
      >
        <Ionicons name="options" size={24} color={theme.colors.text.primary} />
        <Text style={[styles.toolButtonText, { color: theme.colors.text.secondary }]}>
          Adjust
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.toolButton, editMode === 'rotate' && styles.toolButtonActive]}
        onPress={() => setEditMode(editMode === 'rotate' ? 'none' : 'rotate')}
      >
        <MaterialCommunityIcons name="rotate-right" size={24} color={theme.colors.text.primary} />
        <Text style={[styles.toolButtonText, { color: theme.colors.text.secondary }]}>
          Rotate
        </Text>
      </TouchableOpacity>
    </View>
  );

  const renderFilterOptions = () => (
    <ScrollView
      horizontal
      showsHorizontalScrollIndicator={false}
      contentContainerStyle={styles.filterContainer}
    >
      {PHOTO_FILTERS.map(filter => (
        <TouchableOpacity
          key={filter.id}
          style={[
            styles.filterOption,
            editState.currentFilter === filter.id && styles.filterOptionActive,
          ]}
          onPress={() => applyFilter(filter.id)}
        >
          <View style={styles.filterPreview}>
            <Image source={{ uri: photo.uri }} style={styles.filterPreviewImage} />
            <LinearGradient
              colors={[colors.purple[400] + '40', colors.purple[600] + '40']}
              style={StyleSheet.absoluteFill}
            />
          </View>
          <Text
            style={[
              styles.filterName,
              { color: theme.colors.text.primary },
              editState.currentFilter === filter.id && { color: colors.purple[500] },
            ]}
          >
            {filter.name}
          </Text>
        </TouchableOpacity>
      ))}
    </ScrollView>
  );

  const renderAdjustmentOptions = () => (
    <View style={styles.adjustmentContainer}>
      <View style={styles.adjustmentRow}>
        <Ionicons name="sunny" size={20} color={theme.colors.text.secondary} />
        <Text style={[styles.adjustmentLabel, { color: theme.colors.text.primary }]}>
          Brightness
        </Text>
        <View style={styles.sliderReplacement}>
          <TouchableOpacity 
            style={styles.sliderButton} 
            onPress={() => adjustBrightness(Math.max(-1, editState.brightness - 0.1))}
          >
            <Ionicons name="remove" size={16} color={theme.colors.text.primary} />
          </TouchableOpacity>
          <View style={styles.sliderTrack}>
            <View 
              style={[
                styles.sliderProgress, 
                { 
                  width: `${((editState.brightness + 1) / 2) * 100}%`,
                  backgroundColor: colors.purple[500]
                }
              ]} 
            />
          </View>
          <TouchableOpacity 
            style={styles.sliderButton} 
            onPress={() => adjustBrightness(Math.min(1, editState.brightness + 0.1))}
          >
            <Ionicons name="add" size={16} color={theme.colors.text.primary} />
          </TouchableOpacity>
        </View>
        <Text style={[styles.adjustmentValue, { color: theme.colors.text.secondary }]}>
          {Math.round(editState.brightness * 100)}
        </Text>
      </View>
      
      <View style={styles.adjustmentRow}>
        <Ionicons name="contrast" size={20} color={theme.colors.text.secondary} />
        <Text style={[styles.adjustmentLabel, { color: theme.colors.text.primary }]}>
          Contrast
        </Text>
        <View style={styles.sliderReplacement}>
          <TouchableOpacity 
            style={styles.sliderButton} 
            onPress={() => adjustContrast(Math.max(-1, editState.contrast - 0.1))}
          >
            <Ionicons name="remove" size={16} color={theme.colors.text.primary} />
          </TouchableOpacity>
          <View style={styles.sliderTrack}>
            <View 
              style={[
                styles.sliderProgress, 
                { 
                  width: `${((editState.contrast + 1) / 2) * 100}%`,
                  backgroundColor: colors.purple[500]
                }
              ]} 
            />
          </View>
          <TouchableOpacity 
            style={styles.sliderButton} 
            onPress={() => adjustContrast(Math.min(1, editState.contrast + 0.1))}
          >
            <Ionicons name="add" size={16} color={theme.colors.text.primary} />
          </TouchableOpacity>
        </View>
        <Text style={[styles.adjustmentValue, { color: theme.colors.text.secondary }]}>
          {Math.round(editState.contrast * 100)}
        </Text>
      </View>
      
      <View style={styles.adjustmentRow}>
        <Ionicons name="color-palette" size={20} color={theme.colors.text.secondary} />
        <Text style={[styles.adjustmentLabel, { color: theme.colors.text.primary }]}>
          Saturation
        </Text>
        <View style={styles.sliderReplacement}>
          <TouchableOpacity 
            style={styles.sliderButton} 
            onPress={() => adjustSaturation(Math.max(-1, editState.saturation - 0.1))}
          >
            <Ionicons name="remove" size={16} color={theme.colors.text.primary} />
          </TouchableOpacity>
          <View style={styles.sliderTrack}>
            <View 
              style={[
                styles.sliderProgress, 
                { 
                  width: `${((editState.saturation + 1) / 2) * 100}%`,
                  backgroundColor: colors.purple[500]
                }
              ]} 
            />
          </View>
          <TouchableOpacity 
            style={styles.sliderButton} 
            onPress={() => adjustSaturation(Math.min(1, editState.saturation + 0.1))}
          >
            <Ionicons name="add" size={16} color={theme.colors.text.primary} />
          </TouchableOpacity>
        </View>
        <Text style={[styles.adjustmentValue, { color: theme.colors.text.secondary }]}>
          {Math.round(editState.saturation * 100)}
        </Text>
      </View>
    </View>
  );

  const renderRotateOptions = () => (
    <View style={styles.rotateContainer}>
      <TouchableOpacity
        style={styles.rotateButton}
        onPress={() => rotatePhoto(90)}
      >
        <MaterialCommunityIcons name="rotate-right" size={32} color={theme.colors.text.primary} />
        <Text style={[styles.rotateButtonText, { color: theme.colors.text.secondary }]}>
          Rotate Right
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={styles.rotateButton}
        onPress={() => rotatePhoto(-90)}
      >
        <MaterialCommunityIcons name="rotate-left" size={32} color={theme.colors.text.primary} />
        <Text style={[styles.rotateButtonText, { color: theme.colors.text.secondary }]}>
          Rotate Left
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={styles.rotateButton}
        onPress={() => rotatePhoto(180)}
      >
        <MaterialCommunityIcons name="flip-vertical" size={32} color={theme.colors.text.primary} />
        <Text style={[styles.rotateButtonText, { color: theme.colors.text.secondary }]}>
          Flip
        </Text>
      </TouchableOpacity>
    </View>
  );

  const renderEditOptions = () => {
    switch (editMode) {
      case 'filter':
        return renderFilterOptions();
      case 'adjust':
        return renderAdjustmentOptions();
      case 'rotate':
        return renderRotateOptions();
      default:
        return null;
    }
  };

  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      onRequestClose={handleClose}
    >
      <Animated.View
        style={[
          styles.container,
          {
            opacity: fadeAnim,
            backgroundColor: theme.colors.background.primary,
          },
        ]}
      >
        <Animated.View
          style={[
            styles.content,
            {
              transform: [{ translateY: slideAnim }],
            },
          ]}
        >
          {/* Header */}
          <View style={[styles.header, { backgroundColor: theme.colors.background.elevated }]}>
            <TouchableOpacity style={styles.headerButton} onPress={handleClose}>
              <Ionicons name="close" size={28} color={theme.colors.text.primary} />
            </TouchableOpacity>
            
            <Text style={[styles.headerTitle, { color: theme.colors.text.primary }]}>
              Edit Photo
            </Text>
            
            <TouchableOpacity
              style={[styles.headerButton, styles.saveButton]}
              onPress={saveEdits}
              disabled={!hasChanges || isProcessing}
            >
              <LinearGradient
                colors={hasChanges ? [colors.purple[400], colors.purple[600]] : ['#999', '#666']}
                style={styles.saveButtonGradient}
              >
                <Text style={styles.saveButtonText}>Save</Text>
              </LinearGradient>
            </TouchableOpacity>
          </View>
          
          {/* Photo Preview */}
          <View style={styles.photoContainer}>
            <Image
              source={{ uri: previewUri }}
              style={styles.photo}
              resizeMode="contain"
            />
            
            {cropMode && (
              <View style={StyleSheet.absoluteFill}>
                <Animated.View
                  ref={cropViewRef}
                  style={[
                    styles.cropOverlay,
                    {
                      left: cropX,
                      top: cropY,
                      width: cropWidth,
                      height: cropHeight,
                    },
                  ]}
                />
              </View>
            )}
            
            {isProcessing && (
              <View style={styles.processingOverlay}>
                <ActivityIndicator size="large" color={colors.purple[400]} />
                <Text style={styles.processingText}>Processing...</Text>
              </View>
            )}
          </View>
          
          {/* Toolbar */}
          {renderToolbar()}
          
          {/* Edit Options */}
          <View style={[styles.optionsContainer, { backgroundColor: theme.colors.background.secondary }]}>
            {renderEditOptions()}
          </View>
        </Animated.View>
      </Animated.View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.1)',
  },
  headerButton: {
    padding: spacing[2],
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  saveButton: {
    padding: 0,
  },
  saveButtonGradient: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.lg,
  },
  saveButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  photoContainer: {
    flex: 1,
    backgroundColor: 'black',
    justifyContent: 'center',
    alignItems: 'center',
  },
  photo: {
    width: screenWidth,
    height: '100%',
  },
  cropOverlay: {
    position: 'absolute',
    borderWidth: 2,
    borderColor: colors.purple[400],
    borderStyle: 'dashed',
  },
  processingOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  processingText: {
    color: 'white',
    marginTop: spacing[2],
    fontSize: 16,
  },
  toolbar: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingVertical: spacing[3],
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: 'rgba(0, 0, 0, 0.1)',
  },
  toolButton: {
    alignItems: 'center',
    padding: spacing[2],
  },
  toolButtonActive: {
    backgroundColor: colors.purple[100],
    borderRadius: borderRadius.lg,
  },
  toolButtonText: {
    fontSize: 12,
    marginTop: spacing[1],
  },
  optionsContainer: {
    minHeight: 120,
    maxHeight: 200,
  },
  filterContainer: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
  },
  filterOption: {
    alignItems: 'center',
    marginRight: spacing[3],
  },
  filterOptionActive: {
    transform: [{ scale: 1.1 }],
  },
  filterPreview: {
    width: 60,
    height: 60,
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
    marginBottom: spacing[1],
  },
  filterPreviewImage: {
    width: '100%',
    height: '100%',
  },
  filterName: {
    fontSize: 12,
  },
  adjustmentContainer: {
    padding: spacing[4],
  },
  adjustmentRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: spacing[3],
  },
  adjustmentLabel: {
    fontSize: 14,
    fontWeight: '500',
    marginLeft: spacing[2],
    width: 80,
  },
  sliderReplacement: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginHorizontal: spacing[2],
  },
  sliderButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(168, 85, 247, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  sliderTrack: {
    flex: 1,
    height: 6,
    backgroundColor: 'rgba(0, 0, 0, 0.1)',
    borderRadius: 3,
    marginHorizontal: spacing[2],
    overflow: 'hidden',
  },
  sliderProgress: {
    height: '100%',
    borderRadius: 3,
  },
  adjustmentValue: {
    fontSize: 12,
    width: 40,
    textAlign: 'right',
  },
  rotateContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: spacing[4],
  },
  rotateButton: {
    alignItems: 'center',
    padding: spacing[3],
  },
  rotateButtonText: {
    fontSize: 12,
    marginTop: spacing[1],
  },
});
</file>

<file path="src/components/PhotoGallery.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Dimensions,
  TouchableOpacity,
  StatusBar,
  Platform,
  SafeAreaView,
  ActivityIndicator,
  Share,
  Alert,
  Modal,
  PanResponder,
  Animated,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { PinchGestureHandler, State, GestureHandlerRootView } from 'react-native-gesture-handler';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { PhotoMetadata } from '../services/photoService';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface PhotoGalleryProps {
  photos: PhotoMetadata[];
  initialIndex?: number;
  visible: boolean;
  onClose: () => void;
  onPhotoChange?: (index: number) => void;
  onShare?: (photo: PhotoMetadata) => void;
  onDownload?: (photo: PhotoMetadata) => void;
  onDelete?: (photo: PhotoMetadata) => void;
  onEdit?: (photo: PhotoMetadata) => void;
  showMetadata?: boolean;
}

export const PhotoGallery: React.FC<PhotoGalleryProps> = ({
  photos,
  initialIndex = 0,
  visible,
  onClose,
  onPhotoChange,
  onShare,
  onDownload,
  onDelete,
  onEdit,
  showMetadata = true,
}) => {
  const { theme } = useTheme();
  const [currentIndex, setCurrentIndex] = useState(initialIndex);
  const [showControls, setShowControls] = useState(true);
  const [showInfo, setShowInfo] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  // Animation values
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const translateX = useRef(new Animated.Value(0)).current;
  const scale = useRef(new Animated.Value(1)).current;
  const controlsOpacity = useRef(new Animated.Value(1)).current;
  
  // Pinch zoom state
  const baseScale = useRef(new Animated.Value(1)).current;
  const pinchScale = useRef(new Animated.Value(1)).current;
  const lastScale = useRef(1);
  
  // Pan state
  const translateXOffset = useRef(0);
  const translateYOffset = useRef(0);
  const panX = useRef(new Animated.Value(0)).current;
  const panY = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (visible) {
      StatusBar.setHidden(true, 'fade');
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(scale, {
          toValue: 1,
          tension: 100,
          friction: 10,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      StatusBar.setHidden(false, 'fade');
    }
  }, [visible]);

  useEffect(() => {
    if (onPhotoChange) {
      onPhotoChange(currentIndex);
    }
  }, [currentIndex]);

  // Auto-hide controls after 3 seconds
  useEffect(() => {
    const timer = setTimeout(() => {
      if (showControls) {
        hideControls();
      }
    }, 3000);

    return () => clearTimeout(timer);
  }, [showControls, currentIndex]);

  const hideControls = () => {
    Animated.timing(controlsOpacity, {
      toValue: 0,
      duration: 300,
      useNativeDriver: true,
    }).start(() => setShowControls(false));
  };

  const toggleControls = () => {
    if (showControls) {
      hideControls();
    } else {
      setShowControls(true);
      Animated.timing(controlsOpacity, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
    }
  };

  const goToPrevious = () => {
    if (currentIndex > 0) {
      animateTransition('left', () => {
        setCurrentIndex(currentIndex - 1);
        resetZoomAndPan();
      });
    }
  };

  const goToNext = () => {
    if (currentIndex < photos.length - 1) {
      animateTransition('right', () => {
        setCurrentIndex(currentIndex + 1);
        resetZoomAndPan();
      });
    }
  };

  const animateTransition = (direction: 'left' | 'right', callback: () => void) => {
    const toValue = direction === 'left' ? screenWidth : -screenWidth;
    
    Animated.timing(translateX, {
      toValue,
      duration: 250,
      useNativeDriver: true,
    }).start(() => {
      callback();
      translateX.setValue(-toValue);
      Animated.timing(translateX, {
        toValue: 0,
        duration: 250,
        useNativeDriver: true,
      }).start();
    });
  };

  const resetZoomAndPan = () => {
    Animated.parallel([
      Animated.spring(baseScale, {
        toValue: 1,
        useNativeDriver: true,
      }),
      Animated.spring(panX, {
        toValue: 0,
        useNativeDriver: true,
      }),
      Animated.spring(panY, {
        toValue: 0,
        useNativeDriver: true,
      }),
    ]).start();
    
    lastScale.current = 1;
    translateXOffset.current = 0;
    translateYOffset.current = 0;
  };

  const handlePinchGestureEvent = Animated.event(
    [{ nativeEvent: { scale: pinchScale } }],
    { useNativeDriver: true }
  );

  const handlePinchStateChange = (event: any) => {
    if (event.nativeEvent.state === State.END) {
      lastScale.current *= event.nativeEvent.scale;
      lastScale.current = Math.max(1, Math.min(lastScale.current, 4));
      
      Animated.spring(baseScale, {
        toValue: lastScale.current,
        useNativeDriver: true,
      }).start();
      
      pinchScale.setValue(1);
      
      if (lastScale.current === 1) {
        resetZoomAndPan();
      }
    }
  };

  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: (_, gestureState) => {
        // Allow pan if zoomed in or if it's a horizontal swipe when not zoomed
        return lastScale.current > 1 || Math.abs(gestureState.dx) > Math.abs(gestureState.dy);
      },
      onPanResponderGrant: () => {
        panX.setOffset(translateXOffset.current);
        panY.setOffset(translateYOffset.current);
      },
      onPanResponderMove: (_, gestureState) => {
        if (lastScale.current > 1) {
          // Allow panning when zoomed
          panX.setValue(gestureState.dx);
          panY.setValue(gestureState.dy);
        } else {
          // Swipe to change photos when not zoomed
          if (Math.abs(gestureState.dx) > 50) {
            if (gestureState.dx > 0 && currentIndex > 0) {
              goToPrevious();
            } else if (gestureState.dx < 0 && currentIndex < photos.length - 1) {
              goToNext();
            }
          }
        }
      },
      onPanResponderRelease: (_, gestureState) => {
        if (lastScale.current > 1) {
          panX.flattenOffset();
          panY.flattenOffset();
          translateXOffset.current += gestureState.dx;
          translateYOffset.current += gestureState.dy;
        }
      },
    })
  ).current;

  const handleShare = async () => {
    const photo = photos[currentIndex];
    if (onShare) {
      onShare(photo);
    } else {
      try {
        await Share.share({
          message: photo.caption || 'Check out this photo!',
          url: photo.uri,
        });
      } catch (error) {
        console.error('Share failed:', error);
      }
    }
  };

  const handleDelete = () => {
    const photo = photos[currentIndex];
    Alert.alert(
      'Delete Photo',
      'Are you sure you want to delete this photo?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: () => {
            if (onDelete) {
              onDelete(photo);
              if (currentIndex >= photos.length - 1 && currentIndex > 0) {
                setCurrentIndex(currentIndex - 1);
              }
            }
          },
        },
      ]
    );
  };

  const handleDownload = () => {
    const photo = photos[currentIndex];
    if (onDownload) {
      onDownload(photo);
    }
  };

  const handleEdit = () => {
    const photo = photos[currentIndex];
    if (onEdit) {
      onEdit(photo);
    }
  };

  const currentPhoto = photos[currentIndex];

  const renderHeader = () => (
    <Animated.View
      style={[
        styles.header,
        {
          opacity: controlsOpacity,
          transform: [{ translateY: showControls ? 0 : -100 }],
        },
      ]}
    >
      <LinearGradient
        colors={['rgba(0, 0, 0, 0.8)', 'transparent']}
        style={styles.headerGradient}
      >
        <SafeAreaView style={styles.headerContent}>
          <TouchableOpacity style={styles.closeButton} onPress={onClose}>
            <Ionicons name="close" size={28} color="white" />
          </TouchableOpacity>
          
          <Text style={styles.headerTitle}>
            {currentIndex + 1} / {photos.length}
          </Text>
          
          <View style={styles.headerActions}>
            {showMetadata && (
              <TouchableOpacity
                style={styles.actionButton}
                onPress={() => setShowInfo(!showInfo)}
              >
                <Ionicons name="information-circle-outline" size={24} color="white" />
              </TouchableOpacity>
            )}
          </View>
        </SafeAreaView>
      </LinearGradient>
    </Animated.View>
  );

  const renderFooter = () => (
    <Animated.View
      style={[
        styles.footer,
        {
          opacity: controlsOpacity,
          transform: [{ translateY: showControls ? 0 : 100 }],
        },
      ]}
    >
      <LinearGradient
        colors={['transparent', 'rgba(0, 0, 0, 0.8)']}
        style={styles.footerGradient}
      >
        <SafeAreaView style={styles.footerContent}>
          {currentPhoto.caption && (
            <Text style={styles.caption} numberOfLines={2}>
              {currentPhoto.caption}
            </Text>
          )}
          
          <View style={styles.footerActions}>
            <TouchableOpacity style={styles.footerButton} onPress={handleShare}>
              <Ionicons name="share-outline" size={24} color="white" />
            </TouchableOpacity>
            
            {onEdit && (
              <TouchableOpacity style={styles.footerButton} onPress={handleEdit}>
                <Ionicons name="create-outline" size={24} color="white" />
              </TouchableOpacity>
            )}
            
            {onDownload && (
              <TouchableOpacity style={styles.footerButton} onPress={handleDownload}>
                <Ionicons name="download-outline" size={24} color="white" />
              </TouchableOpacity>
            )}
            
            {onDelete && (
              <TouchableOpacity style={styles.footerButton} onPress={handleDelete}>
                <Ionicons name="trash-outline" size={24} color={colors.semantic.error.light} />
              </TouchableOpacity>
            )}
          </View>
        </SafeAreaView>
      </LinearGradient>
    </Animated.View>
  );

  const renderPhotoInfo = () => (
    <Modal
      visible={showInfo}
      transparent
      animationType="slide"
      onRequestClose={() => setShowInfo(false)}
    >
      <TouchableOpacity
        style={styles.infoBackdrop}
        activeOpacity={1}
        onPress={() => setShowInfo(false)}
      >
        <View style={styles.infoContainer}>
          <BlurView intensity={80} style={styles.infoContent}>
            <View style={styles.infoHeader}>
              <Text style={styles.infoTitle}>Photo Details</Text>
              <TouchableOpacity onPress={() => setShowInfo(false)}>
                <Ionicons name="close" size={24} color={theme.colors.text.primary} />
              </TouchableOpacity>
            </View>
            
            <View style={styles.infoBody}>
              {currentPhoto.takenAt && (
                <View style={styles.infoRow}>
                  <Ionicons name="calendar" size={20} color={theme.colors.text.secondary} />
                  <Text style={styles.infoText}>
                    {currentPhoto.takenAt.toLocaleDateString()}
                  </Text>
                </View>
              )}
              
              {currentPhoto.location && (
                <View style={styles.infoRow}>
                  <Ionicons name="location" size={20} color={theme.colors.text.secondary} />
                  <Text style={styles.infoText}>
                    {currentPhoto.location.latitude.toFixed(4)}, {currentPhoto.location.longitude.toFixed(4)}
                  </Text>
                </View>
              )}
              
              <View style={styles.infoRow}>
                <MaterialCommunityIcons name="image-size-select-actual" size={20} color={theme.colors.text.secondary} />
                <Text style={styles.infoText}>
                  {currentPhoto.width} × {currentPhoto.height}
                </Text>
              </View>
              
              <View style={styles.infoRow}>
                <Ionicons name="document" size={20} color={theme.colors.text.secondary} />
                <Text style={styles.infoText}>
                  {(currentPhoto.size / 1024 / 1024).toFixed(2)} MB
                </Text>
              </View>
              
              {currentPhoto.tags && currentPhoto.tags.length > 0 && (
                <View style={styles.infoRow}>
                  <Ionicons name="pricetags" size={20} color={theme.colors.text.secondary} />
                  <View style={styles.tagContainer}>
                    {currentPhoto.tags.map((tag, index) => (
                      <View key={index} style={styles.tag}>
                        <Text style={styles.tagText}>{tag}</Text>
                      </View>
                    ))}
                  </View>
                </View>
              )}
              
              {currentPhoto.exif && (
                <>
                  <Text style={styles.infoSectionTitle}>Camera Info</Text>
                  
                  {currentPhoto.exif.make && (
                    <View style={styles.infoRow}>
                      <Ionicons name="camera" size={20} color={theme.colors.text.secondary} />
                      <Text style={styles.infoText}>
                        {currentPhoto.exif.make} {currentPhoto.exif.model}
                      </Text>
                    </View>
                  )}
                  
                  {currentPhoto.exif.focalLength && (
                    <View style={styles.infoRow}>
                      <MaterialCommunityIcons name="camera-iris" size={20} color={theme.colors.text.secondary} />
                      <Text style={styles.infoText}>
                        f/{currentPhoto.exif.aperture} · {currentPhoto.exif.exposureTime}s · ISO {currentPhoto.exif.iso}
                      </Text>
                    </View>
                  )}
                </>
              )}
            </View>
          </BlurView>
        </View>
      </TouchableOpacity>
    </Modal>
  );

  const renderPhoto = () => {
    const animatedScale = Animated.multiply(baseScale, pinchScale);
    
    return (
      <GestureHandlerRootView style={styles.photoContainer}>
        <TouchableOpacity
          activeOpacity={1}
          onPress={toggleControls}
          style={StyleSheet.absoluteFill}
        >
          <PinchGestureHandler
            onGestureEvent={handlePinchGestureEvent}
            onHandlerStateChange={handlePinchStateChange}
          >
            <Animated.View
              style={[
                StyleSheet.absoluteFill,
                {
                  transform: [
                    { translateX: Animated.add(translateX, panX) },
                    { translateY: panY },
                    { scale: animatedScale },
                  ],
                },
              ]}
              {...panResponder.panHandlers}
            >
              <Animated.Image
                source={{ uri: currentPhoto.uri }}
                style={styles.photo}
                resizeMode="contain"
                onLoadStart={() => setIsLoading(true)}
                onLoadEnd={() => setIsLoading(false)}
              />
            </Animated.View>
          </PinchGestureHandler>
        </TouchableOpacity>
        
        {isLoading && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={colors.purple[400]} />
          </View>
        )}
      </GestureHandlerRootView>
    );
  };

  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      onRequestClose={onClose}
      statusBarTranslucent
    >
      <Animated.View
        style={[
          styles.container,
          {
            opacity: fadeAnim,
            backgroundColor: 'black',
          },
        ]}
      >
        {renderPhoto()}
        {renderHeader()}
        {renderFooter()}
        {renderPhotoInfo()}
        
        {/* Navigation arrows */}
        {currentIndex > 0 && showControls && (
          <TouchableOpacity
            style={[styles.navButton, styles.navButtonLeft]}
            onPress={goToPrevious}
          >
            <Ionicons name="chevron-back" size={32} color="white" />
          </TouchableOpacity>
        )}
        
        {currentIndex < photos.length - 1 && showControls && (
          <TouchableOpacity
            style={[styles.navButton, styles.navButtonRight]}
            onPress={goToNext}
          >
            <Ionicons name="chevron-forward" size={32} color="white" />
          </TouchableOpacity>
        )}
      </Animated.View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  photoContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  photo: {
    width: screenWidth,
    height: screenHeight,
  },
  loadingContainer: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  header: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    zIndex: 10,
  },
  headerGradient: {
    paddingTop: Platform.OS === 'ios' ? 0 : StatusBar.currentHeight,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
  },
  closeButton: {
    padding: spacing[2],
  },
  headerTitle: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  headerActions: {
    flexDirection: 'row',
  },
  actionButton: {
    padding: spacing[2],
    marginLeft: spacing[2],
  },
  footer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    zIndex: 10,
  },
  footerGradient: {
    paddingBottom: Platform.OS === 'ios' ? 0 : spacing[4],
  },
  footerContent: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
  },
  caption: {
    color: 'white',
    fontSize: 14,
    marginBottom: spacing[3],
    textAlign: 'center',
  },
  footerActions: {
    flexDirection: 'row',
    justifyContent: 'center',
  },
  footerButton: {
    padding: spacing[3],
    marginHorizontal: spacing[2],
  },
  navButton: {
    position: 'absolute',
    top: '50%',
    marginTop: -20,
    padding: spacing[2],
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    borderRadius: 20,
  },
  navButtonLeft: {
    left: spacing[4],
  },
  navButtonRight: {
    right: spacing[4],
  },
  infoBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  infoContainer: {
    maxHeight: '80%',
    borderTopLeftRadius: borderRadius.xl,
    borderTopRightRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  infoContent: {
    padding: spacing[4],
  },
  infoHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[4],
  },
  infoTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: 'white',
  },
  infoBody: {
    paddingBottom: spacing[4],
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: spacing[3],
  },
  infoText: {
    marginLeft: spacing[3],
    fontSize: 14,
    color: 'white',
    flex: 1,
  },
  infoSectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: 'white',
    marginTop: spacing[4],
    marginBottom: spacing[3],
  },
  tagContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginLeft: spacing[3],
    flex: 1,
  },
  tag: {
    backgroundColor: colors.purple[500],
    paddingHorizontal: spacing[2],
    paddingVertical: spacing[1],
    borderRadius: borderRadius.md,
    marginRight: spacing[1],
    marginBottom: spacing[1],
  },
  tagText: {
    color: 'white',
    fontSize: 12,
  },
});
</file>

<file path="src/components/PhotoGridView.tsx">
import React, { useState, useRef, useEffect, useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Image,
  Dimensions,
  RefreshControl,
  ActivityIndicator,
  Animated,
  LayoutAnimation,
  Platform,
  UIManager,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
// import MasonryList from '@react-native-seoul/masonry-list'; // Removed dependency
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { PhotoMetadata, photoService, PhotoOrganizationOptions } from '../services/photoService';
import { PhotoGallery } from './PhotoGallery';
import { PhotoPreview } from './PhotoPreview';

// Enable LayoutAnimation on Android
if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const { width: screenWidth } = Dimensions.get('window');

interface PhotoGridViewProps {
  photos: PhotoMetadata[];
  onPhotoSelect?: (photo: PhotoMetadata) => void;
  onPhotosDelete?: (photos: PhotoMetadata[]) => void;
  onPhotoEdit?: (photo: PhotoMetadata) => void;
  refreshing?: boolean;
  onRefresh?: () => void;
  showOrganizationTools?: boolean;
  selectionMode?: boolean;
  selectedPhotos?: PhotoMetadata[];
  onSelectionChange?: (photos: PhotoMetadata[]) => void;
}

type ViewMode = 'grid' | 'masonry' | 'timeline' | 'albums';
type SortBy = 'date' | 'name' | 'size' | 'favorites';
type GroupBy = 'none' | 'date' | 'location' | 'album' | 'tags';

export const PhotoGridView: React.FC<PhotoGridViewProps> = ({
  photos,
  onPhotoSelect,
  onPhotosDelete,
  onPhotoEdit,
  refreshing = false,
  onRefresh,
  showOrganizationTools = true,
  selectionMode = false,
  selectedPhotos = [],
  onSelectionChange,
}) => {
  const { theme } = useTheme();
  const [viewMode, setViewMode] = useState<ViewMode>('masonry');
  const [sortBy, setSortBy] = useState<SortBy>('date');
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');
  const [groupBy, setGroupBy] = useState<GroupBy>('none');
  const [showFilters, setShowFilters] = useState(false);
  const [selectedPhoto, setSelectedPhoto] = useState<PhotoMetadata | null>(null);
  const [showGallery, setShowGallery] = useState(false);
  const [galleryStartIndex, setGalleryStartIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  
  // Animation values
  const filterHeight = useRef(new Animated.Value(0)).current;
  const selectionBarHeight = useRef(new Animated.Value(0)).current;
  const photoScales = useRef<Map<string, Animated.Value>>(new Map()).current;

  useEffect(() => {
    if (showFilters) {
      Animated.spring(filterHeight, {
        toValue: 200,
        tension: 100,
        friction: 10,
        useNativeDriver: false,
      }).start();
    } else {
      Animated.timing(filterHeight, {
        toValue: 0,
        duration: 200,
        useNativeDriver: false,
      }).start();
    }
  }, [showFilters]);

  useEffect(() => {
    if (selectionMode && selectedPhotos.length > 0) {
      Animated.spring(selectionBarHeight, {
        toValue: 60,
        tension: 100,
        friction: 10,
        useNativeDriver: false,
      }).start();
    } else {
      Animated.timing(selectionBarHeight, {
        toValue: 0,
        duration: 200,
        useNativeDriver: false,
      }).start();
    }
  }, [selectionMode, selectedPhotos.length]);

  // Organize photos based on settings
  const organizedPhotos = useMemo(() => {
    let result = [...photos];
    
    // Sort photos
    result.sort((a, b) => {
      let compareValue = 0;
      
      switch (sortBy) {
        case 'date':
          compareValue = a.takenAt.getTime() - b.takenAt.getTime();
          break;
        case 'name':
          compareValue = a.id.localeCompare(b.id);
          break;
        case 'size':
          compareValue = a.size - b.size;
          break;
        case 'favorites':
          compareValue = (a.isFavorite ? 1 : 0) - (b.isFavorite ? 1 : 0);
          break;
      }
      
      return sortOrder === 'asc' ? compareValue : -compareValue;
    });
    
    return result;
  }, [photos, sortBy, sortOrder]);

  // Group photos
  const groupedPhotos = useMemo(() => {
    if (groupBy === 'none') {
      return new Map([['All Photos', organizedPhotos]]);
    }
    
    const options: PhotoOrganizationOptions = {
      groupBy: groupBy as any,
      sortBy: sortBy as any,
      sortOrder,
    };
    
    return photoService.organizePhotos(organizedPhotos, options);
  }, [organizedPhotos, groupBy, sortBy, sortOrder]);

  const getPhotoScale = (photoId: string): Animated.Value => {
    if (!photoScales.has(photoId)) {
      photoScales.set(photoId, new Animated.Value(1));
    }
    return photoScales.get(photoId)!;
  };

  const animatePhotoPress = (photoId: string, callback: () => void) => {
    const scale = getPhotoScale(photoId);
    
    Animated.sequence([
      Animated.timing(scale, {
        toValue: 0.95,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.timing(scale, {
        toValue: 1,
        duration: 100,
        useNativeDriver: true,
      }),
    ]).start(callback);
  };

  const handlePhotoPress = (photo: PhotoMetadata, index: number) => {
    animatePhotoPress(photo.id, () => {
      if (selectionMode) {
        togglePhotoSelection(photo);
      } else {
        setGalleryStartIndex(index);
        setShowGallery(true);
      }
    });
  };

  const handlePhotoLongPress = (photo: PhotoMetadata) => {
    if (!selectionMode && onSelectionChange) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      onSelectionChange([photo]);
    }
  };

  const togglePhotoSelection = (photo: PhotoMetadata) => {
    if (!onSelectionChange) return;
    
    const isSelected = selectedPhotos.some(p => p.id === photo.id);
    let newSelection: PhotoMetadata[];
    
    if (isSelected) {
      newSelection = selectedPhotos.filter(p => p.id !== photo.id);
    } else {
      newSelection = [...selectedPhotos, photo];
    }
    
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    onSelectionChange(newSelection);
  };

  const selectAll = () => {
    if (onSelectionChange) {
      onSelectionChange(organizedPhotos);
    }
  };

  const clearSelection = () => {
    if (onSelectionChange) {
      onSelectionChange([]);
    }
  };

  const deleteSelectedPhotos = () => {
    if (onPhotosDelete && selectedPhotos.length > 0) {
      onPhotosDelete(selectedPhotos);
      clearSelection();
    }
  };

  const renderPhotoItem = (photo: PhotoMetadata, index: number) => {
    const isSelected = selectedPhotos.some(p => p.id === photo.id);
    const scale = getPhotoScale(photo.id);
    
    return (
      <Animated.View
        key={photo.id}
        style={[
          styles.gridItem,
          { transform: [{ scale }] },
        ]}
      >
        <TouchableOpacity
          activeOpacity={0.8}
          onPress={() => handlePhotoPress(photo, index)}
          onLongPress={() => handlePhotoLongPress(photo)}
        >
          <View style={[styles.photoContainer, isSelected && styles.photoContainerSelected]}>
            <Image
              source={{ uri: photo.thumbnailUri || photo.uri }}
              style={styles.photo}
              resizeMode="cover"
            />
            
            {/* Selection overlay */}
            {selectionMode && (
              <View style={[styles.selectionOverlay, isSelected && styles.selectionOverlayActive]}>
                <View style={[styles.selectionCheckbox, isSelected && styles.selectionCheckboxActive]}>
                  {isSelected && <Ionicons name="checkmark" size={16} color="white" />}
                </View>
              </View>
            )}
            
            {/* Photo info overlay */}
            <LinearGradient
              colors={['transparent', 'rgba(0, 0, 0, 0.6)']}
              style={styles.photoInfoOverlay}
            >
              <View style={styles.photoInfo}>
                {photo.isFavorite && (
                  <Ionicons name="heart" size={16} color={colors.semantic.error.light} />
                )}
                {photo.caption && (
                  <Ionicons name="chatbubble" size={14} color="white" style={styles.photoInfoIcon} />
                )}
                {photo.location && (
                  <Ionicons name="location" size={14} color="white" style={styles.photoInfoIcon} />
                )}
              </View>
            </LinearGradient>
          </View>
        </TouchableOpacity>
      </Animated.View>
    );
  };

  const renderViewModeSelector = () => (
    <View style={[styles.viewModeContainer, { backgroundColor: theme.colors.background.elevated }]}>
      <TouchableOpacity
        style={[styles.viewModeButton, viewMode === 'grid' && styles.viewModeButtonActive]}
        onPress={() => setViewMode('grid')}
      >
        <Ionicons name="grid" size={20} color={viewMode === 'grid' ? colors.purple[500] : theme.colors.text.secondary} />
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.viewModeButton, viewMode === 'masonry' && styles.viewModeButtonActive]}
        onPress={() => setViewMode('masonry')}
      >
        <MaterialCommunityIcons name="view-dashboard" size={20} color={viewMode === 'masonry' ? colors.purple[500] : theme.colors.text.secondary} />
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.viewModeButton, viewMode === 'timeline' && styles.viewModeButtonActive]}
        onPress={() => setViewMode('timeline')}
      >
        <Ionicons name="time" size={20} color={viewMode === 'timeline' ? colors.purple[500] : theme.colors.text.secondary} />
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.viewModeButton, viewMode === 'albums' && styles.viewModeButtonActive]}
        onPress={() => setViewMode('albums')}
      >
        <Ionicons name="albums" size={20} color={viewMode === 'albums' ? colors.purple[500] : theme.colors.text.secondary} />
      </TouchableOpacity>
    </View>
  );

  const renderFilters = () => (
    <Animated.View
      style={[
        styles.filtersContainer,
        { 
          backgroundColor: theme.colors.background.secondary,
          height: filterHeight,
        },
      ]}
    >
      <View style={styles.filterSection}>
        <Text style={[styles.filterLabel, { color: theme.colors.text.primary }]}>Sort By</Text>
        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          {(['date', 'name', 'size', 'favorites'] as SortBy[]).map(option => (
            <TouchableOpacity
              key={option}
              style={[styles.filterChip, sortBy === option && styles.filterChipActive]}
              onPress={() => setSortBy(option)}
            >
              <Text
                style={[
                  styles.filterChipText,
                  { color: sortBy === option ? 'white' : theme.colors.text.secondary },
                ]}
              >
                {option.charAt(0).toUpperCase() + option.slice(1)}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>
      
      <View style={styles.filterSection}>
        <Text style={[styles.filterLabel, { color: theme.colors.text.primary }]}>Group By</Text>
        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          {(['none', 'date', 'location', 'album', 'tags'] as GroupBy[]).map(option => (
            <TouchableOpacity
              key={option}
              style={[styles.filterChip, groupBy === option && styles.filterChipActive]}
              onPress={() => setGroupBy(option)}
            >
              <Text
                style={[
                  styles.filterChipText,
                  { color: groupBy === option ? 'white' : theme.colors.text.secondary },
                ]}
              >
                {option.charAt(0).toUpperCase() + option.slice(1)}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>
      
      <TouchableOpacity
        style={styles.sortOrderButton}
        onPress={() => setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')}
      >
        <Ionicons
          name={sortOrder === 'asc' ? 'arrow-up' : 'arrow-down'}
          size={20}
          color={theme.colors.text.primary}
        />
        <Text style={[styles.sortOrderText, { color: theme.colors.text.secondary }]}>
          {sortOrder === 'asc' ? 'Ascending' : 'Descending'}
        </Text>
      </TouchableOpacity>
    </Animated.View>
  );

  const renderSelectionBar = () => (
    <Animated.View
      style={[
        styles.selectionBar,
        {
          backgroundColor: theme.colors.background.elevated,
          height: selectionBarHeight,
        },
      ]}
    >
      <Text style={[styles.selectionText, { color: theme.colors.text.primary }]}>
        {selectedPhotos.length} selected
      </Text>
      
      <View style={styles.selectionActions}>
        <TouchableOpacity style={styles.selectionButton} onPress={selectAll}>
          <Text style={[styles.selectionButtonText, { color: colors.purple[500] }]}>
            Select All
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.selectionButton} onPress={clearSelection}>
          <Text style={[styles.selectionButtonText, { color: theme.colors.text.secondary }]}>
            Clear
          </Text>
        </TouchableOpacity>
        
        {onPhotosDelete && (
          <TouchableOpacity style={styles.selectionButton} onPress={deleteSelectedPhotos}>
            <Ionicons name="trash" size={20} color={colors.semantic.error.main} />
          </TouchableOpacity>
        )}
      </View>
    </Animated.View>
  );

  const renderGroupedContent = () => {
    const groups = Array.from(groupedPhotos.entries());
    
    if (viewMode === 'masonry') {
      return (
        <ScrollView
          refreshControl={
            onRefresh ? (
              <RefreshControl
                refreshing={refreshing}
                onRefresh={onRefresh}
                tintColor={colors.purple[500]}
              />
            ) : undefined
          }
          showsVerticalScrollIndicator={false}
        >
          {groups.map(([groupName, groupPhotos]) => (
            <View key={groupName} style={styles.groupContainer}>
              {groupBy !== 'none' && (
                <View style={styles.groupHeader}>
                  <Text style={[styles.groupTitle, { color: theme.colors.text.primary }]}>
                    {groupName}
                  </Text>
                  <Text style={[styles.groupCount, { color: theme.colors.text.secondary }]}>
                    {groupPhotos.length} photos
                  </Text>
                </View>
              )}
              
              <View style={styles.masonryContainer}>
                <View style={styles.gridContainer}>
                  {groupPhotos.map((photo, index) => renderPhotoItem(photo, index))}
                </View>
              </View>
            </View>
          ))}
        </ScrollView>
      );
    }
    
    // Grid view
    return (
      <ScrollView
        refreshControl={
          onRefresh ? (
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              tintColor={colors.purple[500]}
            />
          ) : undefined
        }
        showsVerticalScrollIndicator={false}
      >
        {groups.map(([groupName, groupPhotos]) => (
          <View key={groupName} style={styles.groupContainer}>
            {groupBy !== 'none' && (
              <View style={styles.groupHeader}>
                <Text style={[styles.groupTitle, { color: theme.colors.text.primary }]}>
                  {groupName}
                </Text>
                <Text style={[styles.groupCount, { color: theme.colors.text.secondary }]}>
                  {groupPhotos.length} photos
                </Text>
              </View>
            )}
            
            <View style={styles.gridContainer}>
              {groupPhotos.map((photo, index) => renderPhotoItem(photo, index))}
            </View>
          </View>
        ))}
      </ScrollView>
    );
  };

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
      {showOrganizationTools && (
        <View style={styles.header}>
          {renderViewModeSelector()}
          
          <TouchableOpacity
            style={styles.filterButton}
            onPress={() => setShowFilters(!showFilters)}
          >
            <Ionicons
              name="options"
              size={20}
              color={showFilters ? colors.purple[500] : theme.colors.text.secondary}
            />
          </TouchableOpacity>
        </View>
      )}
      
      {renderFilters()}
      {renderSelectionBar()}
      
      {isLoading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={colors.purple[500]} />
        </View>
      ) : (
        renderGroupedContent()
      )}
      
      <PhotoGallery
        photos={organizedPhotos}
        initialIndex={galleryStartIndex}
        visible={showGallery}
        onClose={() => setShowGallery(false)}
        onEdit={onPhotoEdit}
        onDelete={photo => {
          if (onPhotosDelete) {
            onPhotosDelete([photo]);
          }
        }}
      />
      
      {selectedPhoto && (
        <PhotoPreview
          photo={selectedPhoto}
          visible={!!selectedPhoto}
          onClose={() => setSelectedPhoto(null)}
          onEdit={onPhotoEdit}
          onDelete={photo => {
            if (onPhotosDelete) {
              onPhotosDelete([photo]);
            }
            setSelectedPhoto(null);
          }}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.1)',
  },
  viewModeContainer: {
    flexDirection: 'row',
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
  },
  viewModeButton: {
    padding: spacing[2],
    paddingHorizontal: spacing[3],
  },
  viewModeButtonActive: {
    backgroundColor: colors.purple[100],
  },
  filterButton: {
    padding: spacing[2],
  },
  filtersContainer: {
    overflow: 'hidden',
    paddingHorizontal: spacing[4],
  },
  filterSection: {
    marginVertical: spacing[2],
  },
  filterLabel: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: spacing[2],
  },
  filterChip: {
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.full,
    backgroundColor: 'rgba(0, 0, 0, 0.05)',
    marginRight: spacing[2],
  },
  filterChipActive: {
    backgroundColor: colors.purple[500],
  },
  filterChipText: {
    fontSize: 12,
    fontWeight: '500',
  },
  sortOrderButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: spacing[2],
  },
  sortOrderText: {
    fontSize: 12,
    marginLeft: spacing[2],
  },
  selectionBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[4],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.1)',
    overflow: 'hidden',
  },
  selectionText: {
    fontSize: 14,
    fontWeight: '600',
  },
  selectionActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectionButton: {
    marginLeft: spacing[3],
    padding: spacing[2],
  },
  selectionButtonText: {
    fontSize: 14,
    fontWeight: '500',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  groupContainer: {
    marginBottom: spacing[4],
  },
  groupHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
  },
  groupTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  groupCount: {
    fontSize: 14,
  },
  masonryContainer: {
    paddingHorizontal: spacing[4],
  },
  gridContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    paddingHorizontal: spacing[4] - spacing[1],
  },
  masonryItem: {
    paddingHorizontal: spacing[1],
    marginBottom: spacing[2],
  },
  gridItem: {
    width: '33.33%',
    padding: spacing[1],
  },
  photoContainer: {
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
    backgroundColor: 'black',
  },
  photoContainerSelected: {
    borderWidth: 3,
    borderColor: colors.purple[500],
  },
  photo: {
    width: '100%',
    aspectRatio: 1,
  },
  selectionOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'flex-start',
    alignItems: 'flex-end',
    padding: spacing[2],
  },
  selectionOverlayActive: {
    backgroundColor: 'rgba(168, 85, 247, 0.3)',
  },
  selectionCheckbox: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: 'white',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  selectionCheckboxActive: {
    backgroundColor: colors.purple[500],
    borderColor: colors.purple[500],
  },
  photoInfoOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    padding: spacing[2],
  },
  photoInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  photoInfoIcon: {
    marginLeft: spacing[1],
  },
});
</file>

<file path="src/components/PhotoManager.tsx">
import React, { useState } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Image,
  ScrollView,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';

interface PhotoManagerProps {
  photos: string[];
  onPhotosChange: (photos: string[]) => void;
  maxPhotos?: number;
}

export const PhotoManager: React.FC<PhotoManagerProps> = ({
  photos,
  onPhotosChange,
  maxPhotos = 10,
}) => {
  const { theme } = useTheme();
  const [isLoading, setIsLoading] = useState(false);

  const pickImage = async () => {
    if (photos.length >= maxPhotos) {
      Alert.alert('写真の上限', `最大${maxPhotos}枚まで追加できます`);
      return;
    }

    const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
    
    if (permissionResult.granted === false) {
      Alert.alert('権限が必要です', 'フォトライブラリへのアクセス権限が必要です');
      return;
    }

    setIsLoading(true);
    
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
        allowsMultipleSelection: true,
        selectionLimit: Math.min(maxPhotos - photos.length, 5),
      });

      if (!result.canceled && result.assets) {
        const newPhotos = result.assets.map(asset => asset.uri);
        onPhotosChange([...photos, ...newPhotos]);
      }
    } catch (error) {
      Alert.alert('エラー', '写真の選択に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  const takePhoto = async () => {
    if (photos.length >= maxPhotos) {
      Alert.alert('写真の上限', `最大${maxPhotos}枚まで追加できます`);
      return;
    }

    const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
    
    if (permissionResult.granted === false) {
      Alert.alert('権限が必要です', 'カメラへのアクセス権限が必要です');
      return;
    }

    setIsLoading(true);
    
    try {
      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets) {
        const newPhoto = result.assets[0].uri;
        onPhotosChange([...photos, newPhoto]);
      }
    } catch (error) {
      Alert.alert('エラー', '写真の撮影に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  const removePhoto = (index: number) => {
    const newPhotos = photos.filter((_, i) => i !== index);
    onPhotosChange(newPhotos);
  };

  const showPhotoOptions = () => {
    Alert.alert(
      '写真を追加',
      '写真の追加方法を選択してください',
      [
        { text: 'キャンセル', style: 'cancel' },
        { text: 'カメラで撮影', onPress: takePhoto },
        { text: 'ライブラリから選択', onPress: pickImage },
      ]
    );
  };

  return (
    <View style={styles.container}>
      {/* Photo Grid */}
      {photos.length > 0 && (
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          style={styles.photosContainer}
          contentContainerStyle={styles.photosContent}
        >
          {photos.map((uri, index) => (
            <View key={index} style={styles.photoItem}>
              <Image source={{ uri }} style={styles.photo} />
              <TouchableOpacity
                style={styles.removeButton}
                onPress={() => removePhoto(index)}
              >
                <Ionicons name="close-circle" size={20} color={colors.red[500]} />
              </TouchableOpacity>
            </View>
          ))}
        </ScrollView>
      )}

      {/* Add Photo Button */}
      {photos.length < maxPhotos && (
        <TouchableOpacity
          style={[
            styles.addButton,
            {
              backgroundColor: theme.colors.background.secondary,
              borderColor: theme.colors.border,
              opacity: isLoading ? 0.5 : 1,
            }
          ]}
          onPress={showPhotoOptions}
          disabled={isLoading}
        >
          <Ionicons 
            name="camera-outline" 
            size={24} 
            color={theme.colors.text.secondary} 
          />
          <Text style={[styles.addButtonText, { color: theme.colors.text.secondary }]}>
            {photos.length === 0 ? '写真を追加' : '写真を追加'}
          </Text>
          <Text style={[styles.addButtonSubtext, { color: theme.colors.text.secondary }]}>
            ({photos.length}/{maxPhotos})
          </Text>
        </TouchableOpacity>
      )}

      {/* Empty State */}
      {photos.length === 0 && (
        <View style={styles.emptyState}>
          <Text style={[styles.emptyStateText, { color: theme.colors.text.secondary }]}>
            写真でアクションの思い出を残しましょう
          </Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    minHeight: 100,
  },
  photosContainer: {
    marginBottom: spacing[3],
  },
  photosContent: {
    paddingRight: spacing[2],
  },
  photoItem: {
    position: 'relative',
    marginRight: spacing[2],
  },
  photo: {
    width: 80,
    height: 80,
    borderRadius: borderRadius.md,
  },
  removeButton: {
    position: 'absolute',
    top: -8,
    right: -8,
    backgroundColor: 'white',
    borderRadius: 10,
  },
  addButton: {
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: spacing[4],
    borderRadius: borderRadius.md,
    borderWidth: 2,
    borderStyle: 'dashed',
  },
  addButtonText: {
    fontSize: 16,
    fontWeight: '500',
    marginTop: spacing[2],
  },
  addButtonSubtext: {
    fontSize: 12,
    marginTop: spacing[1],
  },
  emptyState: {
    alignItems: 'center',
    paddingVertical: spacing[2],
  },
  emptyStateText: {
    fontSize: 14,
    textAlign: 'center',
  },
});
</file>

<file path="src/components/PhotoPreview.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Image,
  Dimensions,
  Modal,
  Animated,
  Share,
  Alert,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
// import MapView, { Marker } from 'react-native-maps'; // Removed dependency
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { PhotoMetadata } from '../services/photoService';
import { PhotoGallery } from './PhotoGallery';
import { PhotoEditor } from './PhotoEditor';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface PhotoPreviewProps {
  photo: PhotoMetadata;
  visible: boolean;
  onClose: () => void;
  onEdit?: (photo: PhotoMetadata) => void;
  onDelete?: (photo: PhotoMetadata) => void;
  onShare?: (photo: PhotoMetadata) => void;
  relatedPhotos?: PhotoMetadata[];
}

export const PhotoPreview: React.FC<PhotoPreviewProps> = ({
  photo,
  visible,
  onClose,
  onEdit,
  onDelete,
  onShare,
  relatedPhotos = [],
}) => {
  const { theme } = useTheme();
  const [showGallery, setShowGallery] = useState(false);
  const [showEditor, setShowEditor] = useState(false);
  const [activeTab, setActiveTab] = useState<'details' | 'metadata' | 'location'>('details');
  
  // Animation values
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(screenHeight)).current;
  const scaleAnim = useRef(new Animated.Value(0.9)).current;

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(slideAnim, {
          toValue: 0,
          tension: 100,
          friction: 10,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 100,
          friction: 10,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible]);

  const handleClose = () => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: screenHeight,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(scaleAnim, {
        toValue: 0.9,
        duration: 200,
        useNativeDriver: true,
      }),
    ]).start(() => {
      onClose();
    });
  };

  const handleShare = async () => {
    if (onShare) {
      onShare(photo);
    } else {
      try {
        await Share.share({
          message: photo.caption || 'Check out this photo!',
          url: photo.uri,
        });
      } catch (error) {
        console.error('Share failed:', error);
      }
    }
  };

  const handleDelete = () => {
    Alert.alert(
      'Delete Photo',
      'Are you sure you want to delete this photo?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: () => {
            if (onDelete) {
              onDelete(photo);
              handleClose();
            }
          },
        },
      ]
    );
  };

  const handleEdit = () => {
    setShowEditor(true);
  };

  const handleSaveEdit = (editedPhoto: PhotoMetadata) => {
    if (onEdit) {
      onEdit(editedPhoto);
    }
    setShowEditor(false);
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / 1024 / 1024).toFixed(1) + ' MB';
  };

  const renderHeader = () => (
    <View style={[styles.header, { backgroundColor: theme.colors.background.elevated }]}>
      <TouchableOpacity style={styles.headerButton} onPress={handleClose}>
        <Ionicons name="close" size={28} color={theme.colors.text.primary} />
      </TouchableOpacity>
      
      <Text style={[styles.headerTitle, { color: theme.colors.text.primary }]}>
        Photo Preview
      </Text>
      
      <View style={styles.headerActions}>
        <TouchableOpacity style={styles.headerButton} onPress={handleShare}>
          <Ionicons name="share-outline" size={24} color={theme.colors.text.primary} />
        </TouchableOpacity>
        
        {onEdit && (
          <TouchableOpacity style={styles.headerButton} onPress={handleEdit}>
            <Ionicons name="create-outline" size={24} color={theme.colors.text.primary} />
          </TouchableOpacity>
        )}
        
        {onDelete && (
          <TouchableOpacity style={styles.headerButton} onPress={handleDelete}>
            <Ionicons name="trash-outline" size={24} color={colors.semantic.error.main} />
          </TouchableOpacity>
        )}
      </View>
    </View>
  );

  const renderPhotoSection = () => (
    <TouchableOpacity
      activeOpacity={0.9}
      onPress={() => setShowGallery(true)}
      style={styles.photoSection}
    >
      <Image source={{ uri: photo.uri }} style={styles.photo} resizeMode="cover" />
      
      <LinearGradient
        colors={['transparent', 'rgba(0, 0, 0, 0.3)']}
        style={styles.photoGradient}
      >
        {photo.caption && (
          <View style={styles.captionContainer}>
            <Text style={styles.caption} numberOfLines={2}>
              {photo.caption}
            </Text>
          </View>
        )}
      </LinearGradient>
      
      <View style={styles.photoActions}>
        {photo.isFavorite && (
          <View style={styles.favoriteIndicator}>
            <Ionicons name="heart" size={20} color={colors.semantic.error.main} />
          </View>
        )}
        
        <TouchableOpacity style={styles.fullscreenButton} onPress={() => setShowGallery(true)}>
          <Ionicons name="expand" size={20} color="white" />
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  const renderTabs = () => (
    <View style={[styles.tabContainer, { backgroundColor: theme.colors.background.secondary }]}>
      <TouchableOpacity
        style={[styles.tab, activeTab === 'details' && styles.tabActive]}
        onPress={() => setActiveTab('details')}
      >
        <Text
          style={[
            styles.tabText,
            { color: theme.colors.text.secondary },
            activeTab === 'details' && { color: colors.purple[500] },
          ]}
        >
          Details
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity
        style={[styles.tab, activeTab === 'metadata' && styles.tabActive]}
        onPress={() => setActiveTab('metadata')}
      >
        <Text
          style={[
            styles.tabText,
            { color: theme.colors.text.secondary },
            activeTab === 'metadata' && { color: colors.purple[500] },
          ]}
        >
          Metadata
        </Text>
      </TouchableOpacity>
      
      {photo.location && (
        <TouchableOpacity
          style={[styles.tab, activeTab === 'location' && styles.tabActive]}
          onPress={() => setActiveTab('location')}
        >
          <Text
            style={[
              styles.tabText,
              { color: theme.colors.text.secondary },
              activeTab === 'location' && { color: colors.purple[500] },
            ]}
          >
            Location
          </Text>
        </TouchableOpacity>
      )}
    </View>
  );

  const renderDetailsTab = () => (
    <ScrollView style={styles.tabContent} showsVerticalScrollIndicator={false}>
      <View style={styles.detailSection}>
        <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
          Photo Information
        </Text>
        
        <View style={styles.detailRow}>
          <View style={styles.detailIcon}>
            <Ionicons name="calendar" size={20} color={theme.colors.text.secondary} />
          </View>
          <View style={styles.detailContent}>
            <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
              Date Taken
            </Text>
            <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
              {photo.takenAt.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
              })}
            </Text>
            <Text style={[styles.detailSubvalue, { color: theme.colors.text.tertiary }]}>
              {photo.takenAt.toLocaleTimeString()}
            </Text>
          </View>
        </View>
        
        <View style={styles.detailRow}>
          <View style={styles.detailIcon}>
            <MaterialCommunityIcons name="image-size-select-actual" size={20} color={theme.colors.text.secondary} />
          </View>
          <View style={styles.detailContent}>
            <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
              Dimensions
            </Text>
            <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
              {photo.width} × {photo.height} pixels
            </Text>
            <Text style={[styles.detailSubvalue, { color: theme.colors.text.tertiary }]}>
              {(photo.width * photo.height / 1000000).toFixed(1)} MP
            </Text>
          </View>
        </View>
        
        <View style={styles.detailRow}>
          <View style={styles.detailIcon}>
            <Ionicons name="document" size={20} color={theme.colors.text.secondary} />
          </View>
          <View style={styles.detailContent}>
            <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
              File Size
            </Text>
            <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
              {formatFileSize(photo.size)}
            </Text>
            <Text style={[styles.detailSubvalue, { color: theme.colors.text.tertiary }]}>
              {photo.mimeType}
            </Text>
          </View>
        </View>
        
        {photo.tags && photo.tags.length > 0 && (
          <View style={styles.detailRow}>
            <View style={styles.detailIcon}>
              <Ionicons name="pricetags" size={20} color={theme.colors.text.secondary} />
            </View>
            <View style={styles.detailContent}>
              <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                Tags
              </Text>
              <View style={styles.tagContainer}>
                {photo.tags.map((tag, index) => (
                  <View key={index} style={styles.tag}>
                    <Text style={styles.tagText}>{tag}</Text>
                  </View>
                ))}
              </View>
            </View>
          </View>
        )}
        
        {photo.album && (
          <View style={styles.detailRow}>
            <View style={styles.detailIcon}>
              <Ionicons name="folder" size={20} color={theme.colors.text.secondary} />
            </View>
            <View style={styles.detailContent}>
              <Text style={[styles.detailLabel, { color: theme.colors.text.secondary }]}>
                Album
              </Text>
              <Text style={[styles.detailValue, { color: theme.colors.text.primary }]}>
                {photo.album}
              </Text>
            </View>
          </View>
        )}
      </View>
      
      {relatedPhotos.length > 0 && (
        <View style={styles.detailSection}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
            Related Photos
          </Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.relatedPhotosContainer}
          >
            {relatedPhotos.map((relatedPhoto, index) => (
              <TouchableOpacity
                key={relatedPhoto.id}
                style={styles.relatedPhoto}
                onPress={() => {
                  // Switch to the related photo
                }}
              >
                <Image source={{ uri: relatedPhoto.thumbnailUri || relatedPhoto.uri }} style={styles.relatedPhotoImage} />
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>
      )}
    </ScrollView>
  );

  const renderMetadataTab = () => (
    <ScrollView style={styles.tabContent} showsVerticalScrollIndicator={false}>
      {photo.exif && (
        <View style={styles.detailSection}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
            Camera Information
          </Text>
          
          {photo.exif.make && (
            <View style={styles.metadataRow}>
              <Text style={[styles.metadataLabel, { color: theme.colors.text.secondary }]}>
                Camera
              </Text>
              <Text style={[styles.metadataValue, { color: theme.colors.text.primary }]}>
                {photo.exif.make} {photo.exif.model}
              </Text>
            </View>
          )}
          
          {photo.exif.focalLength && (
            <View style={styles.metadataRow}>
              <Text style={[styles.metadataLabel, { color: theme.colors.text.secondary }]}>
                Focal Length
              </Text>
              <Text style={[styles.metadataValue, { color: theme.colors.text.primary }]}>
                {photo.exif.focalLength}mm
              </Text>
            </View>
          )}
          
          {photo.exif.aperture && (
            <View style={styles.metadataRow}>
              <Text style={[styles.metadataLabel, { color: theme.colors.text.secondary }]}>
                Aperture
              </Text>
              <Text style={[styles.metadataValue, { color: theme.colors.text.primary }]}>
                f/{photo.exif.aperture}
              </Text>
            </View>
          )}
          
          {photo.exif.exposureTime && (
            <View style={styles.metadataRow}>
              <Text style={[styles.metadataLabel, { color: theme.colors.text.secondary }]}>
                Exposure Time
              </Text>
              <Text style={[styles.metadataValue, { color: theme.colors.text.primary }]}>
                {photo.exif.exposureTime}s
              </Text>
            </View>
          )}
          
          {photo.exif.iso && (
            <View style={styles.metadataRow}>
              <Text style={[styles.metadataLabel, { color: theme.colors.text.secondary }]}>
                ISO
              </Text>
              <Text style={[styles.metadataValue, { color: theme.colors.text.primary }]}>
                {photo.exif.iso}
              </Text>
            </View>
          )}
          
          {photo.exif.flash !== undefined && (
            <View style={styles.metadataRow}>
              <Text style={[styles.metadataLabel, { color: theme.colors.text.secondary }]}>
                Flash
              </Text>
              <Text style={[styles.metadataValue, { color: theme.colors.text.primary }]}>
                {photo.exif.flash ? 'On' : 'Off'}
              </Text>
            </View>
          )}
        </View>
      )}
      
      {photo.editHistory && photo.editHistory.length > 0 && (
        <View style={styles.detailSection}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
            Edit History
          </Text>
          {photo.editHistory.map((edit, index) => (
            <View key={edit.id} style={styles.editHistoryItem}>
              <View style={styles.editHistoryIcon}>
                <Ionicons name="create" size={16} color={colors.purple[500]} />
              </View>
              <View style={styles.editHistoryContent}>
                <Text style={[styles.editHistoryType, { color: theme.colors.text.primary }]}>
                  {edit.type.charAt(0).toUpperCase() + edit.type.slice(1)}
                </Text>
                <Text style={[styles.editHistoryDate, { color: theme.colors.text.tertiary }]}>
                  {edit.timestamp.toLocaleString()}
                </Text>
              </View>
            </View>
          ))}
        </View>
      )}
    </ScrollView>
  );

  const renderLocationTab = () => {
    if (!photo.location) return null;
    
    return (
      <View style={styles.tabContent}>
        <View style={[styles.map, styles.mapPlaceholder, { backgroundColor: theme.colors.background.secondary }]}>
          <Ionicons name="location" size={48} color={theme.colors.text.tertiary} />
          <Text style={[styles.mapPlaceholderText, { color: theme.colors.text.secondary }]}>
            Map functionality unavailable
          </Text>
          <Text style={[styles.mapPlaceholderSubtext, { color: theme.colors.text.tertiary }]}>
            Location: {photo.location.latitude.toFixed(4)}, {photo.location.longitude.toFixed(4)}
          </Text>
        </View>
        
        <View style={[styles.locationInfo, { backgroundColor: theme.colors.background.elevated }]}>
          <View style={styles.locationRow}>
            <Text style={[styles.locationLabel, { color: theme.colors.text.secondary }]}>
              Latitude
            </Text>
            <Text style={[styles.locationValue, { color: theme.colors.text.primary }]}>
              {photo.location.latitude.toFixed(6)}°
            </Text>
          </View>
          
          <View style={styles.locationRow}>
            <Text style={[styles.locationLabel, { color: theme.colors.text.secondary }]}>
              Longitude
            </Text>
            <Text style={[styles.locationValue, { color: theme.colors.text.primary }]}>
              {photo.location.longitude.toFixed(6)}°
            </Text>
          </View>
          
          {photo.location.altitude && (
            <View style={styles.locationRow}>
              <Text style={[styles.locationLabel, { color: theme.colors.text.secondary }]}>
                Altitude
              </Text>
              <Text style={[styles.locationValue, { color: theme.colors.text.primary }]}>
                {photo.location.altitude.toFixed(0)}m
              </Text>
            </View>
          )}
        </View>
      </View>
    );
  };

  const renderTabContent = () => {
    switch (activeTab) {
      case 'details':
        return renderDetailsTab();
      case 'metadata':
        return renderMetadataTab();
      case 'location':
        return renderLocationTab();
      default:
        return null;
    }
  };

  return (
    <>
      <Modal
        visible={visible}
        transparent
        animationType="none"
        onRequestClose={handleClose}
      >
        <Animated.View
          style={[
            styles.backdrop,
            {
              opacity: fadeAnim,
            },
          ]}
        >
          <TouchableOpacity
            style={StyleSheet.absoluteFill}
            activeOpacity={1}
            onPress={handleClose}
          />
          
          <Animated.View
            style={[
              styles.container,
              {
                transform: [
                  { translateY: slideAnim },
                  { scale: scaleAnim },
                ],
              },
            ]}
          >
            <BlurView
              intensity={theme.mode === 'dark' ? 20 : 80}
              style={[styles.content, { backgroundColor: theme.colors.background.primary + 'CC' }]}
            >
              {renderHeader()}
              {renderPhotoSection()}
              {renderTabs()}
              {renderTabContent()}
            </BlurView>
          </Animated.View>
        </Animated.View>
      </Modal>
      
      <PhotoGallery
        photos={[photo, ...relatedPhotos]}
        visible={showGallery}
        onClose={() => setShowGallery(false)}
        initialIndex={0}
        onEdit={onEdit}
        onDelete={onDelete}
        onShare={onShare}
      />
      
      <PhotoEditor
        photo={photo}
        visible={showEditor}
        onClose={() => setShowEditor(false)}
        onSave={handleSaveEdit}
      />
    </>
  );
};

const styles = StyleSheet.create({
  backdrop: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: screenWidth * 0.95,
    maxHeight: screenHeight * 0.9,
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.1)',
  },
  headerButton: {
    padding: spacing[2],
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  headerActions: {
    flexDirection: 'row',
  },
  photoSection: {
    position: 'relative',
    height: screenHeight * 0.4,
    backgroundColor: 'black',
  },
  photo: {
    width: '100%',
    height: '100%',
  },
  photoGradient: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 100,
    justifyContent: 'flex-end',
    padding: spacing[4],
  },
  captionContainer: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.lg,
  },
  caption: {
    color: 'white',
    fontSize: 14,
    lineHeight: 20,
  },
  photoActions: {
    position: 'absolute',
    top: spacing[4],
    right: spacing[4],
    flexDirection: 'row',
  },
  favoriteIndicator: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    padding: spacing[2],
    borderRadius: borderRadius.full,
    marginRight: spacing[2],
  },
  fullscreenButton: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    padding: spacing[2],
    borderRadius: borderRadius.full,
  },
  tabContainer: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.1)',
  },
  tab: {
    flex: 1,
    paddingVertical: spacing[3],
    alignItems: 'center',
  },
  tabActive: {
    borderBottomWidth: 2,
    borderBottomColor: colors.purple[500],
  },
  tabText: {
    fontSize: 14,
    fontWeight: '600',
  },
  tabContent: {
    flex: 1,
  },
  detailSection: {
    padding: spacing[4],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.05)',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '700',
    marginBottom: spacing[3],
  },
  detailRow: {
    flexDirection: 'row',
    marginBottom: spacing[4],
  },
  detailIcon: {
    width: 40,
    alignItems: 'center',
    paddingTop: spacing[1],
  },
  detailContent: {
    flex: 1,
  },
  detailLabel: {
    fontSize: 12,
    marginBottom: spacing[1],
  },
  detailValue: {
    fontSize: 16,
    fontWeight: '500',
  },
  detailSubvalue: {
    fontSize: 12,
    marginTop: spacing[1],
  },
  tagContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: spacing[2],
  },
  tag: {
    backgroundColor: colors.purple[500],
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[1],
    borderRadius: borderRadius.full,
    marginRight: spacing[2],
    marginBottom: spacing[2],
  },
  tagText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '500',
  },
  relatedPhotosContainer: {
    paddingVertical: spacing[2],
  },
  relatedPhoto: {
    width: 80,
    height: 80,
    marginRight: spacing[2],
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
  },
  relatedPhotoImage: {
    width: '100%',
    height: '100%',
  },
  metadataRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: spacing[2],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.05)',
  },
  metadataLabel: {
    fontSize: 14,
  },
  metadataValue: {
    fontSize: 14,
    fontWeight: '500',
  },
  editHistoryItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: spacing[2],
  },
  editHistoryIcon: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: colors.purple[100],
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: spacing[3],
  },
  editHistoryContent: {
    flex: 1,
  },
  editHistoryType: {
    fontSize: 14,
    fontWeight: '500',
  },
  editHistoryDate: {
    fontSize: 12,
    marginTop: spacing[1],
  },
  map: {
    flex: 1,
    minHeight: 200,
  },
  mapPlaceholder: {
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: borderRadius.lg,
    margin: spacing[4],
  },
  mapPlaceholderText: {
    fontSize: 16,
    fontWeight: '500',
    marginTop: spacing[2],
  },
  mapPlaceholderSubtext: {
    fontSize: 12,
    marginTop: spacing[1],
  },
  locationInfo: {
    padding: spacing[4],
  },
  locationRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: spacing[2],
  },
  locationLabel: {
    fontSize: 14,
  },
  locationValue: {
    fontSize: 14,
    fontWeight: '500',
  },
});
</file>

<file path="src/components/SearchableList.tsx">
import React, { useState, useEffect, useMemo, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  Animated,
  ActivityIndicator,
  Keyboard,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { ActionCategory, ParkArea, ParkType } from '../types/models';
import { searchPresets } from '../constants/presets';

interface PresetItem {
  id: string;
  name: string;
  nameEn?: string;
  category: ActionCategory;
  parkType: ParkType;
  area: ParkArea;
  tags?: string[];
  isPopular?: boolean;
  isNew?: boolean;
}

interface SearchableListProps {
  category: ActionCategory;
  parkType: ParkType;
  selectedArea?: ParkArea;
  onSelect: (item: PresetItem) => void;
  placeholder?: string;
  maxResults?: number;
  showRecent?: boolean;
  recentItems?: PresetItem[];
  style?: any;
}

export const SearchableList: React.FC<SearchableListProps> = ({
  category,
  parkType,
  selectedArea,
  onSelect,
  placeholder = "Search for locations...",
  maxResults = 20,
  showRecent = true,
  recentItems = [],
  style,
}) => {
  const { theme } = useTheme();
  const [query, setQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [results, setResults] = useState<PresetItem[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);
  
  const fadeAnimation = useRef(new Animated.Value(0)).current;
  const scaleAnimation = useRef(new Animated.Value(0.95)).current;
  const searchTimeout = useRef<NodeJS.Timeout>();

  // Memoized search function with smart filtering
  const searchResults = useMemo(() => {
    if (!query.trim()) {
      // Show recent items when no search query
      if (showRecent && recentItems.length > 0) {
        return recentItems.slice(0, Math.min(5, maxResults));
      }
      // Show popular items from selected area or category
      const popularItems = searchPresets('', category, parkType)
        .filter(item => item.isPopular && (!selectedArea || item.area === selectedArea))
        .slice(0, Math.min(8, maxResults));
      return popularItems;
    }

    const searchResults = searchPresets(query, category, parkType);
    
    // Smart area detection - if search matches area name, filter by that area
    let filteredResults = searchResults;
    if (selectedArea) {
      filteredResults = searchResults.filter(item => item.area === selectedArea);
    }

    // Sort by relevance
    const sortedResults = filteredResults.sort((a, b) => {
      // Exact name matches first
      if (a.name.toLowerCase() === query.toLowerCase()) return -1;
      if (b.name.toLowerCase() === query.toLowerCase()) return 1;
      
      // Popular items next
      if (a.isPopular && !b.isPopular) return -1;
      if (b.isPopular && !a.isPopular) return 1;
      
      // New items next
      if (a.isNew && !b.isNew) return -1;
      if (b.isNew && !a.isNew) return 1;
      
      // Name starts with query
      const aStartsWith = a.name.toLowerCase().startsWith(query.toLowerCase());
      const bStartsWith = b.name.toLowerCase().startsWith(query.toLowerCase());
      if (aStartsWith && !bStartsWith) return -1;
      if (bStartsWith && !aStartsWith) return 1;
      
      // Alphabetical
      return a.name.localeCompare(b.name);
    });

    return sortedResults.slice(0, maxResults);
  }, [query, category, parkType, selectedArea, recentItems, showRecent, maxResults]);

  // Debounced search effect
  useEffect(() => {
    if (searchTimeout.current) {
      clearTimeout(searchTimeout.current);
    }

    setIsSearching(true);
    searchTimeout.current = setTimeout(() => {
      setResults(searchResults);
      setIsSearching(false);
      setHighlightedIndex(-1);
    }, 200);

    return () => {
      if (searchTimeout.current) {
        clearTimeout(searchTimeout.current);
      }
    };
  }, [searchResults]);

  // Animation effects
  useEffect(() => {
    if (showSuggestions && results.length > 0) {
      Animated.parallel([
        Animated.timing(fadeAnimation, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnimation, {
          toValue: 1,
          tension: 100,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(fadeAnimation, {
          toValue: 0,
          duration: 150,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnimation, {
          toValue: 0.95,
          duration: 150,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [showSuggestions, results.length]);

  const getCategoryColor = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return colors.purple[500];
      case ActionCategory.RESTAURANT:
        return colors.orange[500];
      case ActionCategory.SHOW:
        return colors.pink[500];
      case ActionCategory.GREETING:
        return colors.yellow[500];
      case ActionCategory.SHOPPING:
        return colors.green[500];
      default:
        return colors.gray[500];
    }
  };

  const getCategoryIcon = (category: ActionCategory) => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      default:
        return 'location';
    }
  };

  const formatAreaName = (area: ParkArea): string => {
    return area.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };

  const handleSelect = (item: PresetItem) => {
    setQuery(item.name);
    setShowSuggestions(false);
    onSelect(item);
    Keyboard.dismiss();
  };

  const handleInputFocus = () => {
    setShowSuggestions(true);
  };

  const handleInputBlur = () => {
    // Delay hiding suggestions to allow for item selection
    setTimeout(() => setShowSuggestions(false), 150);
  };

  const renderResultItem = ({ item, index }: { item: PresetItem; index: number }) => {
    const isHighlighted = index === highlightedIndex;
    const categoryColor = getCategoryColor(item.category);

    return (
      <TouchableOpacity
        style={[
          styles.resultItem,
          {
            backgroundColor: isHighlighted 
              ? theme.colors.background.elevated 
              : 'transparent',
            borderLeftColor: categoryColor,
          },
        ]}
        onPress={() => handleSelect(item)}
        activeOpacity={0.7}
      >
        <View style={styles.resultContent}>
          <View style={styles.resultHeader}>
            <View style={styles.resultTitleContainer}>
              <Ionicons
                name={getCategoryIcon(item.category) as any}
                size={16}
                color={categoryColor}
                style={styles.resultIcon}
              />
              <Text 
                style={[styles.resultTitle, { color: theme.colors.text.primary }]}
                numberOfLines={1}
              >
                {item.name}
              </Text>
              {item.isNew && (
                <View style={[styles.badge, { backgroundColor: colors.green[500] }]}>
                  <Text style={styles.badgeText}>NEW</Text>
                </View>
              )}
              {item.isPopular && (
                <Ionicons
                  name="star"
                  size={12}
                  color={colors.yellow[500]}
                  style={styles.popularIcon}
                />
              )}
            </View>
            <Text 
              style={[styles.resultArea, { color: theme.colors.text.secondary }]}
              numberOfLines={1}
            >
              {formatAreaName(item.area)}
            </Text>
          </View>
          
          {item.nameEn && (
            <Text 
              style={[styles.resultSubtitle, { color: theme.colors.text.tertiary }]}
              numberOfLines={1}
            >
              {item.nameEn}
            </Text>
          )}
          
          {item.tags && item.tags.length > 0 && (
            <View style={styles.tagContainer}>
              {item.tags.slice(0, 3).map((tag, index) => (
                <View 
                  key={index}
                  style={[
                    styles.tag,
                    { 
                      backgroundColor: `${categoryColor}20`,
                      borderColor: `${categoryColor}40`,
                    }
                  ]}
                >
                  <Text 
                    style={[
                      styles.tagText, 
                      { color: categoryColor }
                    ]}
                  >
                    {tag}
                  </Text>
                </View>
              ))}
            </View>
          )}
        </View>
      </TouchableOpacity>
    );
  };

  const renderHeader = () => {
    if (query.trim() === '') {
      const headerText = showRecent && recentItems.length > 0 
        ? 'Recent locations'
        : 'Popular locations';
      
      return (
        <View style={styles.sectionHeader}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text.secondary }]}>
            {headerText}
          </Text>
        </View>
      );
    }
    return null;
  };

  const renderEmpty = () => {
    if (isSearching) {
      return (
        <View style={styles.emptyContainer}>
          <ActivityIndicator size="small" color={getCategoryColor(category)} />
          <Text style={[styles.emptyText, { color: theme.colors.text.tertiary }]}>
            Searching...
          </Text>
        </View>
      );
    }

    if (query.trim() !== '' && results.length === 0) {
      return (
        <View style={styles.emptyContainer}>
          <Ionicons
            name="search"
            size={24}
            color={theme.colors.text.tertiary}
          />
          <Text style={[styles.emptyText, { color: theme.colors.text.tertiary }]}>
            No results found
          </Text>
          <Text style={[styles.emptySubtext, { color: theme.colors.text.tertiary }]}>
            Try a different search term
          </Text>
        </View>
      );
    }

    return null;
  };

  return (
    <View style={[styles.container, style]}>
      <View style={styles.searchContainer}>
        <View style={[
          styles.searchInputContainer,
          {
            backgroundColor: theme.colors.background.elevated,
            borderColor: showSuggestions ? getCategoryColor(category) : theme.colors.border,
          }
        ]}>
          <Ionicons
            name="search"
            size={20}
            color={theme.colors.text.secondary}
            style={styles.searchIcon}
          />
          <TextInput
            style={[
              styles.searchInput,
              { color: theme.colors.text.primary }
            ]}
            value={query}
            onChangeText={setQuery}
            onFocus={handleInputFocus}
            onBlur={handleInputBlur}
            placeholder={placeholder}
            placeholderTextColor={theme.colors.text.tertiary}
            returnKeyType="search"
            autoCapitalize="words"
            autoCorrect={false}
          />
          {query.length > 0 && (
            <TouchableOpacity
              onPress={() => setQuery('')}
              style={styles.clearButton}
            >
              <Ionicons
                name="close-circle"
                size={20}
                color={theme.colors.text.secondary}
              />
            </TouchableOpacity>
          )}
        </View>
      </View>

      {showSuggestions && (
        <Animated.View
          style={[
            styles.suggestionsContainer,
            {
              backgroundColor: theme.colors.background.elevated,
              borderColor: theme.colors.border,
              opacity: fadeAnimation,
              transform: [{ scale: scaleAnimation }],
            },
          ]}
        >
          <FlatList
            data={results}
            keyExtractor={(item) => item.id}
            renderItem={renderResultItem}
            ListHeaderComponent={renderHeader}
            ListEmptyComponent={renderEmpty}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
            style={styles.resultsList}
            contentContainerStyle={styles.resultsContent}
          />
        </Animated.View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'relative',
    zIndex: 10,
  },
  searchContainer: {
    marginBottom: spacing[2],
  },
  searchInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1.5,
    borderRadius: borderRadius.lg,
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
  },
  searchIcon: {
    marginRight: spacing[2],
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
  },
  clearButton: {
    padding: spacing[1],
  },
  suggestionsContainer: {
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    maxHeight: 300,
    borderWidth: 1,
    borderRadius: borderRadius.lg,
    marginTop: spacing[1],
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 8,
    zIndex: 1000,
  },
  resultsList: {
    maxHeight: 280,
  },
  resultsContent: {
    paddingVertical: spacing[2],
  },
  sectionHeader: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[2],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
  },
  sectionTitle: {
    fontSize: 12,
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  resultItem: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[3],
    borderLeftWidth: 3,
    borderLeftColor: 'transparent',
  },
  resultContent: {
    flex: 1,
  },
  resultHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: spacing[1],
  },
  resultTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    marginRight: spacing[2],
  },
  resultIcon: {
    marginRight: spacing[2],
  },
  resultTitle: {
    fontSize: 16,
    fontWeight: '600',
    flex: 1,
  },
  resultArea: {
    fontSize: 12,
    fontWeight: '500',
  },
  resultSubtitle: {
    fontSize: 14,
    fontStyle: 'italic',
    marginBottom: spacing[1],
  },
  badge: {
    paddingHorizontal: spacing[1],
    paddingVertical: 2,
    borderRadius: borderRadius.sm,
    marginLeft: spacing[2],
  },
  badgeText: {
    color: 'white',
    fontSize: 10,
    fontWeight: '700',
  },
  popularIcon: {
    marginLeft: spacing[1],
  },
  tagContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: spacing[1],
  },
  tag: {
    paddingHorizontal: spacing[2],
    paddingVertical: 2,
    borderRadius: borderRadius.sm,
    borderWidth: 1,
    marginRight: spacing[1],
    marginBottom: spacing[1],
  },
  tagText: {
    fontSize: 11,
    fontWeight: '500',
  },
  emptyContainer: {
    alignItems: 'center',
    paddingVertical: spacing[6],
  },
  emptyText: {
    fontSize: 14,
    fontWeight: '500',
    marginTop: spacing[2],
  },
  emptySubtext: {
    fontSize: 12,
    marginTop: spacing[1],
  },
});
</file>

<file path="src/components/SwipeableScreen.tsx">
import React, { useRef } from 'react';
import { View, Animated, Dimensions, PanResponder } from 'react-native';

const { width: screenWidth } = Dimensions.get('window');

interface SwipeableScreenProps {
  children: React.ReactNode;
  onSwipeFromLeft?: () => void;
  swipeThreshold?: number;
  edgeWidth?: number;
}

export const SwipeableScreen: React.FC<SwipeableScreenProps> = ({
  children,
  onSwipeFromLeft,
  swipeThreshold = 100,
  edgeWidth = 30,
}) => {
  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => false,
      onMoveShouldSetPanResponder: (evt, gestureState) => {
        const { pageX, dx, dy } = gestureState;
        // より厳密な条件：左端から開始、水平移動優先、十分な水平移動距離
        return pageX <= edgeWidth && 
               dx > 20 && 
               Math.abs(dx) > Math.abs(dy) * 2 &&
               Math.abs(dy) < 30;
      },
      onPanResponderTerminationRequest: () => true, // 他のコンポーネントがコントロールを要求した場合は許可
      onPanResponderGrant: () => {
        // タッチ開始時
      },
      onPanResponderMove: () => {
        // 移動中
      },
      onPanResponderRelease: (evt, gestureState) => {
        const { dx, vx, pageX } = gestureState;
        // より厳密な条件で実行
        if ((dx > swipeThreshold || vx > 0.7) && pageX <= edgeWidth) {
          onSwipeFromLeft?.();
        }
      },
    })
  ).current;

  return (
    <View style={{ flex: 1 }}>
      <View style={{ position: 'absolute', left: 0, top: 0, bottom: 0, width: edgeWidth, zIndex: 1 }} {...panResponder.panHandlers} />
      {children}
    </View>
  );
};

export default SwipeableScreen;
</file>

<file path="src/components/ThemeCustomizer.tsx">
// Clean Theme Customizer Component
// Beautiful white-based design with intuitive controls

import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Animated,
  TextInput,
  Share,
  Alert,
  Dimensions,
  Platform,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
// Removed designStyles import to avoid dependency issues

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface ThemeCustomizerProps {
  visible: boolean;
  onClose: () => void;
}

interface PreviewCardProps {
  title: string;
  children: React.ReactNode;
}

// Preview Card Component
const PreviewCard: React.FC<PreviewCardProps> = ({ title, children }) => {
  const { theme } = useTheme();

  return (
    <View
      style={[
        styles.previewCard,
        {
          backgroundColor: colors.background.card,
          borderRadius: 12,
          shadowColor: colors.effects.shadowSoft,
          shadowOffset: { width: 0, height: 2 },
          shadowOpacity: 1,
          shadowRadius: 8,
          elevation: 3,
          borderWidth: 1,
          borderColor: colors.utility.borderLight,
        },
      ]}
    >
      <Text style={[styles.previewCardTitle, { color: colors.text.secondary }]}>
        {title}
      </Text>
      {children}
    </View>
  );
};

// Main Theme Customizer Component
export const ThemeCustomizer: React.FC<ThemeCustomizerProps> = ({ visible, onClose }) => {
  const {
    theme,
    themeConfig,
    setDesignStyle,
    setAccentColor,
    setAnimationSpeed,
    setBorderRadiusPreference,
    setShadowIntensity,
    resetThemeDefaults,
    exportThemeSettings,
    importThemeSettings,
  } = useTheme();

  const [showColorPicker, setShowColorPicker] = useState(false);
  const [tempAccentColor, setTempAccentColor] = useState(themeConfig.accentColor);
  const [importText, setImportText] = useState('');
  const [showImportModal, setShowImportModal] = useState(false);

  const slideAnim = useRef(new Animated.Value(screenHeight)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;

  // Design styles
  const designStyles: { value: string; label: string; icon: string }[] = [
    { value: 'material', label: 'Material', icon: 'layers' },
    { value: 'neumorphism', label: 'Neumorphism', icon: 'bulb' },
    { value: 'glassmorphism', label: 'Glassmorphism', icon: 'water' },
    { value: 'futuristic', label: 'Futuristic', icon: 'rocket' },
  ];

  // Animation speeds
  const animationSpeeds: { value: string; label: string; icon: string }[] = [
    { value: 'instant', label: 'Instant', icon: 'flash' },
    { value: 'fast', label: 'Fast', icon: 'speedometer' },
    { value: 'normal', label: 'Normal', icon: 'timer' },
    { value: 'slow', label: 'Slow', icon: 'hourglass' },
    { value: 'cinematic', label: 'Cinematic', icon: 'film' },
  ];

  // Preset accent colors - vibrant and beautiful
  const presetColors = [
    colors.purple[500],   // Purple
    colors.blue[500],     // Blue  
    colors.green[500],    // Green
    colors.orange[500],   // Orange
    colors.red[500],      // Red
    colors.pink[500],     // Pink
    colors.teal[500],     // Teal
    colors.yellow[500],   // Yellow
  ];

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.spring(slideAnim, {
          toValue: 0,
          damping: 20,
          stiffness: 90,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.spring(slideAnim, {
          toValue: screenHeight,
          damping: 20,
          stiffness: 90,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible]);

  const handleDesignStyleChange = (style: string) => {
    setDesignStyle(style);
  };

  const handleAnimationSpeedChange = (speed: string) => {
    setAnimationSpeed(speed);
  };

  const handleAccentColorChange = (color: string) => {
    setTempAccentColor(color);
  };

  const applyAccentColor = () => {
    setAccentColor(tempAccentColor);
    setShowColorPicker(false);
  };

  const handlePresetColorSelect = (color: string) => {
    setAccentColor(color);
  };

  const handleExport = async () => {
    const settings = exportThemeSettings();
    
    try {
      await Share.share({
        message: settings,
        title: 'TDR Days Theme Settings',
      });
    } catch (error) {
      Alert.alert('Export Failed', 'Unable to export theme settings');
    }
  };

  const handleImport = async () => {
    const success = await importThemeSettings(importText);
    
    if (success) {
      Alert.alert('Success', 'Theme settings imported successfully!');
      setShowImportModal(false);
      setImportText('');
    } else {
      Alert.alert('Import Failed', 'Invalid theme settings format');
    }
  };

  const handleReset = () => {
    Alert.alert(
      'Reset Theme',
      'Are you sure you want to reset all theme customizations to defaults?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Reset',
          style: 'destructive',
          onPress: () => {
            resetThemeDefaults();
          },
        },
      ]
    );
  };

  return (
    <Modal
      visible={visible}
      transparent
      animationType="slide"
      onRequestClose={onClose}
    >
      {/* Backdrop */}
      <View style={styles.backdrop}>
        <TouchableOpacity
          style={StyleSheet.absoluteFillObject}
          activeOpacity={1}
          onPress={onClose}
        />
      </View>

      {/* Main Container */}
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.headerContent}>
            <Text style={styles.headerTitle}>テーマスタジオ</Text>
            <Text style={styles.headerSubtitle}>アプリの外観をカスタマイズ</Text>
          </View>
          <TouchableOpacity onPress={onClose} style={styles.closeButton}>
            <Ionicons name="close" size={28} color={colors.text.primary} />
          </TouchableOpacity>
        </View>

        <ScrollView
          showsVerticalScrollIndicator={false}
          contentContainerStyle={styles.scrollContent}
        >
          {/* Live Preview Section */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>プレビュー</Text>
            <View style={styles.previewGrid}>
              <PreviewCard title="ボタン">
                <TouchableOpacity
                  style={[
                    styles.previewButton,
                    {
                      backgroundColor: themeConfig.accentColor,
                    },
                  ]}
                >
                  <Text style={styles.previewButtonText}>サンプル</Text>
                </TouchableOpacity>
              </PreviewCard>

              <PreviewCard title="カード">
                <View style={styles.previewCardContent}>
                  <View
                    style={[
                      styles.previewAvatar,
                      {
                        backgroundColor: themeConfig.accentColor + '15',
                      },
                    ]}
                  >
                    <Ionicons name="heart" size={20} color={themeConfig.accentColor} />
                  </View>
                  <Text style={styles.previewCardText}>サンプルテキスト</Text>
                </View>
              </PreviewCard>
            </View>
          </View>

          {/* Design Style */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>デザインスタイル</Text>
            <View style={styles.optionGrid}>
              {designStyles.map((style) => (
                <TouchableOpacity
                  key={style.value}
                  style={[
                    styles.optionCard,
                    {
                      backgroundColor:
                        themeConfig.designStyle === style.value
                          ? themeConfig.accentColor + '10'
                          : colors.background.card,
                      borderColor:
                        themeConfig.designStyle === style.value
                          ? themeConfig.accentColor
                          : colors.utility.border,
                      borderWidth: 1.5,
                    },
                  ]}
                  onPress={() => handleDesignStyleChange(style.value)}
                >
                  <Ionicons
                    name={style.icon as any}
                    size={24}
                    color={
                      themeConfig.designStyle === style.value
                        ? themeConfig.accentColor
                        : colors.text.secondary
                    }
                  />
                  <Text
                    style={[
                      styles.optionLabel,
                      {
                        color:
                          themeConfig.designStyle === style.value
                            ? themeConfig.accentColor
                            : colors.text.primary,
                      },
                    ]}
                  >
                    {style.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          {/* Accent Color */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>アクセントカラー</Text>
            <View style={styles.colorSection}>
              <View style={styles.presetColors}>
                {presetColors.map((color) => (
                  <TouchableOpacity
                    key={color}
                    style={[
                      styles.colorSwatch,
                      {
                        backgroundColor: color,
                        borderWidth: themeConfig.accentColor === color ? 3 : 2,
                        borderColor: themeConfig.accentColor === color ? colors.utility.white : colors.utility.border,
                        shadowColor: themeConfig.accentColor === color ? color : colors.effects.shadowSoft,
                        shadowOffset: { width: 0, height: 2 },
                        shadowOpacity: themeConfig.accentColor === color ? 0.3 : 0.1,
                        shadowRadius: 4,
                        elevation: themeConfig.accentColor === color ? 3 : 1,
                      },
                    ]}
                    onPress={() => handlePresetColorSelect(color)}
                  >
                    {themeConfig.accentColor === color && (
                      <Ionicons name="checkmark" size={16} color="white" />
                    )}
                  </TouchableOpacity>
                ))}
              </View>
              <TouchableOpacity
                style={[
                  styles.customColorButton,
                  {
                    backgroundColor: themeConfig.accentColor,
                  },
                ]}
                onPress={() => setShowColorPicker(true)}
              >
                <Ionicons name="color-palette" size={18} color="white" />
                <Text style={styles.customColorButtonText}>カスタムカラー</Text>
              </TouchableOpacity>
            </View>
          </View>

          {/* Animation Speed */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>アニメーション速度</Text>
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.horizontalOptions}
            >
              {animationSpeeds.map((speed) => (
                <TouchableOpacity
                  key={speed.value}
                  style={[
                    styles.speedOption,
                    {
                      backgroundColor:
                        themeConfig.animationSpeed === speed.value
                          ? themeConfig.accentColor
                          : colors.background.card,
                      borderWidth: 1,
                      borderColor:
                        themeConfig.animationSpeed === speed.value
                          ? themeConfig.accentColor
                          : colors.utility.border,
                    },
                  ]}
                  onPress={() => handleAnimationSpeedChange(speed.value)}
                >
                  <Ionicons
                    name={speed.icon as any}
                    size={18}
                    color={
                      themeConfig.animationSpeed === speed.value
                        ? 'white'
                        : colors.text.secondary
                    }
                  />
                  <Text
                    style={[
                      styles.speedLabel,
                      {
                        color:
                          themeConfig.animationSpeed === speed.value
                            ? 'white'
                            : colors.text.primary,
                      },
                    ]}
                  >
                    {speed.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>

          {/* Actions */}
          <View style={styles.actions}>
            <TouchableOpacity
              style={[styles.actionButton, { backgroundColor: colors.background.card }]}
              onPress={handleExport}
            >
              <Ionicons name="share" size={20} color={colors.text.primary} />
              <Text style={styles.actionButtonText}>エクスポート</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.actionButton, { backgroundColor: colors.background.card }]}
              onPress={() => setShowImportModal(true)}
            >
              <Ionicons name="download" size={20} color={colors.text.primary} />
              <Text style={styles.actionButtonText}>インポート</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.actionButton, { backgroundColor: colors.semantic.error.background }]}
              onPress={handleReset}
            >
              <Ionicons name="refresh" size={20} color={colors.semantic.error.main} />
              <Text style={[styles.actionButtonText, { color: colors.semantic.error.main }]}>
                リセット
              </Text>
            </TouchableOpacity>
          </View>

          {/* Bottom spacing */}
          <View style={{ height: 100 }} />
        </ScrollView>
      </View>

      {/* Simple Color Picker Modal */}
      <Modal
        visible={showColorPicker}
        transparent
        animationType="slide"
        onRequestClose={() => setShowColorPicker(false)}
      >
        <View style={styles.modalBackdrop}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>カスタムカラー</Text>
            <TextInput
              style={[styles.colorInput, { borderColor: tempAccentColor }]}
              placeholder="#9333ea"
              placeholderTextColor={colors.text.tertiary}
              value={tempAccentColor}
              onChangeText={handleAccentColorChange}
              autoCapitalize="none"
            />
            <View style={[styles.colorPreview, { backgroundColor: tempAccentColor }]} />
            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, { backgroundColor: colors.background.tertiary }]}
                onPress={() => setShowColorPicker(false)}
              >
                <Text style={styles.modalButtonText}>キャンセル</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, { backgroundColor: tempAccentColor }]}
                onPress={applyAccentColor}
              >
                <Text style={[styles.modalButtonText, { color: 'white' }]}>適用</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </Modal>
  );
};

const styles = StyleSheet.create({
  // Main Container Styles
  backdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
  },
  container: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: screenHeight * 0.92,
    backgroundColor: colors.background.primary,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    shadowColor: colors.effects.shadowSoft,
    shadowOffset: { width: 0, height: -4 },
    shadowOpacity: 1,
    shadowRadius: 12,
    elevation: 8,
  },

  // Header Styles
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 24,
    paddingTop: 20,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: colors.utility.borderLight,
  },
  headerContent: {
    flex: 1,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: '700',
    color: colors.text.primary,
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
    color: colors.text.secondary,
  },
  closeButton: {
    padding: 8,
    borderRadius: 8,
    backgroundColor: colors.background.tertiary,
  },

  // Content Styles
  scrollContent: {
    paddingHorizontal: 24,
    paddingVertical: 16,
  },
  section: {
    marginBottom: 32,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: colors.text.primary,
    marginBottom: 16,
  },

  // Preview Styles
  previewGrid: {
    flexDirection: 'row',
    gap: 12,
  },
  previewCard: {
    flex: 1,
    padding: 16,
  },
  previewCardTitle: {
    fontSize: 11,
    fontWeight: '500',
    marginBottom: 12,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  previewButton: {
    paddingVertical: 12,
    paddingHorizontal: 20,
    alignItems: 'center',
    borderRadius: 8,
  },
  previewButtonText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  previewCardContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  previewAvatar: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
  },
  previewCardText: {
    fontSize: 14,
    fontWeight: '500',
    color: colors.text.primary,
  },

  // Option Grid Styles
  optionGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'stretch',
    gap: 6,
  },
  optionCard: {
    flex: 1,
    minWidth: 60,
    maxWidth: 80,
    aspectRatio: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 12,
    borderRadius: 12,
    shadowColor: colors.effects.shadowSoft,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 1,
    shadowRadius: 4,
    elevation: 2,
    marginHorizontal: 3,
  },
  optionLabel: {
    fontSize: 11,
    fontWeight: '500',
    marginTop: 8,
    textAlign: 'center',
  },

  // Color Styles
  colorSection: {
    gap: 16,
  },
  presetColors: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
  },
  colorSwatch: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  customColorButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    gap: 8,
  },
  customColorButtonText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },

  // Horizontal Options
  horizontalOptions: {
    flexDirection: 'row',
    gap: 12,
    paddingRight: 24,
  },
  speedOption: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    gap: 6,
  },
  speedLabel: {
    fontSize: 13,
    fontWeight: '500',
  },

  // Action Styles
  actions: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 16,
  },
  actionButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 10,
    gap: 8,
    borderWidth: 1,
    borderColor: colors.utility.border,
    shadowColor: colors.effects.shadowSoft,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 1,
    shadowRadius: 2,
    elevation: 1,
  },
  actionButtonText: {
    fontSize: 13,
    fontWeight: '600',
    color: colors.text.primary,
  },

  // Modal Styles
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  modalContainer: {
    width: '100%',
    maxWidth: 320,
    backgroundColor: colors.background.card,
    borderRadius: 16,
    padding: 24,
    shadowColor: colors.effects.shadowMedium,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 1,
    shadowRadius: 12,
    elevation: 6,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: colors.text.primary,
    textAlign: 'center',
    marginBottom: 20,
  },
  colorInput: {
    backgroundColor: colors.background.tertiary,
    borderWidth: 2,
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: colors.text.primary,
    marginBottom: 16,
  },
  colorPreview: {
    height: 60,
    borderRadius: 8,
    marginBottom: 20,
  },
  modalActions: {
    flexDirection: 'row',
    gap: 12,
  },
  modalButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  modalButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.text.primary,
  },
});

export default ThemeCustomizer;
</file>

<file path="src/components/TimelineAction.tsx">
import React, { useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Image,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { TimelineAction as TimelineActionType, ActionCategory } from '../types/models';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';

interface TimelineActionProps {
  action: TimelineActionType;
  isLast?: boolean;
  onPress: () => void;
  onLongPress: () => void;
  isDragActive?: boolean;
  dragHandleProps?: any;
}

export const TimelineAction: React.FC<TimelineActionProps> = ({
  action,
  isLast = false,
  onPress,
  onLongPress,
  isDragActive = false,
  dragHandleProps,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  const scaleAnimation = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    Animated.spring(scaleAnimation, {
      toValue: isDragActive ? 1.05 : 1,
      useNativeDriver: true,
      tension: 100,
      friction: 8,
    }).start();
  }, [isDragActive, scaleAnimation]);

  const formatTime = (date: Date) => {
    return new Intl.DateTimeFormat('ja-JP', {
      hour: '2-digit',
      minute: '2-digit',
    }).format(new Date(date));
  };

  const getCategoryIcon = () => {
    switch (action.category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      default:
        return 'calendar';
    }
  };

  const getCategoryColor = () => {
    switch (action.category) {
      case ActionCategory.ATTRACTION:
        return colors.purple[500];
      case ActionCategory.RESTAURANT:
        return colors.orange[500];
      case ActionCategory.SHOW:
        return colors.pink[500];
      case ActionCategory.GREETING:
        return colors.yellow[500];
      case ActionCategory.SHOPPING:
        return colors.green[500];
      default:
        return colors.gray[500];
    }
  };

  const getDurationText = () => {
    if (action.duration) {
      const hours = Math.floor(action.duration / 60);
      const minutes = action.duration % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      return `${minutes}m`;
    }
    return null;
  };

  const getWaitTimeText = () => {
    if (action.waitTime && action.waitTime > 0) {
      return `Wait: ${action.waitTime}m`;
    }
    return null;
  };

  const getRatingStars = () => {
    if (!action.rating) return null;
    return Array.from({ length: 5 }, (_, i) => (
      <Ionicons
        key={i}
        name={i < action.rating! ? 'star' : 'star-outline'}
        size={12}
        color={colors.yellow[500]}
        style={{ marginRight: 2 }}
      />
    ));
  };

  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [{ scale: scaleAnimation }],
          opacity: isDragActive ? 0.8 : 1,
        },
      ]}
    >
      <View style={styles.timelineRow}>
        {/* Timeline Connector */}
        <View style={styles.timelineConnector}>
          <View
            style={[
              styles.timelineNode,
              {
                backgroundColor: getCategoryColor(),
                borderColor: theme.colors.background.primary,
              },
            ]}
          >
            <Ionicons
              name={getCategoryIcon() as any}
              size={14}
              color="white"
            />
          </View>
          {!isLast && (
            <View
              style={[
                styles.timelineLine,
                { backgroundColor: theme.colors.border },
              ]}
            />
          )}
        </View>

        {/* Action Card */}
        <TouchableOpacity
          style={[
            styles.actionCard,
            {
              backgroundColor: isDark
                ? theme.colors.background.secondary
                : theme.colors.background.elevated,
              shadowColor: isDragActive ? getCategoryColor() : theme.colors.shadow,
            },
          ]}
          onPress={onPress}
          onLongPress={onLongPress}
          activeOpacity={0.7}
          {...dragHandleProps}
        >
          <LinearGradient
            colors={[
              `${getCategoryColor()}10`,
              `${getCategoryColor()}05`,
            ]}
            style={styles.cardGradient}
          >
            <View style={styles.cardHeader}>
              <View style={styles.headerLeft}>
                <Text
                  style={[
                    styles.timeText,
                    { color: theme.colors.text.secondary },
                  ]}
                >
                  {formatTime(action.time)}
                </Text>
                <Text
                  style={[
                    styles.locationText,
                    { color: theme.colors.text.primary },
                  ]}
                >
                  {action.locationName}
                </Text>
              </View>

              <View style={styles.headerRight}>
                {/* Photos indicator */}
                {action.photos.length > 0 && (
                  <View style={styles.photoIndicator}>
                    {action.photos.slice(0, 3).map((photo, index) => (
                      <View
                        key={photo.id}
                        style={[
                          styles.photoThumbnail,
                          { marginLeft: index > 0 ? -8 : 0 },
                        ]}
                      >
                        <Image
                          source={{ uri: photo.thumbnailUri || photo.uri }}
                          style={styles.thumbnailImage}
                          resizeMode="cover"
                        />
                      </View>
                    ))}
                    {action.photos.length > 3 && (
                      <View
                        style={[
                          styles.photoThumbnail,
                          styles.morePhotos,
                          { backgroundColor: `${getCategoryColor()}20`, marginLeft: -8 },
                        ]}
                      >
                        <Text
                          style={[
                            styles.morePhotosText,
                            { color: getCategoryColor() },
                          ]}
                        >
                          +{action.photos.length - 3}
                        </Text>
                      </View>
                    )}
                  </View>
                )}

                {/* Drag handle */}
                <TouchableOpacity
                  style={styles.dragHandle}
                  {...dragHandleProps}
                >
                  <Ionicons
                    name="reorder-two"
                    size={16}
                    color={theme.colors.text.tertiary}
                  />
                </TouchableOpacity>
              </View>
            </View>

            {/* Meta information */}
            <View style={styles.metaContainer}>
              <View style={styles.metaRow}>
                {getDurationText() && (
                  <View style={styles.metaItem}>
                    <Ionicons
                      name="time-outline"
                      size={12}
                      color={theme.colors.text.tertiary}
                    />
                    <Text
                      style={[
                        styles.metaText,
                        { color: theme.colors.text.secondary },
                      ]}
                    >
                      {getDurationText()}
                    </Text>
                  </View>
                )}

                {getWaitTimeText() && (
                  <View style={styles.metaItem}>
                    <Ionicons
                      name="hourglass-outline"
                      size={12}
                      color={theme.colors.text.tertiary}
                    />
                    <Text
                      style={[
                        styles.metaText,
                        { color: theme.colors.text.secondary },
                      ]}
                    >
                      {getWaitTimeText()}
                    </Text>
                  </View>
                )}

                {action.rating && (
                  <View style={[styles.metaItem, styles.ratingContainer]}>
                    {getRatingStars()}
                  </View>
                )}
              </View>

              {/* Notes preview */}
              {action.notes && (
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.text.secondary },
                  ]}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {action.notes}
                </Text>
              )}
            </View>
          </LinearGradient>
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: spacing[3],
  },
  timelineRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  timelineConnector: {
    alignItems: 'center',
    marginRight: spacing[3],
    width: 24,
  },
  timelineNode: {
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 3,
    zIndex: 1,
  },
  timelineLine: {
    width: 2,
    flex: 1,
    marginTop: 4,
    opacity: 0.3,
  },
  actionCard: {
    flex: 1,
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
    elevation: 2,
  },
  cardGradient: {
    padding: spacing[4],
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: spacing[2],
  },
  headerLeft: {
    flex: 1,
    marginRight: spacing[3],
  },
  timeText: {
    fontSize: 12,
    fontWeight: '500',
    marginBottom: spacing[1],
  },
  locationText: {
    fontSize: 16,
    fontWeight: '600',
    lineHeight: 20,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  photoIndicator: {
    flexDirection: 'row',
    marginRight: spacing[2],
  },
  photoThumbnail: {
    width: 24,
    height: 24,
    borderRadius: 12,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: 'white',
  },
  thumbnailImage: {
    width: '100%',
    height: '100%',
  },
  morePhotos: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  morePhotosText: {
    fontSize: 8,
    fontWeight: '600',
  },
  dragHandle: {
    padding: spacing[1],
  },
  metaContainer: {
    marginTop: spacing[1],
  },
  metaRow: {
    flexDirection: 'row',
    alignItems: 'center',
    flexWrap: 'wrap',
  },
  metaItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: spacing[3],
    marginBottom: spacing[1],
  },
  metaText: {
    fontSize: 12,
    marginLeft: spacing[1],
  },
  ratingContainer: {
    flexDirection: 'row',
  },
  notesText: {
    fontSize: 13,
    lineHeight: 18,
    marginTop: spacing[1],
    fontStyle: 'italic',
  },
});
</file>

<file path="src/components/ValidationFeedback.tsx">
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  TouchableOpacity,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { ValidationResult } from '../utils/validation';

interface ValidationFeedbackProps {
  validation?: ValidationResult;
  onDismiss?: () => void;
  style?: any;
  showSuccess?: boolean;
  successMessage?: string;
}

export const ValidationFeedback: React.FC<ValidationFeedbackProps> = ({
  validation,
  onDismiss,
  style,
  showSuccess = false,
  successMessage = 'All fields are valid',
}) => {
  const { theme } = useTheme();
  const slideAnimation = useRef(new Animated.Value(0)).current;
  const fadeAnimation = useRef(new Animated.Value(0)).current;

  const hasErrors = validation?.errors && validation.errors.length > 0;
  const hasWarnings = validation?.warnings && validation.warnings.length > 0;
  const isValid = validation?.isValid && !hasErrors;
  const shouldShow = hasErrors || hasWarnings || (showSuccess && isValid);

  useEffect(() => {
    if (shouldShow) {
      Animated.parallel([
        Animated.timing(slideAnimation, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnimation, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(slideAnimation, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnimation, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [shouldShow]);

  const getStatusColor = () => {
    if (hasErrors) return colors.red[500];
    if (hasWarnings) return colors.yellow[500];
    if (showSuccess && isValid) return colors.green[500];
    return colors.gray[500];
  };

  const getStatusIcon = () => {
    if (hasErrors) return 'alert-circle';
    if (hasWarnings) return 'warning';
    if (showSuccess && isValid) return 'checkmark-circle';
    return 'information-circle';
  };

  const getStatusText = () => {
    if (hasErrors) return 'Errors found';
    if (hasWarnings) return 'Warnings';
    if (showSuccess && isValid) return 'Success';
    return 'Information';
  };

  const renderMessages = (messages: string[], type: 'error' | 'warning' | 'success') => {
    if (!messages || messages.length === 0) return null;

    const color = type === 'error' ? colors.red[500] : 
                  type === 'warning' ? colors.yellow[500] : colors.green[500];

    return (
      <View style={styles.messageGroup}>
        {messages.map((message, index) => (
          <View key={index} style={styles.messageItem}>
            <Ionicons
              name={getStatusIcon()}
              size={16}
              color={color}
              style={styles.messageIcon}
            />
            <Text
              style={[
                styles.messageText,
                {
                  color: theme.colors.text.primary,
                  opacity: type === 'warning' ? 0.8 : 1,
                }
              ]}
            >
              {message}
            </Text>
          </View>
        ))}
      </View>
    );
  };

  if (!shouldShow) return null;

  return (
    <Animated.View
      style={[
        styles.container,
        style,
        {
          opacity: fadeAnimation,
          transform: [
            {
              translateY: slideAnimation.interpolate({
                inputRange: [0, 1],
                outputRange: [-20, 0],
              }),
            },
          ],
        },
      ]}
    >
      <LinearGradient
        colors={[
          `${getStatusColor()}15`,
          `${getStatusColor()}05`,
        ]}
        style={[
          styles.feedback,
          {
            borderColor: getStatusColor(),
            backgroundColor: theme.colors.background.elevated,
          }
        ]}
      >
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.headerLeft}>
            <Ionicons
              name={getStatusIcon()}
              size={20}
              color={getStatusColor()}
            />
            <Text style={[styles.headerText, { color: theme.colors.text.primary }]}>
              {getStatusText()}
            </Text>
            {(hasErrors || hasWarnings) && (
              <View style={[styles.badge, { backgroundColor: getStatusColor() }]}>
                <Text style={styles.badgeText}>
                  {(validation?.errors?.length || 0) + (validation?.warnings?.length || 0)}
                </Text>
              </View>
            )}
          </View>
          
          {onDismiss && (
            <TouchableOpacity
              onPress={onDismiss}
              style={styles.dismissButton}
            >
              <Ionicons
                name="close"
                size={18}
                color={theme.colors.text.secondary}
              />
            </TouchableOpacity>
          )}
        </View>

        {/* Messages */}
        <View style={styles.content}>
          {hasErrors && renderMessages(validation!.errors, 'error')}
          {hasWarnings && renderMessages(validation!.warnings, 'warning')}
          {showSuccess && isValid && (
            <View style={styles.messageGroup}>
              <View style={styles.messageItem}>
                <Ionicons
                  name="checkmark-circle"
                  size={16}
                  color={colors.green[500]}
                  style={styles.messageIcon}
                />
                <Text
                  style={[
                    styles.messageText,
                    { color: theme.colors.text.primary }
                  ]}
                >
                  {successMessage}
                </Text>
              </View>
            </View>
          )}
        </View>

        {/* Quick Tips */}
        {hasErrors && (
          <View style={styles.tips}>
            <Text style={[styles.tipsTitle, { color: theme.colors.text.secondary }]}>
              Quick Tips:
            </Text>
            <Text style={[styles.tipsText, { color: theme.colors.text.tertiary }]}>
              • All required fields must be filled
              • Check for typos in location names
              • Ensure times are reasonable
            </Text>
          </View>
        )}
      </LinearGradient>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginVertical: spacing[2],
  },
  feedback: {
    borderWidth: 1,
    borderRadius: borderRadius.lg,
    padding: spacing[4],
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: spacing[3],
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  headerText: {
    fontSize: 16,
    fontWeight: '700',
    marginLeft: spacing[2],
    marginRight: spacing[2],
  },
  badge: {
    paddingHorizontal: spacing[2],
    paddingVertical: 2,
    borderRadius: 12,
    minWidth: 24,
    alignItems: 'center',
  },
  badgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '700',
  },
  dismissButton: {
    padding: spacing[1],
  },
  content: {
    marginBottom: spacing[2],
  },
  messageGroup: {
    marginBottom: spacing[2],
  },
  messageItem: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: spacing[2],
  },
  messageIcon: {
    marginRight: spacing[2],
    marginTop: 2,
  },
  messageText: {
    fontSize: 14,
    fontWeight: '500',
    flex: 1,
    lineHeight: 20,
  },
  tips: {
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
    paddingTop: spacing[3],
  },
  tipsTitle: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: spacing[1],
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  tipsText: {
    fontSize: 12,
    lineHeight: 16,
  },
});
</file>

<file path="src/components/VisitCard.tsx">
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Dimensions,
  Animated,
  Easing,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { Visit, TimelineAction, ParkType } from '../types/models';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { TimelineAction as TimelineActionComponent } from './TimelineAction';

const { width } = Dimensions.get('window');

interface VisitCardProps {
  visit: Visit;
  actions: TimelineAction[];
  isExpanded?: boolean;
  onToggleExpand: () => void;
  onReorderActions: (actionIds: string[]) => void;
  onActionPress: (action: TimelineAction) => void;
  onAddAction: () => void;
}

export const VisitCard: React.FC<VisitCardProps> = ({
  visit,
  actions,
  isExpanded = false,
  onToggleExpand,
  onReorderActions,
  onActionPress,
  onAddAction,
}) => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';
  const [expandAnimation] = useState(new Animated.Value(isExpanded ? 1 : 0));

  // Animate expansion
  React.useEffect(() => {
    Animated.timing(expandAnimation, {
      toValue: isExpanded ? 1 : 0,
      duration: 300,
      easing: Easing.bezier(0.4, 0.0, 0.2, 1),
      useNativeDriver: false,
    }).start();
  }, [isExpanded, expandAnimation]);

  const animatedHeight = expandAnimation.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 300], // Adjust based on content
    extrapolate: 'clamp',
  });

  const rotateIcon = expandAnimation.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '180deg'],
  });

  const formatDate = (date: Date) => {
    return new Intl.DateTimeFormat('ja-JP', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      weekday: 'short',
    }).format(new Date(date));
  };

  const formatTime = (date: Date) => {
    return new Intl.DateTimeFormat('ja-JP', {
      hour: '2-digit',
      minute: '2-digit',
    }).format(new Date(date));
  };

  const getParkIcon = () => {
    return visit.parkType === ParkType.LAND ? 'castle' : 'boat';
  };

  const getParkColor = () => {
    return visit.parkType === ParkType.LAND ? colors.purple[500] : colors.blue[500];
  };

  const getVisitDuration = () => {
    if (visit.startTime && visit.endTime) {
      const duration = new Date(visit.endTime).getTime() - new Date(visit.startTime).getTime();
      const hours = Math.floor(duration / (1000 * 60 * 60));
      const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
      return `${hours}h ${minutes}m`;
    }
    return null;
  };

  const getProgressPercentage = () => {
    if (!visit.startTime || !visit.endTime) return 0;
    const totalDuration = new Date(visit.endTime).getTime() - new Date(visit.startTime).getTime();
    const currentTime = new Date().getTime();
    const elapsed = currentTime - new Date(visit.startTime).getTime();
    return Math.min(Math.max(elapsed / totalDuration, 0), 1) * 100;
  };

  return (
    <View style={[styles.container, { marginBottom: spacing[4] }]}>
      {/* Glass morphism card */}
      <BlurView
        intensity={isDark ? 20 : 80}
        style={[
          styles.card,
          {
            backgroundColor: isDark 
              ? 'rgba(255, 255, 255, 0.05)' 
              : 'rgba(255, 255, 255, 0.3)',
          },
        ]}
      >
        <LinearGradient
          colors={
            visit.parkType === ParkType.LAND
              ? ['rgba(168, 85, 247, 0.1)', 'rgba(147, 51, 234, 0.05)']
              : ['rgba(59, 130, 246, 0.1)', 'rgba(37, 99, 235, 0.05)']
          }
          style={styles.gradientOverlay}
        >
          {/* Card Header */}
          <TouchableOpacity
            style={styles.header}
            onPress={onToggleExpand}
            activeOpacity={0.7}
          >
            <View style={styles.headerLeft}>
              <View
                style={[
                  styles.parkIcon,
                  { backgroundColor: `${getParkColor()}20` },
                ]}
              >
                <Ionicons
                  name={getParkIcon() as any}
                  size={24}
                  color={getParkColor()}
                />
              </View>
              <View style={styles.headerInfo}>
                <Text
                  style={[
                    styles.dateText,
                    { color: theme.colors.text.primary },
                  ]}
                >
                  {formatDate(visit.date)}
                </Text>
                <View style={styles.metaRow}>
                  <Text
                    style={[
                      styles.parkText,
                      { color: getParkColor() },
                    ]}
                  >
                    {visit.parkType === ParkType.LAND ? 'Disneyland' : 'DisneySea'}
                  </Text>
                  {visit.startTime && visit.endTime && (
                    <>
                      <Text style={[styles.separator, { color: theme.colors.text.tertiary }]}>
                        •
                      </Text>
                      <Text
                        style={[
                          styles.timeText,
                          { color: theme.colors.text.secondary },
                        ]}
                      >
                        {formatTime(visit.startTime)} - {formatTime(visit.endTime)}
                      </Text>
                    </>
                  )}
                </View>
              </View>
            </View>

            <View style={styles.headerRight}>
              <View style={styles.statsContainer}>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.colors.text.primary }]}>
                    {actions.length}
                  </Text>
                  <Text style={[styles.statLabel, { color: theme.colors.text.secondary }]}>
                    actions
                  </Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.colors.text.primary }]}>
                    {actions.reduce((sum, action) => sum + action.photos.length, 0)}
                  </Text>
                  <Text style={[styles.statLabel, { color: theme.colors.text.secondary }]}>
                    photos
                  </Text>
                </View>
              </View>
              <Animated.View style={{ transform: [{ rotate: rotateIcon }] }}>
                <Ionicons
                  name="chevron-down"
                  size={20}
                  color={theme.colors.text.tertiary}
                />
              </Animated.View>
            </View>
          </TouchableOpacity>

          {/* Progress Bar */}
          {getVisitDuration() && (
            <View style={styles.progressContainer}>
              <View
                style={[
                  styles.progressBar,
                  { backgroundColor: `${getParkColor()}20` },
                ]}
              >
                <View
                  style={[
                    styles.progressFill,
                    {
                      backgroundColor: getParkColor(),
                      width: `${getProgressPercentage()}%`,
                    },
                  ]}
                />
              </View>
              <Text style={[styles.durationText, { color: theme.colors.text.secondary }]}>
                {getVisitDuration()}
              </Text>
            </View>
          )}

          {/* Expandable Content */}
          <Animated.View
            style={[
              styles.expandableContent,
              {
                height: animatedHeight,
                opacity: expandAnimation,
              },
            ]}
          >
            <View style={styles.actionsContainer}>
              <View style={styles.actionsHeader}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  Timeline
                </Text>
                <TouchableOpacity
                  style={[
                    styles.addButton,
                    { backgroundColor: `${getParkColor()}20` },
                  ]}
                  onPress={onAddAction}
                >
                  <Ionicons name="add" size={20} color={getParkColor()} />
                </TouchableOpacity>
              </View>

              {actions.length > 0 ? (
                <View style={styles.timelineContainer}>
                  {actions.map((action, index) => (
                    <TimelineActionComponent
                      key={action.id}
                      action={action}
                      isLast={index === actions.length - 1}
                      onPress={() => onActionPress(action)}
                      onLongPress={() => {}}
                      isDragActive={false}
                    />
                  ))}
                </View>
              ) : (
                <View style={styles.emptyState}>
                  <Ionicons
                    name="calendar-outline"
                    size={32}
                    color={theme.colors.text.tertiary}
                  />
                  <Text style={[styles.emptyText, { color: theme.colors.text.secondary }]}>
                    No timeline actions yet
                  </Text>
                  <Text style={[styles.emptySubtext, { color: theme.colors.text.tertiary }]}>
                    Tap the + button to add your first action
                  </Text>
                </View>
              )}
            </View>
          </Animated.View>
        </LinearGradient>
      </BlurView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: spacing[5],
  },
  card: {
    borderRadius: borderRadius['2xl'],
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  gradientOverlay: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: spacing[5],
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  parkIcon: {
    width: 48,
    height: 48,
    borderRadius: borderRadius.xl,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: spacing[4],
  },
  headerInfo: {
    flex: 1,
  },
  dateText: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: spacing[1],
  },
  metaRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  parkText: {
    fontSize: 14,
    fontWeight: '500',
  },
  separator: {
    fontSize: 14,
    marginHorizontal: spacing[2],
  },
  timeText: {
    fontSize: 14,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statsContainer: {
    flexDirection: 'row',
    marginRight: spacing[3],
  },
  statItem: {
    alignItems: 'center',
    marginLeft: spacing[3],
  },
  statNumber: {
    fontSize: 16,
    fontWeight: '700',
  },
  statLabel: {
    fontSize: 10,
    textTransform: 'uppercase',
    marginTop: 2,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[5],
    paddingBottom: spacing[3],
  },
  progressBar: {
    flex: 1,
    height: 4,
    borderRadius: 2,
    marginRight: spacing[3],
  },
  progressFill: {
    height: '100%',
    borderRadius: 2,
  },
  durationText: {
    fontSize: 12,
    fontWeight: '500',
  },
  expandableContent: {
    overflow: 'hidden',
  },
  actionsContainer: {
    padding: spacing[5],
    paddingTop: 0,
  },
  actionsHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: spacing[4],
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  addButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  timelineContainer: {
    flex: 1,
  },
  emptyState: {
    alignItems: 'center',
    paddingVertical: spacing[8],
  },
  emptyText: {
    fontSize: 16,
    fontWeight: '500',
    marginTop: spacing[2],
  },
  emptySubtext: {
    fontSize: 14,
    textAlign: 'center',
    marginTop: spacing[1],
  },
});
</file>

<file path="src/components/VisitFilter.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Easing,
  Modal,
  ScrollView,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
// import DateTimePicker from '@react-native-community/datetimepicker'; // Removed dependency
import { VisitFilter as VisitFilterType, ParkType, Companion } from '../types/models';
import { useTheme } from '../contexts/ThemeContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';

interface VisitFilterProps {
  filter?: VisitFilterType;
  companions?: Companion[];
  onFilterChange?: (filter: VisitFilterType) => void;
}

export const VisitFilter: React.FC<VisitFilterProps> = (props) => {
  const {
    filter = {},
    companions = [],
    onFilterChange = () => {},
  } = props || {};
  
  // Safely use theme with fallback
  let theme, isDark;
  try {
    const themeContext = useTheme();
    theme = themeContext?.theme || { mode: 'light', colors: { text: { primary: '#000' } } };
    isDark = theme.mode === 'dark';
  } catch (error) {
    console.warn('Theme context not available, using defaults');
    theme = { mode: 'light', colors: { text: { primary: '#000' } } };
    isDark = false;
  }
  const [isExpanded, setIsExpanded] = useState(false);
  const [showStartDatePicker, setShowStartDatePicker] = useState(false);
  const [showEndDatePicker, setShowEndDatePicker] = useState(false);
  const expandAnimation = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    Animated.timing(expandAnimation, {
      toValue: isExpanded ? 1 : 0,
      duration: 300,
      easing: Easing.bezier(0.4, 0.0, 0.2, 1),
      useNativeDriver: false,
    }).start();
  }, [isExpanded, expandAnimation]);

  const animatedHeight = expandAnimation.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 400],
    extrapolate: 'clamp',
  });

  const rotateIcon = expandAnimation.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '180deg'],
  });

  const formatDate = (date?: Date) => {
    if (!date) return 'Select Date';
    return new Intl.DateTimeFormat('ja-JP', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    }).format(date);
  };

  const getActiveFiltersCount = () => {
    let count = 0;
    if (filter.parkType) count++;
    if (filter.dateRange) count++;
    if (filter.companionIds?.length) count++;
    return count;
  };

  const clearAllFilters = () => {
    onFilterChange({});
  };

  const toggleParkType = (parkType: ParkType) => {
    onFilterChange({
      ...filter,
      parkType: filter.parkType === parkType ? undefined : parkType,
    });
  };

  const setDateRange = (startDate?: Date, endDate?: Date) => {
    if (startDate && endDate) {
      onFilterChange({
        ...filter,
        dateRange: { startDate, endDate },
      });
    } else {
      const currentRange = filter.dateRange;
      onFilterChange({
        ...filter,
        dateRange: {
          startDate: startDate || currentRange?.startDate || new Date(),
          endDate: endDate || currentRange?.endDate || new Date(),
        },
      });
    }
  };

  const clearDateRange = () => {
    onFilterChange({
      ...filter,
      dateRange: undefined,
    });
  };

  const toggleCompanion = (companionId: string) => {
    const currentIds = filter.companionIds || [];
    const newIds = currentIds.includes(companionId)
      ? currentIds.filter(id => id !== companionId)
      : [...currentIds, companionId];
    
    onFilterChange({
      ...filter,
      companionIds: newIds.length > 0 ? newIds : undefined,
    });
  };

  const getSelectedCompanionsText = () => {
    if (!filter.companionIds?.length) return 'All companions';
    if (filter.companionIds.length === 1) {
      const companion = companions.find(c => c.id === filter.companionIds![0]);
      return companion?.name || 'Unknown';
    }
    return `${filter.companionIds.length} companions`;
  };

  return (
    <View style={styles.container}>
      {/* Filter Toggle Button */}
      <TouchableOpacity
        style={[
          styles.toggleButton,
          {
            backgroundColor: isDark
              ? theme.colors.background.secondary
              : theme.colors.background.elevated,
          },
        ]}
        onPress={() => setIsExpanded(!isExpanded)}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={['rgba(168, 85, 247, 0.1)', 'rgba(147, 51, 234, 0.05)']}
          style={styles.toggleGradient}
        >
          <View style={styles.toggleLeft}>
            <Ionicons
              name="funnel"
              size={20}
              color={colors.purple[500]}
            />
            <Text style={[styles.toggleText, { color: theme.colors.text.primary }]}>
              Filters
            </Text>
            {getActiveFiltersCount() > 0 && (
              <View style={[styles.badge, { backgroundColor: colors.purple[500] }]}>
                <Text style={styles.badgeText}>{getActiveFiltersCount()}</Text>
              </View>
            )}
          </View>
          
          <View style={styles.toggleRight}>
            {getActiveFiltersCount() > 0 && (
              <TouchableOpacity
                onPress={(e) => {
                  e.stopPropagation();
                  clearAllFilters();
                }}
                style={styles.clearButton}
              >
                <Ionicons name="close-circle" size={20} color={theme.colors.text.tertiary} />
              </TouchableOpacity>
            )}
            <Animated.View style={{ transform: [{ rotate: rotateIcon }] }}>
              <Ionicons
                name="chevron-down"
                size={20}
                color={theme.colors.text.secondary}
              />
            </Animated.View>
          </View>
        </LinearGradient>
      </TouchableOpacity>

      {/* Expandable Filter Content */}
      <Animated.View
        style={[
          styles.expandableContent,
          {
            height: animatedHeight,
            opacity: expandAnimation,
          },
        ]}
      >
        <BlurView
          intensity={isDark ? 20 : 80}
          style={[
            styles.filterPanel,
            {
              backgroundColor: isDark
                ? 'rgba(255, 255, 255, 0.05)'
                : 'rgba(255, 255, 255, 0.3)',
            },
          ]}
        >
          <ScrollView showsVerticalScrollIndicator={false}>
            {/* Park Type Filter */}
            <View style={styles.filterSection}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                Park
              </Text>
              <View style={styles.parkTypeContainer}>
                <TouchableOpacity
                  style={[
                    styles.parkTypeButton,
                    {
                      backgroundColor: filter.parkType === ParkType.LAND
                        ? colors.purple[500]
                        : theme.colors.background.elevated,
                      borderColor: filter.parkType === ParkType.LAND
                        ? colors.purple[500]
                        : theme.colors.border,
                    },
                  ]}
                  onPress={() => toggleParkType(ParkType.LAND)}
                >
                  <Ionicons
                    name="castle"
                    size={20}
                    color={filter.parkType === ParkType.LAND ? 'white' : colors.purple[500]}
                  />
                  <Text
                    style={[
                      styles.parkTypeText,
                      {
                        color: filter.parkType === ParkType.LAND
                          ? 'white'
                          : theme.colors.text.primary,
                      },
                    ]}
                  >
                    Disneyland
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.parkTypeButton,
                    {
                      backgroundColor: filter.parkType === ParkType.SEA
                        ? colors.blue[500]
                        : theme.colors.background.elevated,
                      borderColor: filter.parkType === ParkType.SEA
                        ? colors.blue[500]
                        : theme.colors.border,
                    },
                  ]}
                  onPress={() => toggleParkType(ParkType.SEA)}
                >
                  <Ionicons
                    name="boat"
                    size={20}
                    color={filter.parkType === ParkType.SEA ? 'white' : colors.blue[500]}
                  />
                  <Text
                    style={[
                      styles.parkTypeText,
                      {
                        color: filter.parkType === ParkType.SEA
                          ? 'white'
                          : theme.colors.text.primary,
                      },
                    ]}
                  >
                    DisneySea
                  </Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* Date Range Filter */}
            <View style={styles.filterSection}>
              <View style={styles.sectionHeader}>
                <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                  Date Range
                </Text>
                {filter.dateRange && (
                  <TouchableOpacity onPress={clearDateRange} style={styles.clearSectionButton}>
                    <Text style={[styles.clearSectionText, { color: colors.purple[500] }]}>
                      Clear
                    </Text>
                  </TouchableOpacity>
                )}
              </View>

              <View style={styles.dateRangeContainer}>
                <TouchableOpacity
                  style={[
                    styles.dateButton,
                    {
                      backgroundColor: theme.colors.background.elevated,
                      borderColor: theme.colors.border,
                    },
                  ]}
                  onPress={() => setShowStartDatePicker(true)}
                >
                  <Ionicons
                    name="calendar-outline"
                    size={16}
                    color={theme.colors.text.secondary}
                  />
                  <Text style={[styles.dateText, { color: theme.colors.text.primary }]}>
                    {formatDate(filter.dateRange?.startDate)}
                  </Text>
                </TouchableOpacity>

                <View style={styles.dateSeparator}>
                  <Text style={[styles.separatorText, { color: theme.colors.text.tertiary }]}>
                    to
                  </Text>
                </View>

                <TouchableOpacity
                  style={[
                    styles.dateButton,
                    {
                      backgroundColor: theme.colors.background.elevated,
                      borderColor: theme.colors.border,
                    },
                  ]}
                  onPress={() => setShowEndDatePicker(true)}
                >
                  <Ionicons
                    name="calendar-outline"
                    size={16}
                    color={theme.colors.text.secondary}
                  />
                  <Text style={[styles.dateText, { color: theme.colors.text.primary }]}>
                    {formatDate(filter.dateRange?.endDate)}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* Companions Filter */}
            <View style={styles.filterSection}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                Companions
              </Text>
              <Text style={[styles.sectionSubtitle, { color: theme.colors.text.secondary }]}>
                {getSelectedCompanionsText()}
              </Text>
              
              <View style={styles.companionsContainer}>
                {companions.map(companion => (
                  <TouchableOpacity
                    key={companion.id}
                    style={[
                      styles.companionChip,
                      {
                        backgroundColor: filter.companionIds?.includes(companion.id)
                          ? colors.purple[500]
                          : theme.colors.background.elevated,
                        borderColor: filter.companionIds?.includes(companion.id)
                          ? colors.purple[500]
                          : theme.colors.border,
                      },
                    ]}
                    onPress={() => toggleCompanion(companion.id)}
                  >
                    <Text
                      style={[
                        styles.companionText,
                        {
                          color: filter.companionIds?.includes(companion.id)
                            ? 'white'
                            : theme.colors.text.primary,
                        },
                      ]}
                    >
                      {companion.name}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
          </ScrollView>
        </BlurView>
      </Animated.View>

      {/* Date Pickers - Functionality disabled due to removed dependency */}
      {showStartDatePicker && (
        <Modal transparent visible={showStartDatePicker}>
          <View style={styles.datePickerModal}>
            <View style={[styles.datePickerContent, { backgroundColor: theme.colors.background.elevated }]}>
              <Text style={[styles.datePickerText, { color: theme.colors.text.primary }]}>
                Date picker functionality is unavailable
              </Text>
              <TouchableOpacity
                style={[styles.datePickerButton, { backgroundColor: colors.purple[500] }]}
                onPress={() => setShowStartDatePicker(false)}
              >
                <Text style={styles.datePickerButtonText}>Close</Text>
              </TouchableOpacity>
            </View>
          </View>
        </Modal>
      )}

      {showEndDatePicker && (
        <Modal transparent visible={showEndDatePicker}>
          <View style={styles.datePickerModal}>
            <View style={[styles.datePickerContent, { backgroundColor: theme.colors.background.elevated }]}>
              <Text style={[styles.datePickerText, { color: theme.colors.text.primary }]}>
                Date picker functionality is unavailable
              </Text>
              <TouchableOpacity
                style={[styles.datePickerButton, { backgroundColor: colors.purple[500] }]}
                onPress={() => setShowEndDatePicker(false)}
              >
                <Text style={styles.datePickerButtonText}>Close</Text>
              </TouchableOpacity>
            </View>
          </View>
        </Modal>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: spacing[4],
  },
  toggleButton: {
    marginHorizontal: spacing[5],
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  toggleGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: spacing[4],
  },
  toggleLeft: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  toggleText: {
    fontSize: 16,
    fontWeight: '600',
    marginLeft: spacing[2],
  },
  badge: {
    width: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: spacing[2],
  },
  badgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  toggleRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  clearButton: {
    marginRight: spacing[2],
  },
  expandableContent: {
    overflow: 'hidden',
    marginTop: spacing[2],
  },
  filterPanel: {
    marginHorizontal: spacing[5],
    borderRadius: borderRadius.xl,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    overflow: 'hidden',
  },
  filterSection: {
    padding: spacing[4],
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[3],
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  sectionSubtitle: {
    fontSize: 14,
    marginTop: spacing[1],
    marginBottom: spacing[3],
  },
  clearSectionButton: {
    padding: spacing[1],
  },
  clearSectionText: {
    fontSize: 14,
    fontWeight: '500',
  },
  parkTypeContainer: {
    flexDirection: 'row',
    gap: spacing[3],
  },
  parkTypeButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: spacing[3],
    borderRadius: borderRadius.lg,
    borderWidth: 1,
  },
  parkTypeText: {
    fontSize: 14,
    fontWeight: '500',
    marginLeft: spacing[2],
  },
  dateRangeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  dateButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: spacing[3],
    borderRadius: borderRadius.lg,
    borderWidth: 1,
  },
  dateText: {
    fontSize: 14,
    marginLeft: spacing[2],
  },
  dateSeparator: {
    paddingHorizontal: spacing[3],
  },
  separatorText: {
    fontSize: 14,
  },
  companionsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing[2],
  },
  companionChip: {
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.lg,
    borderWidth: 1,
  },
  companionText: {
    fontSize: 14,
    fontWeight: '500',
  },
  datePickerModal: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  datePickerContent: {
    padding: spacing[4],
    borderRadius: borderRadius.lg,
    margin: spacing[4],
    alignItems: 'center',
  },
  datePickerText: {
    fontSize: 16,
    marginBottom: spacing[4],
  },
  datePickerButton: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.lg,
  },
  datePickerButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});
</file>

<file path="src/constants/icons.ts">
/**
 * Icon mappings for Tokyo Disney Resort categories, areas, and specific locations
 * Uses Expo Vector Icons (@expo/vector-icons)
 */

import { 
  ActionCategory, 
  ParkType, 
  LandArea, 
  SeaArea 
} from '../types/models';

// Icon library types for Expo Vector Icons
export type IconLibrary = 
  | 'AntDesign'
  | 'Entypo' 
  | 'EvilIcons'
  | 'Feather'
  | 'FontAwesome'
  | 'FontAwesome5'
  | 'Foundation'
  | 'Ionicons'
  | 'MaterialCommunityIcons'
  | 'MaterialIcons'
  | 'Octicons'
  | 'SimpleLineIcons'
  | 'Zocial';

export interface IconConfig {
  library: IconLibrary;
  name: string;
  color?: string;
  size?: number;
}

// Park Type Icons
export const PARK_TYPE_ICONS: Record<ParkType, IconConfig> = {
  [ParkType.LAND]: {
    library: 'FontAwesome5',
    name: 'fort-awesome',
    color: '#FF6B9D',
  },
  [ParkType.SEA]: {
    library: 'FontAwesome5',
    name: 'globe',
    color: '#4FC3F7',
  },
};

// Action Category Icons
export const ACTION_CATEGORY_ICONS: Record<ActionCategory, IconConfig> = {
  [ActionCategory.ATTRACTION]: {
    library: 'MaterialCommunityIcons',
    name: 'ferris-wheel',
    color: '#FF5722',
  },
  [ActionCategory.RESTAURANT]: {
    library: 'MaterialCommunityIcons',
    name: 'silverware-fork-knife',
    color: '#4CAF50',
  },
  [ActionCategory.SHOW]: {
    library: 'MaterialCommunityIcons',
    name: 'theater',
    color: '#9C27B0',
  },
  [ActionCategory.GREETING]: {
    library: 'MaterialCommunityIcons',
    name: 'hand-wave',
    color: '#FF9800',
  },
  [ActionCategory.SHOPPING]: {
    library: 'MaterialCommunityIcons',
    name: 'shopping',
    color: '#E91E63',
  },
};

// Tokyo Disneyland Area Icons
export const LAND_AREA_ICONS: Record<LandArea, IconConfig> = {
  [LandArea.WORLD_BAZAAR]: {
    library: 'MaterialCommunityIcons',
    name: 'store',
    color: '#8E24AA',
  },
  [LandArea.ADVENTURELAND]: {
    library: 'MaterialCommunityIcons',
    name: 'palm-tree',
    color: '#2E7D32',
  },
  [LandArea.WESTERNLAND]: {
    library: 'MaterialCommunityIcons',
    name: 'hat-fedora',
    color: '#8D6E63',
  },
  [LandArea.CRITTER_COUNTRY]: {
    library: 'MaterialCommunityIcons',
    name: 'pine-tree',
    color: '#388E3C',
  },
  [LandArea.FANTASYLAND]: {
    library: 'MaterialCommunityIcons',
    name: 'castle',
    color: '#E91E63',
  },
  [LandArea.TOONTOWN]: {
    library: 'MaterialCommunityIcons',
    name: 'home-city',
    color: '#FF9800',
  },
  [LandArea.TOMORROWLAND]: {
    library: 'MaterialCommunityIcons',
    name: 'rocket',
    color: '#3F51B5',
  },
};

// Tokyo DisneySea Area Icons
export const SEA_AREA_ICONS: Record<SeaArea, IconConfig> = {
  [SeaArea.MEDITERRANEAN_HARBOR]: {
    library: 'MaterialCommunityIcons',
    name: 'lighthouse',
    color: '#1976D2',
  },
  [SeaArea.AMERICAN_WATERFRONT]: {
    library: 'MaterialCommunityIcons',
    name: 'city',
    color: '#F57C00',
  },
  [SeaArea.PORT_DISCOVERY]: {
    library: 'MaterialCommunityIcons',
    name: 'submarine',
    color: '#00BCD4',
  },
  [SeaArea.LOST_RIVER_DELTA]: {
    library: 'MaterialCommunityIcons',
    name: 'temple-hindu',
    color: '#8BC34A',
  },
  [SeaArea.ARABIAN_COAST]: {
    library: 'MaterialCommunityIcons',
    name: 'dome-light',
    color: '#FF9800',
  },
  [SeaArea.MERMAID_LAGOON]: {
    library: 'MaterialCommunityIcons',
    name: 'waves',
    color: '#4FC3F7',
  },
  [SeaArea.MYSTERIOUS_ISLAND]: {
    library: 'MaterialCommunityIcons',
    name: 'volcano',
    color: '#F44336',
  },
  [SeaArea.FANTASY_SPRINGS]: {
    library: 'MaterialCommunityIcons',
    name: 'snowflake',
    color: '#9C27B0',
  },
};

// Specific Attraction Type Icons
export const ATTRACTION_TYPE_ICONS: Record<string, IconConfig> = {
  // Ride types
  'roller coaster': {
    library: 'MaterialCommunityIcons',
    name: 'roller-coaster',
    color: '#F44336',
  },
  'dark ride': {
    library: 'MaterialCommunityIcons',
    name: 'train-car',
    color: '#673AB7',
  },
  'boat ride': {
    library: 'MaterialCommunityIcons',
    name: 'sail-boat',
    color: '#2196F3',
  },
  'flying': {
    library: 'MaterialCommunityIcons',
    name: 'airplane',
    color: '#03DAC6',
  },
  'spinning': {
    library: 'MaterialCommunityIcons',
    name: 'loading',
    color: '#FF9800',
  },
  'simulator': {
    library: 'MaterialCommunityIcons',
    name: 'monitor',
    color: '#9C27B0',
  },
  'water ride': {
    library: 'MaterialCommunityIcons',
    name: 'water',
    color: '#2196F3',
  },
  'thrill': {
    library: 'MaterialCommunityIcons',
    name: 'flash',
    color: '#FF5722',
  },
  'family': {
    library: 'MaterialCommunityIcons',
    name: 'account-group',
    color: '#4CAF50',
  },
  'gentle': {
    library: 'MaterialCommunityIcons',
    name: 'heart',
    color: '#E91E63',
  },
  
  // Show types
  'theater show': {
    library: 'MaterialCommunityIcons',
    name: 'theater',
    color: '#9C27B0',
  },
  'interactive show': {
    library: 'MaterialCommunityIcons',
    name: 'hand-pointing-up',
    color: '#FF9800',
  },
  '3d show': {
    library: 'MaterialCommunityIcons',
    name: 'glasses',
    color: '#3F51B5',
  },
  
  // Interactive types
  'interactive': {
    library: 'MaterialCommunityIcons',
    name: 'hand-point-right',
    color: '#FF9800',
  },
  'shooting': {
    library: 'MaterialCommunityIcons',
    name: 'target',
    color: '#F44336',
  },
  'arcade': {
    library: 'MaterialCommunityIcons',
    name: 'gamepad-variant',
    color: '#9C27B0',
  },
  
  // Transportation
  'transport': {
    library: 'MaterialCommunityIcons',
    name: 'train',
    color: '#607D8B',
  },
  'train': {
    library: 'MaterialCommunityIcons',
    name: 'train',
    color: '#795548',
  },
  'steamer': {
    library: 'MaterialCommunityIcons',
    name: 'ferry',
    color: '#607D8B',
  },
  'raft': {
    library: 'MaterialCommunityIcons',
    name: 'raft',
    color: '#8BC34A',
  },
  
  // Exploration
  'walkthrough': {
    library: 'MaterialCommunityIcons',
    name: 'walk',
    color: '#8BC34A',
  },
  'playground': {
    library: 'MaterialCommunityIcons',
    name: 'playground',
    color: '#FF9800',
  },
  'treehouse': {
    library: 'MaterialCommunityIcons',
    name: 'tree',
    color: '#4CAF50',
  },
};

// Restaurant Type Icons
export const RESTAURANT_TYPE_ICONS: Record<string, IconConfig> = {
  // Service types
  'table service': {
    library: 'MaterialCommunityIcons',
    name: 'silverware-fork-knife',
    color: '#4CAF50',
  },
  'quick service': {
    library: 'MaterialCommunityIcons',
    name: 'fast-forward',
    color: '#FF9800',
  },
  'buffet': {
    library: 'MaterialCommunityIcons',
    name: 'food-variant',
    color: '#2196F3',
  },
  'character dining': {
    library: 'MaterialCommunityIcons',
    name: 'face-agent',
    color: '#E91E63',
  },
  'show dining': {
    library: 'MaterialCommunityIcons',
    name: 'theater',
    color: '#9C27B0',
  },
  
  // Cuisine types
  'american': {
    library: 'MaterialCommunityIcons',
    name: 'hamburger',
    color: '#F44336',
  },
  'italian': {
    library: 'MaterialCommunityIcons',
    name: 'pasta',
    color: '#4CAF50',
  },
  'chinese': {
    library: 'MaterialCommunityIcons',
    name: 'noodles',
    color: '#FF9800',
  },
  'japanese': {
    library: 'MaterialCommunityIcons',
    name: 'rice',
    color: '#795548',
  },
  'french': {
    library: 'MaterialCommunityIcons',
    name: 'baguette',
    color: '#3F51B5',
  },
  'mexican': {
    library: 'MaterialCommunityIcons',
    name: 'chili-hot',
    color: '#FF5722',
  },
  'middle eastern': {
    library: 'MaterialCommunityIcons',
    name: 'food-drumstick',
    color: '#FF9800',
  },
  'mediterranean': {
    library: 'MaterialCommunityIcons',
    name: 'fish',
    color: '#2196F3',
  },
  'polynesian': {
    library: 'MaterialCommunityIcons',
    name: 'palm-tree',
    color: '#4CAF50',
  },
  'creole': {
    library: 'MaterialCommunityIcons',
    name: 'pot-steam',
    color: '#8BC34A',
  },
  
  // Food types
  'pizza': {
    library: 'MaterialCommunityIcons',
    name: 'pizza',
    color: '#FF5722',
  },
  'hamburgers': {
    library: 'MaterialCommunityIcons',
    name: 'hamburger',
    color: '#F44336',
  },
  'pasta': {
    library: 'MaterialCommunityIcons',
    name: 'pasta',
    color: '#4CAF50',
  },
  'curry': {
    library: 'MaterialCommunityIcons',
    name: 'bowl-mix',
    color: '#FF9800',
  },
  'ramen': {
    library: 'MaterialCommunityIcons',
    name: 'noodles',
    color: '#795548',
  },
  'hot dogs': {
    library: 'MaterialCommunityIcons',
    name: 'hot-dog',
    color: '#F44336',
  },
  'coffee': {
    library: 'MaterialCommunityIcons',
    name: 'coffee',
    color: '#795548',
  },
  'dessert': {
    library: 'MaterialCommunityIcons',
    name: 'cupcake',
    color: '#E91E63',
  },
  'sweets': {
    library: 'MaterialCommunityIcons',
    name: 'candy',
    color: '#E91E63',
  },
  'snacks': {
    library: 'MaterialCommunityIcons',
    name: 'food-apple',
    color: '#FF9800',
  },
  'popcorn': {
    library: 'MaterialCommunityIcons',
    name: 'popcorn',
    color: '#FFEB3B',
  },
};

// Shopping Type Icons
export const SHOPPING_TYPE_ICONS: Record<string, IconConfig> = {
  // Store types
  'souvenirs': {
    library: 'MaterialCommunityIcons',
    name: 'gift',
    color: '#E91E63',
  },
  'clothing': {
    library: 'MaterialCommunityIcons',
    name: 'tshirt-crew',
    color: '#9C27B0',
  },
  'accessories': {
    library: 'MaterialCommunityIcons',
    name: 'watch',
    color: '#FF9800',
  },
  'toys': {
    library: 'MaterialCommunityIcons',
    name: 'teddy-bear',
    color: '#2196F3',
  },
  'plush': {
    library: 'MaterialCommunityIcons',
    name: 'teddy-bear',
    color: '#E91E63',
  },
  'candy': {
    library: 'MaterialCommunityIcons',
    name: 'candy',
    color: '#F44336',
  },
  'confectionery': {
    library: 'MaterialCommunityIcons',
    name: 'cake',
    color: '#E91E63',
  },
  'stationery': {
    library: 'MaterialCommunityIcons',
    name: 'pen',
    color: '#3F51B5',
  },
  'books': {
    library: 'MaterialCommunityIcons',
    name: 'book-open',
    color: '#795548',
  },
  'home goods': {
    library: 'MaterialCommunityIcons',
    name: 'home',
    color: '#4CAF50',
  },
  'kitchen': {
    library: 'MaterialCommunityIcons',
    name: 'pot',
    color: '#607D8B',
  },
  'perfume': {
    library: 'MaterialCommunityIcons',
    name: 'spray-bottle',
    color: '#E91E63',
  },
  'cosmetics': {
    library: 'MaterialCommunityIcons',
    name: 'lipstick',
    color: '#E91E63',
  },
  'fashion': {
    library: 'MaterialCommunityIcons',
    name: 'hanger',
    color: '#9C27B0',
  },
  
  // Character themed
  'duffy': {
    library: 'MaterialCommunityIcons',
    name: 'teddy-bear',
    color: '#8D6E63',
  },
  'department store': {
    library: 'MaterialCommunityIcons',
    name: 'store',
    color: '#2196F3',
  },
  'bazaar': {
    library: 'MaterialCommunityIcons',
    name: 'tent',
    color: '#FF9800',
  },
  'marketplace': {
    library: 'MaterialCommunityIcons',
    name: 'storefront',
    color: '#4CAF50',
  },
};

// Character Type Icons for Greetings
export const CHARACTER_TYPE_ICONS: Record<string, IconConfig> = {
  // Main characters
  'mickey': {
    library: 'MaterialCommunityIcons',
    name: 'mouse',
    color: '#000000',
  },
  'minnie': {
    library: 'MaterialCommunityIcons',
    name: 'mouse-variant',
    color: '#E91E63',
  },
  'donald': {
    library: 'MaterialCommunityIcons',
    name: 'duck',
    color: '#2196F3',
  },
  'goofy': {
    library: 'MaterialCommunityIcons',
    name: 'dog',
    color: '#FF9800',
  },
  'chip': {
    library: 'MaterialCommunityIcons',
    name: 'rodent',
    color: '#8BC34A',
  },
  'dale': {
    library: 'MaterialCommunityIcons',
    name: 'rodent',
    color: '#F44336',
  },
  
  // Disney characters
  'princesses': {
    library: 'MaterialCommunityIcons',
    name: 'crown',
    color: '#E91E63',
  },
  'winnie the pooh': {
    library: 'MaterialCommunityIcons',
    name: 'teddy-bear',
    color: '#FFEB3B',
  },
  'stitch': {
    library: 'MaterialCommunityIcons',
    name: 'alien',
    color: '#3F51B5',
  },
  'toy story': {
    library: 'MaterialCommunityIcons',
    name: 'toy-brick',
    color: '#FFEB3B',
  },
  'little mermaid': {
    library: 'MaterialCommunityIcons',
    name: 'waves',
    color: '#4FC3F7',
  },
  'aladdin': {
    library: 'MaterialCommunityIcons',
    name: 'lamp',
    color: '#FF9800',
  },
  'frozen': {
    library: 'MaterialCommunityIcons',
    name: 'snowflake',
    color: '#03DAC6',
  },
  'beauty and the beast': {
    library: 'MaterialCommunityIcons',
    name: 'flower-tulip',
    color: '#FFEB3B',
  },
  'peter pan': {
    library: 'MaterialCommunityIcons',
    name: 'airplane',
    color: '#4CAF50',
  },
  'tangled': {
    library: 'MaterialCommunityIcons',
    name: 'lightbulb',
    color: '#FF9800',
  },
  'alice': {
    library: 'MaterialCommunityIcons',
    name: 'cards',
    color: '#2196F3',
  },
  
  // DisneySea exclusive
  'duffy': {
    library: 'MaterialCommunityIcons',
    name: 'teddy-bear',
    color: '#8D6E63',
  },
  'shelliemay': {
    library: 'MaterialCommunityIcons',
    name: 'teddy-bear',
    color: '#E91E63',
  },
  'gelatoni': {
    library: 'MaterialCommunityIcons',
    name: 'palette',
    color: '#4CAF50',
  },
  'stellalou': {
    library: 'MaterialCommunityIcons',
    name: 'rabbit',
    color: '#9C27B0',
  },
  
  // Groups
  'bears': {
    library: 'MaterialCommunityIcons',
    name: 'teddy-bear',
    color: '#8D6E63',
  },
  'chipmunks': {
    library: 'MaterialCommunityIcons',
    name: 'rodent',
    color: '#FF9800',
  },
  'classic': {
    library: 'MaterialCommunityIcons',
    name: 'star',
    color: '#FFEB3B',
  },
  'main characters': {
    library: 'MaterialCommunityIcons',
    name: 'star-circle',
    color: '#FFEB3B',
  },
};

// Weather Icons
export const WEATHER_ICONS: Record<string, IconConfig> = {
  'SUNNY': {
    library: 'MaterialCommunityIcons',
    name: 'weather-sunny',
    color: '#FFEB3B',
  },
  'CLOUDY': {
    library: 'MaterialCommunityIcons',
    name: 'weather-cloudy',
    color: '#9E9E9E',
  },
  'RAINY': {
    library: 'MaterialCommunityIcons',
    name: 'weather-rainy',
    color: '#2196F3',
  },
  'SNOWY': {
    library: 'MaterialCommunityIcons',
    name: 'weather-snowy',
    color: '#03DAC6',
  },
};

// Time of Day Icons
export const TIME_OF_DAY_ICONS: Record<string, IconConfig> = {
  'morning': {
    library: 'MaterialCommunityIcons',
    name: 'weather-sunset-up',
    color: '#FF9800',
  },
  'afternoon': {
    library: 'MaterialCommunityIcons',
    name: 'weather-sunny',
    color: '#FFEB3B',
  },
  'evening': {
    library: 'MaterialCommunityIcons',
    name: 'weather-sunset-down',
    color: '#FF5722',
  },
  'night': {
    library: 'MaterialCommunityIcons',
    name: 'weather-night',
    color: '#3F51B5',
  },
};

// Rating Icons
export const RATING_ICONS: Record<number, IconConfig> = {
  1: {
    library: 'MaterialCommunityIcons',
    name: 'star',
    color: '#FFC107',
  },
  2: {
    library: 'MaterialCommunityIcons',
    name: 'star',
    color: '#FFC107',
  },
  3: {
    library: 'MaterialCommunityIcons',
    name: 'star',
    color: '#FFC107',
  },
  4: {
    library: 'MaterialCommunityIcons',
    name: 'star',
    color: '#FFC107',
  },
  5: {
    library: 'MaterialCommunityIcons',
    name: 'star',
    color: '#FFC107',
  },
};

// Status Icons
export const STATUS_ICONS = {
  popular: {
    library: 'MaterialCommunityIcons' as const,
    name: 'fire',
    color: '#FF5722',
  },
  new: {
    library: 'MaterialCommunityIcons' as const,
    name: 'new-box',
    color: '#4CAF50',
  },
  fastpass: {
    library: 'MaterialCommunityIcons' as const,
    name: 'clock-fast',
    color: '#2196F3',
  },
  closed: {
    library: 'MaterialCommunityIcons' as const,
    name: 'close-circle',
    color: '#F44336',
  },
  refurbishment: {
    library: 'MaterialCommunityIcons' as const,
    name: 'wrench',
    color: '#FF9800',
  },
};

// Helper function to get icon for a specific item based on its tags
export const getIconForItem = (tags: string[] = [], category: ActionCategory): IconConfig => {
  // Check for specific tag matches first
  for (const tag of tags) {
    if (category === ActionCategory.ATTRACTION && ATTRACTION_TYPE_ICONS[tag]) {
      return ATTRACTION_TYPE_ICONS[tag];
    }
    if (category === ActionCategory.RESTAURANT && RESTAURANT_TYPE_ICONS[tag]) {
      return RESTAURANT_TYPE_ICONS[tag];
    }
    if (category === ActionCategory.SHOPPING && SHOPPING_TYPE_ICONS[tag]) {
      return SHOPPING_TYPE_ICONS[tag];
    }
    if (category === ActionCategory.GREETING && CHARACTER_TYPE_ICONS[tag]) {
      return CHARACTER_TYPE_ICONS[tag];
    }
  }
  
  // Fall back to category icon
  return ACTION_CATEGORY_ICONS[category];
};

// Helper function to get area icon
export const getAreaIcon = (area: LandArea | SeaArea): IconConfig => {
  if (Object.values(LandArea).includes(area as LandArea)) {
    return LAND_AREA_ICONS[area as LandArea];
  }
  return SEA_AREA_ICONS[area as SeaArea];
};

// Helper function to get multiple status icons for an item
export const getStatusIcons = (isPopular?: boolean, isNew?: boolean): IconConfig[] => {
  const icons: IconConfig[] = [];
  
  if (isPopular) {
    icons.push(STATUS_ICONS.popular);
  }
  
  if (isNew) {
    icons.push(STATUS_ICONS.new);
  }
  
  return icons;
};

// Export all icon mappings
export const ALL_ICONS = {
  parkType: PARK_TYPE_ICONS,
  category: ACTION_CATEGORY_ICONS,
  landArea: LAND_AREA_ICONS,
  seaArea: SEA_AREA_ICONS,
  attractionType: ATTRACTION_TYPE_ICONS,
  restaurantType: RESTAURANT_TYPE_ICONS,
  shoppingType: SHOPPING_TYPE_ICONS,
  characterType: CHARACTER_TYPE_ICONS,
  weather: WEATHER_ICONS,
  timeOfDay: TIME_OF_DAY_ICONS,
  rating: RATING_ICONS,
  status: STATUS_ICONS,
};
</file>

<file path="src/constants/index.ts">
export * from './presets';
export * from './icons';
</file>

<file path="src/constants/presets.ts">
export const PRESET_ATTRACTIONS_BY_AREA = {
  land: {
    'ワールドバザール': [
      'オムニバス',
      'ペニーアーケード'
    ],
    'アドベンチャーランド': [
      'ウェスタンリバー鉄道',
      'カリブの海賊',
      'ジャングルクルーズ：ワイルドライフ・エクスペディション',
      'スイスファミリー・ツリーハウス',
      '魅惑のチキルーム：スティッチ・プレゼンツ"アロハ・エ・コモ・マイ！"'
    ],
    'ウエスタンランド': [
      'ウエスタンランド・シューティングギャラリー',
      'カントリーベア・シアター',
      '蒸気船マークトウェイン号',
      'トムソーヤ島いかだ',
      'ビッグサンダー・マウンテン'
    ],
    'クリッターカントリー': [
      'スプラッシュ・マウンテン',
      'ビーバーブラザーズのカヌー探険'
    ],
    'ファンタジーランド': [
      '白雪姫と七人のこびと',
      'ピノキオの冒険旅行',
      'ピーターパン空の旅',
      'プーさんのハニーハント',
      'イッツ・ア・スモールワールド',
      '空飛ぶダンボ',
      'キャッスルカルーセル',
      'シンデレラのフェアリーテイル・ホール',
      'ホーンテッドマンション',
      'アリスのティーパーティー',
      'ミッキーのフィルハーマジック',
      '美女と野獣"魔法のものがたり"'
    ],
    'トゥーンタウン': [
      'ガジェットのゴーコースター',
      'グーフィーのペイント＆プレイハウス',
      'チップとデールのツリーハウス',
      'トゥーンパーク',
      'ドナルドのボート'
    ],
    'トゥモローランド': [
      'スター・ツアーズ：ザ・アドベンチャーズ・コンティニュー',
      'スティッチ・エンカウンター',
      'ベイマックスのハッピーライド',
      'モンスターズ・インク"ライド＆ゴーシーク！"'
    ]
  },
  sea: {
    'メディテレーニアンハーバー': [
      'ソアリン：ファンタスティック・フライト',
      'ディズニーシー・トランジットスチーマーライン',
      'フォートレス・エクスプロレーション',
      'ヴェネツィアン・ゴンドラ'
    ],
    'アメリカンウォーターフロント': [
      'タワー・オブ・テラー',
      'トイ・ストーリー・マニア！',
      'タートル・トーク',
      'ビッグシティ・ヴィークル',
      'ディズニーシー・エレクトリックレールウェイ'
    ],
    'ポートディスカバリー': [
      'アクアトピア',
      'ニモ＆フレンズ・シーライダー',
      'ディズニーシー・エレクトリックレールウェイ'
    ],
    'ロストリバーデルタ': [
      'インディ・ジョーンズ・アドベンチャー：クリスタルスカルの魔宮',
      'レイジングスピリッツ',
      'ディズニーシー・トランジットスチーマーライン'
    ],
    'アラビアンコースト': [
      'シンドバッド・ストーリーブック・ヴォヤッジ',
      'マジックランプシアター',
      'ジャスミンのフライングカーペット',
      'キャラバンカルーセル'
    ],
    'マーメイドラグーン': [
      'フランダーのフライングフィッシュコースター',
      'スカットルのスクーター',
      'ジャンピン・ジェリーフィッシュ',
      'ブローフィッシュ・バルーンレース',
      'ワールプール',
      'アリエルのプレイグラウンド',
      'マーメイドラグーンシアター'
    ],
    'ミステリアスアイランド': [
      '海底2万マイル',
      'センター・オブ・ジ・アース'
    ],
    'ファンタジースプリングス': [
      'ピーターパン空の旅（仮称）',
      'ティンカー・ベルのビジーバギー',
      'アナとエルサのフローズンジャーニー',
      'ラプンツェルのランタンフェスティバル'
    ]
  }
};

export const PRESET_RESTAURANTS_BY_AREA = {
  land: {
    'ワールドバザール': [
      'アイスクリームコーン',
      'イーストサイド・カフェ',
      'グレートアメリカン・ワッフルカンパニー',
      'スウィートハート・カフェ',
      'センターストリート・コーヒーハウス',
      'リフレッシュメントコーナー',
      'れすとらん北齋',
      'クラブ33'
    ],
    'アドベンチャーランド': [
      'カフェ・オーリンズ',
      'クリスタルパレス・レストラン',
      'ザ・ガゼーボ',
      'スキッパーズ・ギャレー',
      'スクウィーザーズ・トロピカル・ジュースバー',
      'チャイナボイジャー',
      'パークサイドワゴン',
      'フレッシュフルーツオアシス',
      'ブルーバイユー・レストラン',
      'ボイラールーム・バイツ',
      'ポリネシアンテラス・レストラン'
    ],
    'ウエスタンランド': [
      'カウボーイ・クックハウス',
      'キャンプ・ウッドチャック・キッチン',
      'ザ・ダイヤモンドホースシュー',
      'ハングリーベア・レストラン',
      'プラザパビリオン・レストラン',
      'ペコスビル・カフェ'
    ],
    'クリッターカントリー': [
      'グランマ・サラのキッチン',
      'ラケッティのラクーンサルーン'
    ],
    'ファンタジーランド': [
      'キャプテンフックス・ギャレー',
      'クイーン・オブ・ハートのバンケットホール',
      'クレオズ',
      'トルバドールタバン',
      'ビレッジペイストリー',
      'マジカルマーケット',
      'ラ・タベルヌ・ド・ガストン',
      'ル・フウズ',
      'ル・プティポッパー'
    ],
    'トゥーンタウン': [
      'ディンギードリンク',
      'トゥーントーン・トリート',
      'トゥーンポップ',
      'ヒューイ・デューイ・ルーイのグッドタイム・カフェ',
      'ポップ・ア・ロット・ポップコーン',
      'ミッキーのトレーラー'
    ],
    'トゥモローランド': [
      'ソフトランディング',
      'トゥモローランド・テラス',
      'パン・ギャラクティック・ピザ・ポート',
      'ビッグポップ',
      'プラズマ・レイズ・ダイナー',
      'ポッピングポッド'
    ]
  },
  sea: {
    'メディテレーニアンハーバー': [
      'カフェ・ポルトフィーノ',
      'ゴンドリエ・スナック',
      'ザンビーニ・ブラザーズ・リストランテ',
      'マゼランズ',
      'マンマ・ビスコッティーズ・ベーカリー'
    ],
    'アメリカンウォーターフロント': [
      'S.S.コロンビア・ダイニングルーム',
      'ケープコッド・クックオフ',
      'ケープコッド・コンフェクション',
      'ドックサイドダイナー',
      'テディ・ルーズヴェルト・ラウンジ',
      'ニューヨーク・デリ',
      'レストラン櫻',
      'レストラン櫻 テラス席',
      'ハドソンリバー・ハーベスト',
      'バーナクル・ビルズ',
      'リバティ・ランディング・ダイナー'
    ],
    'ポートディスカバリー': [
      'シーサイドスナック',
      'ブリーズウェイ・バイツ',
      'ベイサイド・テイクアウト',
      'ホライズンベイ・レストラン'
    ],
    'ロストリバーデルタ': [
      'エクスペディション・イート',
      'トロピック・アルズ',
      'ミゲルズ・エルドラド・キャンティーナ',
      'ユカタン・ベースキャンプ・グリル'
    ],
    'ファンタジースプリングス': [
      'アレンデール・ロイヤルバンケット',
      'オーケンのオーケーフード',
      'スナグリーダックリング',
      'ルックアウト・クックアウト'
    ],
    'アラビアンコースト': [
      'オープンセサミ',
      'カスバ・フードコート',
      'サルタンズ・オアシス'
    ],
    'マーメイドラグーン': [
      'セバスチャンのカリプソキッチン'
    ],
    'ミステリアスアイランド': [
      'ヴォルケイニア・レストラン',
      'ノーチラスギャレー',
      'リフレッシュメント・ステーション'
    ]
  }
};

export const PRESET_SHOPS_BY_AREA = {
  land: {
    'ワールドバザール': [
      'カメラセンター',
      'グランドエンポーリアム',
      'シルエットスタジオ',
      'タウンセンターファッション',
      'ディズニー＆カンパニー',
      'トイ・ステーション',
      'ハウス・オブ・グリーティング',
      'ハリントンズ・ジュエリー＆ウォッチ',
      'ビビディ・バビディ・ブティック',
      'ペイストリーパレス',
      'ホームストア',
      'マジックショップ',
      'ワールドバザール・コンフェクショナリー'
    ],
    'アドベンチャーランド': [
      'アドベンチャーランド・バザール',
      'クリスタルアーツ',
      'ゴールデンガリオン',
      'ジャングルカーニバル',
      'パイレーツ・トレジャー',
      'パーティグラ・ギフト',
      'ラ・プティート・パフュームリー'
    ],
    'ウエスタンランド': [
      'ウエスタンウエア',
      'ウエスタンランド写真館',
      'カントリーベア・バンドワゴン',
      'ゼネラルストア',
      'トレーディングポスト',
      'ハッピーキャンパーサプライ',
      'フロンティア・ウッドクラフト'
    ],
    'クリッターカントリー': [
      'スプラッシュダウン・フォト',
      'フート＆ハラー・ハイドアウト'
    ],
    'ファンタジーランド': [
      'ガラスの靴',
      'キングダム・トレジャー',
      'ストロンボリズ・ワゴン',
      'ハーモニーフェア',
      'ビレッジショップス',
      'プーさんコーナー',
      'ブレイブリトルテイラー・ショップ',
      'プレジャーアイランド・キャンディーズ'
    ],
    'トゥーンタウン': [
      'ギャグファクトリー/ファイブ・アンド・ダイム',
      'トゥーンタウン・デリバリーカンパニー'
    ],
    'トゥモローランド': [
      'コズミック・エンカウンター',
      'スターゲイザーサプライ',
      'トレジャーコメット',
      'モンスターズ・インク・カンパニーストア'
    ]
  },
  sea: {
    'メディテレーニアンハーバー': [
      'イル・ポスティーノ・ステーショナリー',
      'ヴァレンティーナズ・スウィート',
      'ヴィラ・ドナルド・ホームショップ',
      'ヴェネツィアン・カーニバル・マーケット',
      'エンポーリオ',
      'ガッレリーア・ディズニー',
      'スプレンディード',
      'ピッコロメルカート',
      'フィガロズ・クロージアー',
      'フォトグラフィカ',
      'ベッラ・ミンニ・コレクション',
      'マーチャント・オブ・ヴェニス・コンフェクション',
      'ミラマーレ',
      'リメンブランツェ'
    ],
    'アメリカンウォーターフロント': [
      'アーント・ペグズ・ヴィレッジストア',
      'スチームボート・ミッキーズ',
      'スリンキー・ドッグのギフトトロリー',
      'タワー・オブ・テラー・メモラビリア',
      'タワー・オブ・テラー・メモラビリア（カプセルトイ）',
      'ニュージーズ・ノヴェルティ',
      'マクダックス・デパートメントストア'
    ],
    'ポートディスカバリー': [
      'スカイウォッチャー・スーヴェニア',
      'ディスカバリーギフト'
    ],
    'ロストリバーデルタ': [
      'エクスペディション・フォトアーカイヴ',
      'ペドラーズ・アウトポスト',
      'ルックアウト・トレーダー',
      'ロストリバーアウトフィッター'
    ],
    'ファンタジースプリングス': [
      'ファンタジースプリングス・ギフト',
      'スプリングス・トレジャー'
    ],
    'アラビアンコースト': [
      'アグラバーマーケットプレイス',
      'アブーズ・バザール'
    ],
    'マーメイドラグーン': [
      'キス・デ・ガール・ファッション',
      'グロットフォト＆ギフト',
      'シータートル・スーヴェニア',
      'スリーピーホエール・ショップ',
      'マーメイドトレジャー',
      'マーメイドメモリー'
    ],
    'ミステリアスアイランド': [
      'ノーチラスギフト'
    ]
  }
};

export const PRESET_GREETING_BY_AREA = {
  land: {
    'トゥーンタウン': [
      'ミッキーの家とミート・ミッキー',
      'ミニーのスタイルスタジオ'
    ],
    'ウエスタンランド': [
      'ウッドチャック・グリーティングトレイル'
    ]
  },
  sea: {
    'ロストリバーデルタ': [
      'ミッキー＆フレンズ・グリーティングトレイル',
      'サルードス・アミーゴス！グリーティングドック'
    ],
    'アメリカンウォーターフロント': [
      'ヴィレッジ・グリーティングプレイス'
    ],
    'マーメイドラグーン': [
      'アリエルのグリーティンググロット'
    ]
  }
};
</file>

<file path="src/contexts/LanguageContext.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Supported languages
export type Language = 'ja' | 'en';

// Language Context Interface
interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
  t: (key: string, params?: Record<string, string>) => string;
  isLoading: boolean;
}

// Storage key for language preference
const LANGUAGE_STORAGE_KEY = '@tdr_days_language';

// Create the context
const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

// Translation data
const translations = {
  ja: {
    // Common
    'common.loading': '読み込み中...',
    'common.save': '保存',
    'common.cancel': 'キャンセル',
    'common.delete': '削除',
    'common.edit': '編集',
    'common.add': '追加',
    'common.search': '検索',
    'common.filter': 'フィルター',
    'common.settings': '設定',
    'common.back': '戻る',
    'common.next': '次へ',
    'common.previous': '前へ',
    'common.complete': '完了',
    'common.ok': 'OK',
    'common.yes': 'はい',
    'common.no': 'いいえ',

    // Navigation
    'nav.home': 'ホーム',
    'nav.visitList': '来園記録',
    'nav.record': '記録',
    'nav.analytics': '分析',
    'nav.profile': 'プロフィール',

    // Home Screen
    'home.welcome': 'ようこそ',
    'home.appTitle': 'TDR Days',
    'home.tagline': '✨ あなたの魔法のディズニージャーニーが待っています ✨',
    'home.totalVisits': '総来園回数',
    'home.allTime': '通算',
    'home.activities': 'アクティビティ',
    'home.logged': '記録済み',
    'home.disneyland': 'ディズニーランド',
    'home.disneysea': 'ディズニーシー',
    'home.disneylandShort': 'ランド',
    'home.disneyseaShort': 'シー',
    'home.visits': '回',
    'home.chooseAdventure': 'あなたの冒険を選択',
    'home.selectPark': 'パークを選択して魔法の思い出を探索しましょう',
    'home.tokyoDisneyland': '東京ディズニーランド',
    'home.landDescription': '夢が叶う魔法の王国',
    'home.tokyoDisneysea': '東京ディズニーシー',
    'home.seaDescription': '冒険と想像の驚異を発見',
    'home.quickActions': 'クイックアクション',
    'home.newVisit': '新しい来園',
    'home.analytics': '分析',
    'home.photos': '写真',
    'home.favorites': 'お気に入り',
    'home.recentMagic': '最近の魔法',
    'home.startJourney': '魔法の旅を始めましょう',
    'home.firstVisitMessage': '最初のディズニー来園を記録して、忘れられない思い出を作り始めましょう！',
    'home.recordFirstVisit': '最初の来園を記録',
    'home.noVisitsFound': '来園記録が見つかりません',
    'home.adjustFilters': 'フィルターを調整してより多くの来園記録を表示してください',
    'home.addFirstVisit': '最初のディズニー来園を追加してください！',

    // Record Screen
    'record.title': '来園を記録',
    'record.editVisit': '来園記録を編集',
    'record.subtitle': 'あなたのディズニーの一日の魔法を記録',
    'record.complete': '% 完了',
    'record.weather': '天気',
    'record.sunny': '晴れ',
    'record.cloudy': '曇り',
    'record.rainy': '雨',
    'record.snowy': '雪',
    'record.notes': 'メモ',
    'record.notesPlaceholder': '今日の魔法の瞬間、お気に入りのアトラクション、思い出をシェアしてください...',
    'record.saveVisit': '来園を保存',
    'record.savingVisit': '来園を保存中...',
    'record.incompleteForm': 'フォームが未完成です',
    'record.selectDateAndPark': '少なくとも日付とパークを選択してください。',
    'record.success': '成功！',
    'record.successMessage': '来園が正常に記録されました！',
    'record.error': 'エラー',
    'record.errorMessage': '来園の保存に失敗しました。もう一度お試しください。',

    // Analytics Screen
    'analytics.title': '分析ダッシュボード',
    'analytics.subtitle': 'あなたのディズニーパターンを発見',
    'analytics.totalVisits': '総来園回数',
    'analytics.totalActions': '総アクティビティ数',
    'analytics.photosTaken': '撮影写真数',
    'analytics.avgVisitDuration': '平均滞在時間',
    'analytics.allTime': '全期間',
    'analytics.thisPeriod': 'この期間',
    'analytics.perVisit': '来園あたり',
    'analytics.memoriesCaptured': '記録された思い出',
    'analytics.hoursPerVisit': '来園あたりの時間',
    'analytics.monthly': '月別',
    'analytics.yearly': '年別',
    'analytics.custom': 'カスタム',
    'analytics.loading': '分析データを読み込み中...',
    'analytics.parkVisitsDistribution': 'パーク来園分布',
    'analytics.activityBreakdown': 'アクティビティ内訳',
    'analytics.visitsOverTime': '来園数推移',
    'analytics.popularAreas': '人気エリア',
    'analytics.visitCalendar': '来園カレンダー',
    'analytics.topAttractions': 'トップアトラクション',
    'analytics.favoriteRestaurants': 'お気に入りレストラン',
    'analytics.favoriteCompanions': 'お気に入りの同行者',
    'analytics.exportSuccess': '分析データエクスポート',
    'analytics.exportError': 'エクスポートエラー',
    'analytics.exportErrorMessage': '分析データの生成に失敗しました。',
    'analytics.visits': '回',
    'analytics.visitsTogether': '一緒に来園',

    // Profile Screen
    'profile.disneyExplorer': 'ディズニーエクスプローラー',
    'profile.email': 'explorer@tdrdays.com',
    'profile.days': '日',
    'profile.attractions': 'アトラクション',
    'profile.photos': '写真',
    'profile.account': 'アカウント',
    'profile.editProfile': 'プロフィール編集',
    'profile.notifications': '通知',
    'profile.privacy': 'プライバシー',
    'profile.preferences': '設定',
    'profile.darkMode': 'ダークモード',
    'profile.themeStudio': 'テーマスタジオ',
    'profile.language': '言語',
    'profile.dateFormat': '日付形式',
    'profile.dataStorage': 'データ・ストレージ',
    'profile.backupData': 'データバックアップ',
    'profile.restoreData': 'データ復元',
    'profile.clearCache': 'キャッシュクリア',
    'profile.other': 'その他',
    'profile.helpSupport': 'ヘルプ・サポート',
    'profile.about': 'アプリについて',
    'profile.signOut': 'サインアウト',
    'profile.version': 'TDR Days v1.0.0',
    'profile.madeWithLove': 'ディズニーファンのために ❤️ で作成',
    'profile.japanese': '日本語',
    'profile.english': 'English',
    'profile.welcomeTitle': 'プロフィール設定',
    'profile.welcomeMessage': 'あなたの名前とプロフィール画像を設定して始めましょう！',
    'profile.addPhoto': '写真を追加',
    'profile.changePhoto': '写真を変更',
    'profile.yourName': 'お名前',
    'profile.namePlaceholder': 'お名前を入力してください',
    'profile.getStarted': '始める',
    'profile.saving': '保存中...',
    'profile.nameRequired': '名前が必要です',
    'profile.nameRequiredMessage': '名前を入力してください。',
    'profile.saveError': '保存エラー',
    'profile.saveErrorMessage': 'プロフィールの保存に失敗しました。',
    'profile.permissionRequired': '権限が必要です',
    'profile.permissionMessage': '写真ライブラリへのアクセス権限が必要です。',
    'profile.imageError': '画像エラー',
    'profile.imageErrorMessage': '画像の選択に失敗しました。',
    'profile.cropImage': '画像を切り取り',
    'profile.cropError': '切り取りエラー',
    'profile.cropErrorMessage': '画像の切り取りに失敗しました。',
    'profile.cropInstructions': '円の中に収めたい部分を調整してください',
    'profile.scaleControl': '拡大・縮小',
    'profile.positionControl': '位置調整',

    // Parks
    'park.disneyland': 'ディズニーランド',
    'park.disneysea': 'ディズニーシー',

    // Date formats
    'date.format': 'YYYY/MM/DD',
  },
  en: {
    // Common
    'common.loading': 'Loading...',
    'common.save': 'Save',
    'common.cancel': 'Cancel',
    'common.delete': 'Delete',
    'common.edit': 'Edit',
    'common.add': 'Add',
    'common.search': 'Search',
    'common.filter': 'Filter',
    'common.settings': 'Settings',
    'common.back': 'Back',
    'common.next': 'Next',
    'common.previous': 'Previous',
    'common.complete': 'Complete',
    'common.ok': 'OK',
    'common.yes': 'Yes',
    'common.no': 'No',
    'common.done': 'Done',

    // Navigation
    'nav.home': 'Home',
    'nav.visitList': 'Visit Records',
    'nav.record': 'Record',
    'nav.analytics': 'Analytics',
    'nav.profile': 'Profile',

    // Home Screen
    'home.welcome': 'Welcome to',
    'home.appTitle': 'TDR Days',
    'home.tagline': '✨ Your magical Disney journey awaits ✨',
    'home.totalVisits': 'Total Visits',
    'home.allTime': 'All time',
    'home.activities': 'Activities',
    'home.logged': 'Logged',
    'home.disneyland': 'Disneyland',
    'home.disneysea': 'DisneySea',
    'home.disneylandShort': 'Land',
    'home.disneyseaShort': 'Sea',
    'home.visits': 'Visits',
    'home.chooseAdventure': 'Choose Your Adventure',
    'home.selectPark': 'Select a park to explore your magical memories',
    'home.tokyoDisneyland': 'Tokyo Disneyland',
    'home.landDescription': 'The magical kingdom where dreams come true',
    'home.tokyoDisneysea': 'Tokyo DisneySea',
    'home.seaDescription': 'Discover the wonders of adventure and imagination',
    'home.quickActions': 'Quick Actions',
    'home.newVisit': 'New Visit',
    'home.analytics': 'Analytics',
    'home.photos': 'Photos',
    'home.favorites': 'Favorites',
    'home.recentMagic': 'Recent Magic',
    'home.startJourney': 'Start Your Magical Journey',
    'home.firstVisitMessage': 'Record your first Disney visit and begin creating unforgettable memories!',
    'home.recordFirstVisit': 'Record First Visit',
    'home.noVisitsFound': 'No visits found',
    'home.adjustFilters': 'Try adjusting your filters to see more visits',
    'home.addFirstVisit': 'Start by adding your first Disney visit!',

    // Record Screen
    'record.title': 'Record Your Visit',
    'record.editVisit': 'Edit Visit Record',
    'record.subtitle': 'Capture the magic of your Disney day',
    'record.complete': '% Complete',
    'record.weather': 'Weather',
    'record.sunny': 'Sunny',
    'record.cloudy': 'Cloudy',
    'record.rainy': 'Rainy',
    'record.snowy': 'Snowy',
    'record.notes': 'Notes',
    'record.notesPlaceholder': 'Share your magical moments, favorite attractions, or memories from today...',
    'record.saveVisit': 'Save Visit',
    'record.savingVisit': 'Saving Visit...',
    'record.incompleteForm': 'Incomplete Form',
    'record.selectDateAndPark': 'Please select at least a date and park.',
    'record.success': 'Success!',
    'record.successMessage': 'Your visit has been recorded successfully!',
    'record.error': 'Error',
    'record.errorMessage': 'Failed to save visit. Please try again.',

    // Analytics Screen
    'analytics.title': 'Analytics Dashboard',
    'analytics.subtitle': 'Discover your Disney patterns',
    'analytics.totalVisits': 'Total Visits',
    'analytics.totalActions': 'Total Actions',
    'analytics.photosTaken': 'Photos Taken',
    'analytics.avgVisitDuration': 'Avg Visit Duration',
    'analytics.allTime': 'All time',
    'analytics.thisPeriod': 'This period',
    'analytics.perVisit': 'per visit',
    'analytics.memoriesCaptured': 'Memories captured',
    'analytics.hoursPerVisit': 'Hours per visit',
    'analytics.monthly': 'Monthly',
    'analytics.yearly': 'Yearly',
    'analytics.custom': 'Custom',
    'analytics.loading': 'Loading analytics...',
    'analytics.parkVisitsDistribution': 'Park Visits Distribution',
    'analytics.activityBreakdown': 'Activity Breakdown',
    'analytics.visitsOverTime': 'Visits Over Time',
    'analytics.popularAreas': 'Popular Areas',
    'analytics.visitCalendar': 'Visit Calendar',
    'analytics.topAttractions': 'Top Attractions',
    'analytics.favoriteRestaurants': 'Favorite Restaurants',
    'analytics.favoriteCompanions': 'Favorite Companions',
    'analytics.exportSuccess': 'Analytics Export',
    'analytics.exportError': 'Export Error',
    'analytics.exportErrorMessage': 'Failed to generate analytics data.',
    'analytics.visits': 'visits',
    'analytics.visitsTogether': 'visits together',

    // Profile Screen
    'profile.disneyExplorer': 'Disney Explorer',
    'profile.email': 'explorer@tdrdays.com',
    'profile.days': 'Days',
    'profile.attractions': 'Attractions',
    'profile.photos': 'Photos',
    'profile.account': 'Account',
    'profile.editProfile': 'Edit Profile',
    'profile.notifications': 'Notifications',
    'profile.privacy': 'Privacy',
    'profile.preferences': 'Preferences',
    'profile.darkMode': 'Dark Mode',
    'profile.themeStudio': 'Theme Studio',
    'profile.language': 'Language',
    'profile.dateFormat': 'Date Format',
    'profile.dataStorage': 'Data & Storage',
    'profile.backupData': 'Backup Data',
    'profile.restoreData': 'Restore Data',
    'profile.clearCache': 'Clear Cache',
    'profile.other': 'Other',
    'profile.helpSupport': 'Help & Support',
    'profile.about': 'About',
    'profile.signOut': 'Sign Out',
    'profile.version': 'TDR Days v1.0.0',
    'profile.madeWithLove': 'Made with ❤️ for Disney fans',
    'profile.japanese': '日本語',
    'profile.english': 'English',
    'profile.welcomeTitle': 'Profile Setup',
    'profile.welcomeMessage': 'Set up your name and profile picture to get started!',
    'profile.addPhoto': 'Add Photo',
    'profile.changePhoto': 'Change Photo',
    'profile.yourName': 'Your Name',
    'profile.namePlaceholder': 'Enter your name',
    'profile.getStarted': 'Get Started',
    'profile.saving': 'Saving...',
    'profile.nameRequired': 'Name Required',
    'profile.nameRequiredMessage': 'Please enter your name.',
    'profile.saveError': 'Save Error',
    'profile.saveErrorMessage': 'Failed to save profile.',
    'profile.permissionRequired': 'Permission Required',
    'profile.permissionMessage': 'Photo library access permission is required.',
    'profile.imageError': 'Image Error',
    'profile.imageErrorMessage': 'Failed to select image.',
    'profile.cropImage': 'Crop Image',
    'profile.cropError': 'Crop Error',
    'profile.cropErrorMessage': 'Failed to crop image.',
    'profile.cropInstructions': 'Adjust the part you want to fit in the circle',
    'profile.scaleControl': 'Scale',
    'profile.positionControl': 'Position',

    // Parks
    'park.disneyland': 'Disneyland',
    'park.disneysea': 'DisneySea',

    // Date formats
    'date.format': 'MM/DD/YYYY',
  },
};

// Language Provider Props
interface LanguageProviderProps {
  children: ReactNode;
}

// Language Provider Component
export const LanguageProvider: React.FC<LanguageProviderProps> = ({ children }) => {
  const [language, setLanguageState] = useState<Language>('ja'); // Default to Japanese
  const [isLoading, setIsLoading] = useState(true);

  // Load saved language preference on mount
  useEffect(() => {
    const loadSavedLanguage = async () => {
      try {
        const savedLanguage = await AsyncStorage.getItem(LANGUAGE_STORAGE_KEY);
        if (savedLanguage && (savedLanguage === 'ja' || savedLanguage === 'en')) {
          setLanguageState(savedLanguage as Language);
        }
      } catch (error) {
        console.error('Error loading language preference:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadSavedLanguage();
  }, []);

  // Set language and save to storage
  const setLanguage = async (lang: Language) => {
    setLanguageState(lang);
    try {
      await AsyncStorage.setItem(LANGUAGE_STORAGE_KEY, lang);
    } catch (error) {
      console.error('Error saving language preference:', error);
    }
  };

  // Translation function
  const t = (key: string, params?: Record<string, string>): string => {
    // Simple key-based lookup
    const currentLangTranslations = translations[language];
    
    if (currentLangTranslations && currentLangTranslations[key]) {
      let value = currentLangTranslations[key];
      
      // Replace parameters if provided
      if (params) {
        return Object.entries(params).reduce((str, [paramKey, paramValue]) => {
          return str.replace(new RegExp(`\\{\\{${paramKey}\\}\\}`, 'g'), paramValue);
        }, value);
      }
      
      return value;
    }
    
    // Fallback to English
    const englishTranslations = translations.en;
    if (englishTranslations && englishTranslations[key]) {
      let value = englishTranslations[key];
      
      // Replace parameters if provided
      if (params) {
        return Object.entries(params).reduce((str, [paramKey, paramValue]) => {
          return str.replace(new RegExp(`\\{\\{${paramKey}\\}\\}`, 'g'), paramValue);
        }, value);
      }
      
      return value;
    }
    
    return key; // Return the key itself as fallback
  };

  const contextValue: LanguageContextType = {
    language,
    setLanguage,
    t,
    isLoading,
  };

  return (
    <LanguageContext.Provider value={contextValue}>
      {children}
    </LanguageContext.Provider>
  );
};

// Custom hook to use the language context
export const useLanguage = (): LanguageContextType => {
  const context = useContext(LanguageContext);
  
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  
  return context;
};

// Export types
export type TranslationKey = string;
export default LanguageContext;
</file>

<file path="src/contexts/ThemeContext.tsx">
// Ultra-Minimal Theme Context - Safe Implementation
import React, { createContext, useContext, useState, ReactNode } from 'react';

// Minimal fallback theme
const fallbackTheme = {
  mode: 'light' as const,
  colors: {
    purple: {
      500: '#9333ea',
      bright: '#8b5cf6',
    },
    background: {
      primary: '#ffffff',
      secondary: '#fdfdfd', 
      card: '#ffffff',
    },
    text: {
      primary: '#1f2937',
      secondary: '#6b7280',
    },
    utility: {
      borderLight: '#f3f4f6',
    },
  },
};

// Try to import theme safely
let lightTheme, darkTheme;
try {
  const themeModule = require('../styles/theme');
  lightTheme = themeModule.lightTheme || fallbackTheme;
  darkTheme = themeModule.darkTheme || { ...fallbackTheme, mode: 'dark' };
} catch (error) {
  console.warn('Failed to import theme, using fallback');
  lightTheme = fallbackTheme;
  darkTheme = { ...fallbackTheme, mode: 'dark' };
}

export type ThemeMode = 'light' | 'dark';
export type Theme = typeof fallbackTheme;

// Simple theme configuration
export interface ThemeConfiguration {
  mode: ThemeMode;
  designStyle: string;
  accentColor: string;
  animationSpeed: string;
  borderRadiusPreference: string;
  shadowIntensity: string;
}

// Theme context interface
interface ThemeContextType {
  theme: Theme;
  themeMode: ThemeMode;
  toggleTheme: () => void;
  setThemeMode: (mode: ThemeMode) => void;
  isLoading: boolean;
  systemTheme: string | null;
  
  // Configuration
  themeConfig: ThemeConfiguration;
  setDesignStyle: (style: string) => void;
  setAccentColor: (color: string) => void;
  setAnimationSpeed: (speed: string) => void;
  setBorderRadiusPreference: (preference: string) => void;
  setShadowIntensity: (intensity: string) => void;
  resetThemeDefaults: () => void;
  exportThemeSettings: () => string;
  importThemeSettings: (settings: string) => Promise<boolean>;
}

// Default configuration
const defaultThemeConfig: ThemeConfiguration = {
  mode: 'light',
  designStyle: 'material',
  accentColor: '#a855f7',
  animationSpeed: 'normal',
  borderRadiusPreference: 'rounded',
  shadowIntensity: 'normal',
};

// Create context
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Provider props
interface ThemeProviderProps {
  children: ReactNode;
}

// Safe Theme Provider
export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [themeMode, setThemeModeState] = useState<ThemeMode>('light');
  const [themeConfig, setThemeConfig] = useState<ThemeConfiguration>(defaultThemeConfig);
  const [isLoading] = useState(false);

  // Safe theme selection
  const theme = themeMode === 'light' ? (lightTheme || fallbackTheme) : (darkTheme || fallbackTheme);

  // Toggle theme
  const toggleTheme = () => {
    const newMode = themeMode === 'light' ? 'dark' : 'light';
    setThemeModeState(newMode);
  };

  // Set theme mode
  const setThemeMode = (mode: ThemeMode) => {
    setThemeModeState(mode);
  };

  // Simple config setters
  const setDesignStyle = (style: string) => {
    setThemeConfig(prev => ({ ...prev, designStyle: style }));
  };

  const setAccentColor = (color: string) => {
    setThemeConfig(prev => ({ ...prev, accentColor: color }));
  };

  const setAnimationSpeed = (speed: string) => {
    setThemeConfig(prev => ({ ...prev, animationSpeed: speed }));
  };

  const setBorderRadiusPreference = (preference: string) => {
    setThemeConfig(prev => ({ ...prev, borderRadiusPreference: preference }));
  };

  const setShadowIntensity = (intensity: string) => {
    setThemeConfig(prev => ({ ...prev, shadowIntensity: intensity }));
  };

  const resetThemeDefaults = () => {
    setThemeConfig(defaultThemeConfig);
  };

  const exportThemeSettings = (): string => {
    return JSON.stringify(themeConfig);
  };

  const importThemeSettings = async (settings: string): Promise<boolean> => {
    try {
      const config = JSON.parse(settings);
      setThemeConfig(config);
      return true;
    } catch {
      return false;
    }
  };

  const contextValue: ThemeContextType = {
    theme,
    themeMode,
    toggleTheme,
    setThemeMode,
    isLoading,
    systemTheme: null,
    themeConfig,
    setDesignStyle,
    setAccentColor,
    setAnimationSpeed,
    setBorderRadiusPreference,
    setShadowIntensity,
    resetThemeDefaults,
    exportThemeSettings,
    importThemeSettings,
  };

  return (
    <ThemeContext.Provider value={contextValue}>
      {children}
    </ThemeContext.Provider>
  );
};

// Safe hook to use theme
export const useTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  if (!context) {
    // Return a safe fallback instead of throwing
    return {
      theme: fallbackTheme,
      themeMode: 'light',
      toggleTheme: () => {},
      setThemeMode: () => {},
      isLoading: false,
      systemTheme: null,
      themeConfig: defaultThemeConfig,
      setDesignStyle: () => {},
      setAccentColor: () => {},
      setAnimationSpeed: () => {},
      setBorderRadiusPreference: () => {},
      setShadowIntensity: () => {},
      resetThemeDefaults: () => {},
      exportThemeSettings: () => '{}',
      importThemeSettings: async () => false,
    };
  }
  return context;
};

export default ThemeContext;
</file>

<file path="src/hooks/useActions.ts">
/**
 * Hook for managing timeline actions with CRUD operations and filtering
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import { storage, STORAGE_KEYS, StorageError } from '../services/storage';
import {
  TimelineAction,
  ActionFilter,
  ActionStats,
  ActionCategory,
  ParkArea,
  Visit,
  DateRange,
  SortOptions,
  CreateInput,
  UpdateInput,
  Photo,
} from '../types/models';

interface UseActionsReturn {
  // Data
  actions: TimelineAction[];
  isLoading: boolean;
  error: StorageError | null;

  // CRUD operations
  createAction: (action: CreateInput<TimelineAction>) => Promise<TimelineAction>;
  updateAction: (id: string, updates: UpdateInput<TimelineAction>) => Promise<TimelineAction | null>;
  deleteAction: (id: string) => Promise<boolean>;
  deleteAllActions: () => Promise<boolean>;
  getAction: (id: string) => Promise<TimelineAction | null>;

  // Batch operations
  createMultipleActions: (actions: CreateInput<TimelineAction>[]) => Promise<TimelineAction[]>;
  updateMultipleActions: (updates: Array<{ id: string; data: UpdateInput<TimelineAction> }>) => Promise<TimelineAction[]>;
  deleteMultipleActions: (ids: string[]) => Promise<number>;

  // Query operations
  getActionsByVisit: (visitId: string) => Promise<TimelineAction[]>;
  getActionsByCategory: (category: ActionCategory) => Promise<TimelineAction[]>;
  getActionsByArea: (area: ParkArea) => Promise<TimelineAction[]>;
  getActionsByDateRange: (dateRange: DateRange) => Promise<TimelineAction[]>;
  getFilteredActions: (filter: ActionFilter) => Promise<TimelineAction[]>;

  // Sorting and ordering
  sortActions: (actions: TimelineAction[], sortBy: SortOptions<TimelineAction>) => TimelineAction[];
  reorderActions: (visitId: string, actionIds: string[]) => Promise<void>;
  
  // Photo operations
  addPhotosToAction: (actionId: string, photos: Photo[]) => Promise<TimelineAction | null>;
  removePhotoFromAction: (actionId: string, photoId: string) => Promise<TimelineAction | null>;

  // Statistics
  getActionStatistics: (filter?: ActionFilter) => Promise<ActionStats>;
  getLocationVisitCount: (locationName: string) => Promise<number>;
  
  // Utility
  refreshData: () => Promise<void>;
}

export function useActions(): UseActionsReturn {
  const [actions, setActions] = useState<TimelineAction[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<StorageError | null>(null);

  // Load initial data
  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      const actionsData = await storage.getAll<TimelineAction>(STORAGE_KEYS.ACTIONS);
      setActions(actionsData);
    } catch (err) {
      setError(err as StorageError);
      // Still set empty array on error
      setActions([]);
    } finally {
      setIsLoading(false);
    }
  };

  // CRUD operations
  const createAction = useCallback(async (
    actionData: CreateInput<TimelineAction>
  ): Promise<TimelineAction> => {
    try {
      // Auto-assign sort order if not provided
      if (actionData.sortOrder === undefined) {
        const visitActions = await getActionsByVisit(actionData.visitId);
        const maxSortOrder = Math.max(...visitActions.map(a => a.sortOrder || 0), 0);
        actionData.sortOrder = maxSortOrder + 1;
      }

      const newAction = await storage.create<TimelineAction>(STORAGE_KEYS.ACTIONS, actionData);
      
      // Update visit's cached action count
      const visit = await storage.get<Visit>(STORAGE_KEYS.VISITS, actionData.visitId);
      if (visit) {
        await storage.update<Visit>(STORAGE_KEYS.VISITS, visit.id, {
          actionCount: (visit.actionCount || 0) + 1,
          totalPhotoCount: (visit.totalPhotoCount || 0) + (actionData.photos?.length || 0),
        });
      }

      await loadData();
      return newAction;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const updateAction = useCallback(async (
    id: string,
    updates: UpdateInput<TimelineAction>
  ): Promise<TimelineAction | null> => {
    try {
      const currentAction = await storage.get<TimelineAction>(STORAGE_KEYS.ACTIONS, id);
      if (!currentAction) return null;

      const updatedAction = await storage.update<TimelineAction>(STORAGE_KEYS.ACTIONS, id, updates);
      
      // Update visit's cached photo count if photos changed
      if (updates.photos !== undefined && currentAction.photos.length !== updates.photos.length) {
        const visit = await storage.get<Visit>(STORAGE_KEYS.VISITS, currentAction.visitId);
        if (visit) {
          const photoDiff = updates.photos.length - currentAction.photos.length;
          await storage.update<Visit>(STORAGE_KEYS.VISITS, visit.id, {
            totalPhotoCount: (visit.totalPhotoCount || 0) + photoDiff,
          });
        }
      }

      await loadData();
      return updatedAction;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const deleteAction = useCallback(async (id: string): Promise<boolean> => {
    try {
      const action = await storage.get<TimelineAction>(STORAGE_KEYS.ACTIONS, id);
      if (!action) return false;

      const result = await storage.delete<TimelineAction>(STORAGE_KEYS.ACTIONS, id);
      
      if (result) {
        // Update visit's cached counts
        const visit = await storage.get<Visit>(STORAGE_KEYS.VISITS, action.visitId);
        if (visit) {
          await storage.update<Visit>(STORAGE_KEYS.VISITS, visit.id, {
            actionCount: Math.max((visit.actionCount || 0) - 1, 0),
            totalPhotoCount: Math.max((visit.totalPhotoCount || 0) - action.photos.length, 0),
          });
        }
      }

      await loadData();
      return result;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const deleteAllActions = useCallback(async (): Promise<boolean> => {
    try {
      // Clear all actions
      await storage.clear(STORAGE_KEYS.ACTIONS);
      
      // Reset action counts in all visits
      const allVisits = await storage.getAll<Visit>(STORAGE_KEYS.VISITS);
      if (allVisits.length > 0) {
        const updates = allVisits.map(visit => ({
          id: visit.id,
          data: { 
            actionCount: 0,
            totalPhotoCount: 0
          }
        }));
        await storage.updateMany<Visit>(STORAGE_KEYS.VISITS, updates);
      }
      
      await loadData();
      return true;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getAction = useCallback(async (id: string): Promise<TimelineAction | null> => {
    try {
      return await storage.get<TimelineAction>(STORAGE_KEYS.ACTIONS, id);
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  // Batch operations
  const createMultipleActions = useCallback(async (
    actionsData: CreateInput<TimelineAction>[]
  ): Promise<TimelineAction[]> => {
    try {
      // Group by visit to assign sort orders
      const actionsByVisit = actionsData.reduce((acc, action) => {
        if (!acc[action.visitId]) acc[action.visitId] = [];
        acc[action.visitId].push(action);
        return acc;
      }, {} as Record<string, CreateInput<TimelineAction>[]>);

      // Assign sort orders for each visit
      for (const visitId in actionsByVisit) {
        const visitActions = await getActionsByVisit(visitId);
        let maxSortOrder = Math.max(...visitActions.map(a => a.sortOrder || 0), 0);
        
        actionsByVisit[visitId].forEach(action => {
          if (action.sortOrder === undefined) {
            action.sortOrder = ++maxSortOrder;
          }
        });
      }

      const newActions = await storage.createMany<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        actionsData
      );

      // Update visit cached counts
      const visitUpdates = Object.entries(actionsByVisit).map(([visitId, visitActions]) => ({
        id: visitId,
        data: {
          actionCount: actions.filter(a => a.visitId === visitId).length + visitActions.length,
          totalPhotoCount: actions.filter(a => a.visitId === visitId).reduce((sum, a) => sum + a.photos.length, 0) +
                          visitActions.reduce((sum, a) => sum + (a.photos?.length || 0), 0),
        },
      }));

      if (visitUpdates.length > 0) {
        await storage.updateMany<Visit>(STORAGE_KEYS.VISITS, visitUpdates);
      }

      await loadData();
      return newActions;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [actions]);

  const updateMultipleActions = useCallback(async (
    updates: Array<{ id: string; data: UpdateInput<TimelineAction> }>
  ): Promise<TimelineAction[]> => {
    try {
      const updatedActions = await storage.updateMany<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        updates
      );
      await loadData();
      return updatedActions;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const deleteMultipleActions = useCallback(async (ids: string[]): Promise<number> => {
    try {
      // Get actions to update visit counts
      const actionsToDelete = await Promise.all(
        ids.map(id => storage.get<TimelineAction>(STORAGE_KEYS.ACTIONS, id))
      );
      const validActions = actionsToDelete.filter(Boolean) as TimelineAction[];

      const deletedCount = await storage.deleteMany<TimelineAction>(STORAGE_KEYS.ACTIONS, ids);

      // Update visit cached counts
      const visitCounts = validActions.reduce((acc, action) => {
        if (!acc[action.visitId]) {
          acc[action.visitId] = { actionCount: 0, photoCount: 0 };
        }
        acc[action.visitId].actionCount++;
        acc[action.visitId].photoCount += action.photos.length;
        return acc;
      }, {} as Record<string, { actionCount: number; photoCount: number }>);

      const visitUpdates = await Promise.all(
        Object.entries(visitCounts).map(async ([visitId, counts]) => {
          const visit = await storage.get<Visit>(STORAGE_KEYS.VISITS, visitId);
          if (visit) {
            return {
              id: visitId,
              data: {
                actionCount: Math.max((visit.actionCount || 0) - counts.actionCount, 0),
                totalPhotoCount: Math.max((visit.totalPhotoCount || 0) - counts.photoCount, 0),
              },
            };
          }
          return null;
        })
      ).then(results => results.filter(Boolean) as Array<{ id: string; data: Partial<Visit> }>);

      if (visitUpdates.length > 0) {
        await storage.updateMany<Visit>(STORAGE_KEYS.VISITS, visitUpdates);
      }

      await loadData();
      return deletedCount;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  // Query operations
  const getActionsByVisit = useCallback(async (visitId: string): Promise<TimelineAction[]> => {
    try {
      const visitActions = await storage.find<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        action => action.visitId === visitId
      );
      return sortActions(visitActions, { field: 'time', direction: 'ASC' });
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getActionsByCategory = useCallback(async (
    category: ActionCategory
  ): Promise<TimelineAction[]> => {
    try {
      return await storage.find<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        action => action.category === category
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getActionsByArea = useCallback(async (area: ParkArea): Promise<TimelineAction[]> => {
    try {
      return await storage.find<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        action => action.area === area
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getActionsByDateRange = useCallback(async (
    dateRange: DateRange
  ): Promise<TimelineAction[]> => {
    try {
      // First get visits in date range (using JST)
      const visits = await storage.find<Visit>(
        STORAGE_KEYS.VISITS,
        visit => {
          const jstOffset = 9 * 60; // JST is UTC+9
          const visitDate = new Date(visit.date);
          const visitDateJST = new Date(visitDate.getTime() + (jstOffset * 60 * 1000));
          const startDateJST = new Date(dateRange.startDate.getTime() + (jstOffset * 60 * 1000));
          const endDateJST = new Date(dateRange.endDate.getTime() + (jstOffset * 60 * 1000));
          
          return visitDateJST >= startDateJST && visitDateJST <= endDateJST;
        }
      );
      const visitIds = visits.map(v => v.id);

      // Then get actions for those visits
      return await storage.find<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        action => visitIds.includes(action.visitId)
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getFilteredActions = useCallback(async (
    filter: ActionFilter
  ): Promise<TimelineAction[]> => {
    try {
      return await storage.find<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        action => {
          if (filter.visitId && action.visitId !== filter.visitId) return false;
          if (filter.category && action.category !== filter.category) return false;
          if (filter.area && action.area !== filter.area) return false;
          if (filter.locationName && 
              !action.locationName.toLowerCase().includes(filter.locationName.toLowerCase())) {
            return false;
          }
          
          if (filter.dateRange) {
            // Need to check visit date
            return true; // Will be filtered in post-processing
          }
          
          return true;
        }
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  // Sorting
  const sortActions = useCallback((
    actionsToSort: TimelineAction[],
    sortBy: SortOptions<TimelineAction>
  ): TimelineAction[] => {
    return [...actionsToSort].sort((a, b) => {
      const aValue = a[sortBy.field];
      const bValue = b[sortBy.field];

      if (aValue === undefined || bValue === undefined) return 0;

      let comparison = 0;
      if (aValue < bValue) comparison = -1;
      if (aValue > bValue) comparison = 1;

      return sortBy.direction === 'ASC' ? comparison : -comparison;
    });
  }, []);

  const reorderActions = useCallback(async (
    visitId: string,
    actionIds: string[]
  ): Promise<void> => {
    try {
      const updates = actionIds.map((id, index) => ({
        id,
        data: { sortOrder: index },
      }));

      await storage.updateMany<TimelineAction>(STORAGE_KEYS.ACTIONS, updates);
      await loadData();
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  // Photo operations
  const addPhotosToAction = useCallback(async (
    actionId: string,
    photos: Photo[]
  ): Promise<TimelineAction | null> => {
    try {
      const action = await storage.get<TimelineAction>(STORAGE_KEYS.ACTIONS, actionId);
      if (!action) return null;

      const updatedPhotos = [...action.photos, ...photos];
      return await updateAction(actionId, { photos: updatedPhotos });
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [updateAction]);

  const removePhotoFromAction = useCallback(async (
    actionId: string,
    photoId: string
  ): Promise<TimelineAction | null> => {
    try {
      const action = await storage.get<TimelineAction>(STORAGE_KEYS.ACTIONS, actionId);
      if (!action) return null;

      const updatedPhotos = action.photos.filter(photo => photo.id !== photoId);
      return await updateAction(actionId, { photos: updatedPhotos });
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [updateAction]);

  // Statistics
  const getActionStatistics = useCallback(async (
    filter?: ActionFilter
  ): Promise<ActionStats> => {
    try {
      let filteredActions = filter
        ? await getFilteredActions(filter)
        : await storage.getAll<TimelineAction>(STORAGE_KEYS.ACTIONS);

      // Apply date range filter if needed (using JST)
      if (filter?.dateRange) {
        const visits = await storage.find<Visit>(
          STORAGE_KEYS.VISITS,
          visit => {
            const jstOffset = 9 * 60; // JST is UTC+9
            const visitDate = new Date(visit.date);
            const visitDateJST = new Date(visitDate.getTime() + (jstOffset * 60 * 1000));
            const startDateJST = new Date(filter.dateRange!.startDate.getTime() + (jstOffset * 60 * 1000));
            const endDateJST = new Date(filter.dateRange!.endDate.getTime() + (jstOffset * 60 * 1000));
            
            return visitDateJST >= startDateJST && visitDateJST <= endDateJST;
          }
        );
        const visitIds = new Set(visits.map(v => v.id));
        filteredActions = filteredActions.filter(action => visitIds.has(action.visitId));
      }

      // Exclude custom actions from analytics calculations
      filteredActions = filteredActions.filter(action => action.category !== ActionCategory.CUSTOM);

      // Calculate actions by category
      const actionsByCategory = filteredActions.reduce((acc, action) => {
        acc[action.category] = (acc[action.category] || 0) + 1;
        return acc;
      }, {} as Record<ActionCategory, number>);

      // Calculate top attractions
      const attractionCounts = new Map<string, { count: number; totalWaitTime: number }>();
      filteredActions
        .filter(action => action.category === ActionCategory.ATTRACTION)
        .forEach(action => {
          const current = attractionCounts.get(action.locationName) || { count: 0, totalWaitTime: 0 };
          attractionCounts.set(action.locationName, {
            count: current.count + 1,
            totalWaitTime: current.totalWaitTime + (action.waitTime || 0),
          });
        });

      const topAttractions = Array.from(attractionCounts.entries())
        .map(([locationName, stats]) => ({
          locationName,
          count: stats.count,
          averageWaitTime: stats.count > 0 && stats.totalWaitTime > 0 
            ? Math.round(stats.totalWaitTime / stats.count) 
            : undefined,
        }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);

      // Calculate top restaurants
      const restaurantCounts = new Map<string, number>();
      filteredActions
        .filter(action => action.category === ActionCategory.RESTAURANT)
        .forEach(action => {
          restaurantCounts.set(
            action.locationName,
            (restaurantCounts.get(action.locationName) || 0) + 1
          );
        });

      const topRestaurants = Array.from(restaurantCounts.entries())
        .map(([locationName, count]) => ({ locationName, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);

      // Calculate area distribution
      const areaStats = new Map<ParkArea, { visitCount: number; timeSpent: number }>();
      filteredActions.forEach(action => {
        const current = areaStats.get(action.area) || { visitCount: 0, timeSpent: 0 };
        areaStats.set(action.area, {
          visitCount: current.visitCount + 1,
          timeSpent: current.timeSpent + (action.duration || 0),
        });
      });

      const areaDistribution = Array.from(areaStats.entries())
        .map(([area, stats]) => ({
          area,
          visitCount: stats.visitCount,
          timeSpent: stats.timeSpent,
        }))
        .sort((a, b) => b.visitCount - a.visitCount);

      // Calculate photo count
      const photoCount = filteredActions.reduce((sum, action) => sum + action.photos.length, 0);

      // Calculate average actions per visit with safety check
      const uniqueVisitIds = new Set(filteredActions.map(a => a.visitId));
      const averageActionsPerVisit = uniqueVisitIds.size > 0
        ? filteredActions.length / uniqueVisitIds.size
        : 0;

      return {
        totalActions: filteredActions.length,
        actionsByCategory,
        topAttractions,
        topRestaurants,
        areaDistribution,
        averageActionsPerVisit,
        photoCount,
      };
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [getFilteredActions]);

  const getLocationVisitCount = useCallback(async (locationName: string): Promise<number> => {
    try {
      const matchingActions = await storage.find<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        action => action.locationName.toLowerCase() === locationName.toLowerCase()
      );
      return matchingActions.length;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const refreshData = useCallback(async () => {
    await loadData();
  }, []);

  return {
    // Data
    actions,
    isLoading,
    error,

    // CRUD operations
    createAction,
    updateAction,
    deleteAction,
    deleteAllActions,
    getAction,

    // Batch operations
    createMultipleActions,
    updateMultipleActions,
    deleteMultipleActions,

    // Query operations
    getActionsByVisit,
    getActionsByCategory,
    getActionsByArea,
    getActionsByDateRange,
    getFilteredActions,

    // Sorting and ordering
    sortActions,
    reorderActions,

    // Photo operations
    addPhotosToAction,
    removePhotoFromAction,

    // Statistics
    getActionStatistics,
    getLocationVisitCount,

    // Utility
    refreshData,
  };
}
</file>

<file path="src/hooks/useResponsive.ts">
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Dimensions, ScaledSize } from 'react-native';
import {
  getCurrentBreakpoint,
  getScreenDimensions,
  responsiveValue,
  responsiveDimension,
  responsiveFontSize,
  responsiveSpacing,
  getLayoutConfig,
  calculateColumnWidth,
  getContainerWidth,
  BREAKPOINTS,
  PLATFORM,
  getGridConfig,
  getSafeAreaPadding,
  getAnimationDuration,
  getTouchTargetSize,
} from '../utils/responsive';

// Main responsive hook
export const useResponsive = () => {
  const [dimensions, setDimensions] = useState(getScreenDimensions());
  const [breakpoint, setBreakpoint] = useState(getCurrentBreakpoint());

  useEffect(() => {
    const updateDimensions = ({ window }: { window: ScaledSize }) => {
      const newDimensions = {
        width: window.width,
        height: window.height,
        isLandscape: window.width > window.height,
        isPortrait: window.width <= window.height,
        aspectRatio: window.width / window.height,
      };
      setDimensions(newDimensions);
      setBreakpoint(getCurrentBreakpoint(window.width));
    };

    const subscription = Dimensions.addEventListener('change', updateDimensions);
    return () => subscription?.remove();
  }, []);

  const responsive = useCallback(
    <T>(values: Partial<Record<keyof typeof BREAKPOINTS, T>>): T => {
      return responsiveValue(values, dimensions.width);
    },
    [dimensions.width]
  );

  const rDimension = useCallback(
    (base: number, scale?: Partial<Record<keyof typeof BREAKPOINTS, number>>) => {
      return responsiveDimension(base, scale);
    },
    [dimensions.width]
  );

  const rFontSize = useCallback(
    (base: number) => responsiveFontSize(base),
    [dimensions.width]
  );

  const rSpacing = useCallback(
    (base: number) => responsiveSpacing(base),
    [dimensions.width]
  );

  const layoutConfig = useMemo(
    () => getLayoutConfig(dimensions.width),
    [dimensions.width]
  );

  const gridConfig = useMemo(
    () => getGridConfig(dimensions.width),
    [dimensions.width]
  );

  const containerWidth = useMemo(
    () => getContainerWidth(),
    [dimensions.width]
  );

  const safeAreaPadding = useMemo(
    () => getSafeAreaPadding(),
    [breakpoint]
  );

  const animationDuration = useCallback(
    (base?: number) => getAnimationDuration(base),
    [breakpoint]
  );

  const touchTargetSize = useMemo(
    () => getTouchTargetSize(),
    [breakpoint]
  );

  const isBreakpoint = useCallback(
    (bp: keyof typeof BREAKPOINTS) => {
      return dimensions.width >= BREAKPOINTS[bp];
    },
    [dimensions.width]
  );

  const isExactBreakpoint = useCallback(
    (bp: keyof typeof BREAKPOINTS) => {
      return breakpoint === bp;
    },
    [breakpoint]
  );

  return {
    // Dimensions
    dimensions,
    breakpoint,
    
    // Responsive utilities
    responsive,
    rDimension,
    rFontSize,
    rSpacing,
    
    // Layout configurations
    layoutConfig,
    gridConfig,
    containerWidth,
    safeAreaPadding,
    
    // Animation & interaction
    animationDuration,
    touchTargetSize,
    
    // Breakpoint checks
    isBreakpoint,
    isExactBreakpoint,
    
    // Platform info
    platform: PLATFORM,
    
    // Screen state
    isLandscape: dimensions.isLandscape,
    isPortrait: dimensions.isPortrait,
    aspectRatio: dimensions.aspectRatio,
  };
};

// Hook for dynamic column calculations
export const useColumns = (
  defaultColumns: Partial<Record<keyof typeof BREAKPOINTS, number>> = {}
) => {
  const { responsive, dimensions, gridConfig } = useResponsive();
  
  const columns = responsive({
    mobile: 1,
    mobileL: 1,
    tablet: 2,
    laptop: 3,
    desktop: 4,
    desktopL: 4,
    ultraWide: 6,
    ...defaultColumns,
  });
  
  const columnWidth = useMemo(
    () => calculateColumnWidth(1, dimensions.width),
    [dimensions.width]
  );
  
  const getItemWidth = useCallback(
    (columnsToSpan: number = 1, includeGutter: boolean = true) => {
      return calculateColumnWidth(columnsToSpan, dimensions.width, includeGutter);
    },
    [dimensions.width]
  );
  
  return {
    columns,
    columnWidth,
    getItemWidth,
    gutter: gridConfig.gutter,
    margin: gridConfig.margin,
  };
};

// Hook for orientation changes
export const useOrientation = () => {
  const [orientation, setOrientation] = useState<'portrait' | 'landscape'>(
    getScreenDimensions().isPortrait ? 'portrait' : 'landscape'
  );
  
  useEffect(() => {
    const updateOrientation = ({ window }: { window: ScaledSize }) => {
      setOrientation(window.width > window.height ? 'landscape' : 'portrait');
    };
    
    const subscription = Dimensions.addEventListener('change', updateOrientation);
    return () => subscription?.remove();
  }, []);
  
  return {
    orientation,
    isPortrait: orientation === 'portrait',
    isLandscape: orientation === 'landscape',
  };
};

// Hook for screen metrics
export const useScreenMetrics = () => {
  const { dimensions, breakpoint } = useResponsive();
  const [metrics, setMetrics] = useState({
    screenWidth: dimensions.width,
    screenHeight: dimensions.height,
    windowWidth: dimensions.width,
    windowHeight: dimensions.height,
    scale: 1,
    fontScale: 1,
  });
  
  useEffect(() => {
    const screen = Dimensions.get('screen');
    const window = Dimensions.get('window');
    
    setMetrics({
      screenWidth: screen.width,
      screenHeight: screen.height,
      windowWidth: window.width,
      windowHeight: window.height,
      scale: screen.scale || 1,
      fontScale: screen.fontScale || 1,
    });
  }, [dimensions]);
  
  const density = useMemo(() => {
    const scale = metrics.scale;
    if (scale <= 1) return 'mdpi';
    if (scale <= 1.5) return 'hdpi';
    if (scale <= 2) return 'xhdpi';
    if (scale <= 3) return 'xxhdpi';
    return 'xxxhdpi';
  }, [metrics.scale]);
  
  return {
    ...metrics,
    density,
    breakpoint,
    isHighDensity: metrics.scale >= 2,
  };
};

// Hook for adaptive layouts
export const useAdaptiveLayout = () => {
  const { layoutConfig, breakpoint, dimensions } = useResponsive();
  const [layoutMode, setLayoutMode] = useState<'stack' | 'drawer' | 'tabs'>('stack');
  
  useEffect(() => {
    if (layoutConfig.sidebar) {
      setLayoutMode('drawer');
    } else if (breakpoint === 'tablet') {
      setLayoutMode('tabs');
    } else {
      setLayoutMode('stack');
    }
  }, [layoutConfig, breakpoint]);
  
  const shouldShowSidebar = layoutConfig.sidebar;
  const navigationPosition = layoutConfig.navigation;
  const isCompact = dimensions.width < BREAKPOINTS.tablet;
  const isExpanded = dimensions.width >= BREAKPOINTS.laptop;
  
  return {
    layoutMode,
    shouldShowSidebar,
    navigationPosition,
    isCompact,
    isExpanded,
    columns: layoutConfig.columns,
    cardColumns: layoutConfig.cardColumns,
    analyticsColumns: layoutConfig.analyticsColumns,
  };
};

// Hook for responsive styles
export const useResponsiveStyles = () => {
  const {
    rDimension,
    rFontSize,
    rSpacing,
    responsive,
    breakpoint,
    dimensions,
  } = useResponsive();
  
  const styles = useMemo(() => ({
    // Padding helpers
    padding: {
      xs: rSpacing(4),
      sm: rSpacing(8),
      md: rSpacing(16),
      lg: rSpacing(24),
      xl: rSpacing(32),
      xxl: rSpacing(48),
    },
    
    // Margin helpers
    margin: {
      xs: rSpacing(4),
      sm: rSpacing(8),
      md: rSpacing(16),
      lg: rSpacing(24),
      xl: rSpacing(32),
      xxl: rSpacing(48),
    },
    
    // Font size helpers
    fontSize: {
      xs: rFontSize(10),
      sm: rFontSize(12),
      md: rFontSize(14),
      lg: rFontSize(16),
      xl: rFontSize(20),
      xxl: rFontSize(24),
      xxxl: rFontSize(32),
    },
    
    // Border radius helpers
    borderRadius: {
      sm: rDimension(4),
      md: rDimension(8),
      lg: rDimension(12),
      xl: rDimension(16),
      full: 9999,
    },
    
    // Shadow helpers
    shadow: {
      sm: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: rDimension(1) },
        shadowOpacity: 0.1,
        shadowRadius: rDimension(2),
        elevation: responsive({ mobile: 2, tablet: 3, desktop: 4 }),
      },
      md: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: rDimension(2) },
        shadowOpacity: 0.15,
        shadowRadius: rDimension(4),
        elevation: responsive({ mobile: 4, tablet: 6, desktop: 8 }),
      },
      lg: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: rDimension(4) },
        shadowOpacity: 0.2,
        shadowRadius: rDimension(8),
        elevation: responsive({ mobile: 8, tablet: 12, desktop: 16 }),
      },
    },
  }), [rDimension, rFontSize, rSpacing, responsive]);
  
  return styles;
};

// Export all hooks
export default {
  useResponsive,
  useColumns,
  useOrientation,
  useScreenMetrics,
  useAdaptiveLayout,
  useResponsiveStyles,
};
</file>

<file path="src/hooks/useVisits.ts">
/**
 * Hook for managing visits with CRUD operations and statistics
 */

import { useState, useEffect, useCallback } from 'react';
import { storage, STORAGE_KEYS, StorageError } from '../services/storage';
import {
  Visit,
  Companion,
  VisitFilter,
  VisitStats,
  DateRange,
  ParkType,
  TimelineAction,
  CreateInput,
  UpdateInput,
} from '../types/models';

interface UseVisitsReturn {
  // Data
  visits: Visit[];
  companions: Companion[];
  isLoading: boolean;
  error: StorageError | null;

  // CRUD operations
  createVisit: (visit: CreateInput<Visit>) => Promise<Visit>;
  updateVisit: (id: string, updates: UpdateInput<Visit>) => Promise<Visit | null>;
  deleteVisit: (id: string) => Promise<boolean>;
  deleteAllVisits: () => Promise<boolean>;
  getVisit: (id: string) => Promise<Visit | null>;

  // Companion operations
  createCompanion: (companion: CreateInput<Companion>) => Promise<Companion>;
  updateCompanion: (id: string, updates: UpdateInput<Companion>) => Promise<Companion | null>;
  deleteCompanion: (id: string) => Promise<boolean>;

  // Query operations
  getVisitsByDateRange: (dateRange: DateRange) => Promise<Visit[]>;
  getVisitsByCompanion: (companionId: string) => Promise<Visit[]>;
  getVisitsByPark: (parkType: ParkType) => Promise<Visit[]>;
  getFilteredVisits: (filter: VisitFilter) => Promise<Visit[]>;

  // Statistics
  getVisitStatistics: (filter?: VisitFilter) => Promise<VisitStats>;
  getCompanionVisitCount: (companionId: string) => Promise<number>;

  // Utility
  refreshData: () => Promise<void>;
}

export function useVisits(): UseVisitsReturn {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [companions, setCompanions] = useState<Companion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<StorageError | null>(null);

  // Load initial data
  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      const [visitsData, companionsData] = await Promise.all([
        storage.getAll<Visit>(STORAGE_KEYS.VISITS),
        storage.getAll<Companion>(STORAGE_KEYS.COMPANIONS),
      ]);
      setVisits(visitsData);
      setCompanions(companionsData);
    } catch (err) {
      setError(err as StorageError);
      // Still set empty arrays on error
      setVisits([]);
      setCompanions([]);
    } finally {
      setIsLoading(false);
    }
  };

  // Visit CRUD operations
  const createVisit = useCallback(async (visitData: CreateInput<Visit>): Promise<Visit> => {
    try {
      const newVisit = await storage.create<Visit>(STORAGE_KEYS.VISITS, visitData);
      
      // Update companion visit IDs
      if (visitData.companionIds?.length) {
        const updates = visitData.companionIds.map(companionId => {
          const companion = companions.find(c => c.id === companionId);
          if (companion) {
            return {
              id: companionId,
              data: { visitIds: [...(companion.visitIds || []), newVisit.id] },
            };
          }
          return null;
        }).filter(Boolean) as Array<{ id: string; data: Partial<Companion> }>;

        if (updates.length > 0) {
          await storage.updateMany<Companion>(STORAGE_KEYS.COMPANIONS, updates);
        }
      }

      await loadData();
      return newVisit;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [companions]);

  const updateVisit = useCallback(async (
    id: string,
    updates: UpdateInput<Visit>
  ): Promise<Visit | null> => {
    try {
      const currentVisit = await storage.get<Visit>(STORAGE_KEYS.VISITS, id);
      if (!currentVisit) return null;

      // Handle companion changes
      if (updates.companionIds && 
          JSON.stringify(updates.companionIds) !== JSON.stringify(currentVisit.companionIds)) {
        // Remove visit ID from old companions
        const oldCompanionUpdates = currentVisit.companionIds.map(companionId => ({
          id: companionId,
          data: {
            visitIds: companions.find(c => c.id === companionId)?.visitIds.filter(vid => vid !== id) || [],
          },
        }));

        // Add visit ID to new companions
        const newCompanionUpdates = updates.companionIds
          .filter(cId => !currentVisit.companionIds.includes(cId))
          .map(companionId => {
            const companion = companions.find(c => c.id === companionId);
            return {
              id: companionId,
              data: { visitIds: [...(companion?.visitIds || []), id] },
            };
          });

        const allUpdates = [...oldCompanionUpdates, ...newCompanionUpdates];
        if (allUpdates.length > 0) {
          await storage.updateMany<Companion>(STORAGE_KEYS.COMPANIONS, allUpdates);
        }
      }

      const updatedVisit = await storage.update<Visit>(STORAGE_KEYS.VISITS, id, updates);
      await loadData();
      return updatedVisit;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [companions]);

  const deleteVisit = useCallback(async (id: string): Promise<boolean> => {
    try {
      const visit = await storage.get<Visit>(STORAGE_KEYS.VISITS, id);
      if (!visit) return false;

      // Remove visit ID from companions
      if (visit.companionIds?.length) {
        const updates = visit.companionIds.map(companionId => {
          const companion = companions.find(c => c.id === companionId);
          if (companion) {
            return {
              id: companionId,
              data: { visitIds: companion.visitIds.filter(vid => vid !== id) },
            };
          }
          return null;
        }).filter(Boolean) as Array<{ id: string; data: Partial<Companion> }>;

        if (updates.length > 0) {
          await storage.updateMany<Companion>(STORAGE_KEYS.COMPANIONS, updates);
        }
      }

      // Delete all actions for this visit
      const actions = await storage.find<TimelineAction>(
        STORAGE_KEYS.ACTIONS,
        action => action.visitId === id
      );
      if (actions.length > 0) {
        await storage.deleteMany(STORAGE_KEYS.ACTIONS, actions.map(a => a.id));
      }

      const result = await storage.delete<Visit>(STORAGE_KEYS.VISITS, id);
      await loadData();
      return result;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [companions]);

  const deleteAllVisits = useCallback(async (): Promise<boolean> => {
    try {
      // Delete all visits
      await storage.clear(STORAGE_KEYS.VISITS);
      
      // Delete all actions
      await storage.clear(STORAGE_KEYS.ACTIONS);
      
      // Clear companion visit IDs
      const allCompanions = await storage.getAll<Companion>(STORAGE_KEYS.COMPANIONS);
      if (allCompanions.length > 0) {
        const updates = allCompanions.map(companion => ({
          id: companion.id,
          data: { visitIds: [] }
        }));
        await storage.updateMany<Companion>(STORAGE_KEYS.COMPANIONS, updates);
      }
      
      await loadData();
      return true;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getVisit = useCallback(async (id: string): Promise<Visit | null> => {
    try {
      return await storage.get<Visit>(STORAGE_KEYS.VISITS, id);
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  // Companion operations
  const createCompanion = useCallback(async (
    companionData: CreateInput<Companion>
  ): Promise<Companion> => {
    try {
      const newCompanion = await storage.create<Companion>(
        STORAGE_KEYS.COMPANIONS,
        { ...companionData, visitIds: companionData.visitIds || [] }
      );
      await loadData();
      return newCompanion;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const updateCompanion = useCallback(async (
    id: string,
    updates: UpdateInput<Companion>
  ): Promise<Companion | null> => {
    try {
      const updatedCompanion = await storage.update<Companion>(
        STORAGE_KEYS.COMPANIONS,
        id,
        updates
      );
      await loadData();
      return updatedCompanion;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const deleteCompanion = useCallback(async (id: string): Promise<boolean> => {
    try {
      const companion = await storage.get<Companion>(STORAGE_KEYS.COMPANIONS, id);
      if (!companion) return false;

      // Remove companion from all visits
      if (companion.visitIds?.length) {
        const visitUpdates = companion.visitIds.map(visitId => {
          const visit = visits.find(v => v.id === visitId);
          if (visit) {
            return {
              id: visitId,
              data: { companionIds: visit.companionIds.filter(cId => cId !== id) },
            };
          }
          return null;
        }).filter(Boolean) as Array<{ id: string; data: Partial<Visit> }>;

        if (visitUpdates.length > 0) {
          await storage.updateMany<Visit>(STORAGE_KEYS.VISITS, visitUpdates);
        }
      }

      const result = await storage.delete<Companion>(STORAGE_KEYS.COMPANIONS, id);
      await loadData();
      return result;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [visits]);

  // Query operations
  const getVisitsByDateRange = useCallback(async (
    dateRange: DateRange
  ): Promise<Visit[]> => {
    try {
      return await storage.find<Visit>(
        STORAGE_KEYS.VISITS,
        visit => {
          // 日本時間での日付比較
          const jstOffset = 9 * 60; // JST is UTC+9
          const visitDate = new Date(visit.date);
          const visitDateJST = new Date(visitDate.getTime() + (jstOffset * 60 * 1000));
          const startDateJST = new Date(dateRange.startDate.getTime() + (jstOffset * 60 * 1000));
          const endDateJST = new Date(dateRange.endDate.getTime() + (jstOffset * 60 * 1000));
          
          return visitDateJST >= startDateJST && visitDateJST <= endDateJST;
        }
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getVisitsByCompanion = useCallback(async (companionId: string): Promise<Visit[]> => {
    try {
      return await storage.find<Visit>(
        STORAGE_KEYS.VISITS,
        visit => visit.companionIds.includes(companionId)
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getVisitsByPark = useCallback(async (parkType: ParkType): Promise<Visit[]> => {
    try {
      return await storage.find<Visit>(
        STORAGE_KEYS.VISITS,
        visit => visit.parkType === parkType
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const getFilteredVisits = useCallback(async (filter: VisitFilter): Promise<Visit[]> => {
    try {
      return await storage.find<Visit>(
        STORAGE_KEYS.VISITS,
        visit => {
          if (filter.parkType && visit.parkType !== filter.parkType) return false;
          
          if (filter.dateRange) {
            // 日本時間での日付比較
            const jstOffset = 9 * 60; // JST is UTC+9
            const visitDate = new Date(visit.date);
            const visitDateJST = new Date(visitDate.getTime() + (jstOffset * 60 * 1000));
            const startDateJST = new Date(filter.dateRange.startDate.getTime() + (jstOffset * 60 * 1000));
            const endDateJST = new Date(filter.dateRange.endDate.getTime() + (jstOffset * 60 * 1000));
            
            if (visitDateJST < startDateJST || visitDateJST > endDateJST) {
              return false;
            }
          }
          
          if (filter.companionIds?.length) {
            const hasCompanion = filter.companionIds.some(cId => 
              visit.companionIds.includes(cId)
            );
            if (!hasCompanion) return false;
          }
          
          return true;
        }
      );
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  // Statistics
  const getVisitStatistics = useCallback(async (
    filter?: VisitFilter
  ): Promise<VisitStats> => {
    try {
      const filteredVisits = filter 
        ? await getFilteredVisits(filter)
        : await storage.getAll<Visit>(STORAGE_KEYS.VISITS);

      const landVisits = filteredVisits.filter(v => v.parkType === ParkType.LAND);
      const seaVisits = filteredVisits.filter(v => v.parkType === ParkType.SEA);

      // Calculate average visit duration
      let totalDuration = 0;
      let durationCount = 0;
      filteredVisits.forEach(visit => {
        if (visit.startTime && visit.endTime) {
          const duration = new Date(visit.endTime).getTime() - new Date(visit.startTime).getTime();
          totalDuration += duration;
          durationCount++;
        }
      });
      const averageVisitDuration = durationCount > 0 
        ? totalDuration / durationCount / (1000 * 60) // Convert to minutes
        : undefined;

      // Calculate companion statistics
      const companionStats = new Map<string, number>();
      filteredVisits.forEach(visit => {
        visit.companionIds.forEach(companionId => {
          companionStats.set(companionId, (companionStats.get(companionId) || 0) + 1);
        });
      });

      const favoriteCompanions = await Promise.all(
        Array.from(companionStats.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5)
          .map(async ([companionId, count]) => {
            const companion = await storage.get<Companion>(STORAGE_KEYS.COMPANIONS, companionId);
            return companion ? { companion, visitCount: count } : null;
          })
      ).then(results => results.filter(Boolean) as Array<{ companion: Companion; visitCount: number }>);

      // Calculate visits by month
      const visitsByMonthMap = new Map<string, number>();
      filteredVisits.forEach(visit => {
        const date = new Date(visit.date);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        visitsByMonthMap.set(monthKey, (visitsByMonthMap.get(monthKey) || 0) + 1);
      });
      const visitsByMonth = Array.from(visitsByMonthMap.entries())
        .map(([month, count]) => ({ month, count }))
        .sort((a, b) => a.month.localeCompare(b.month));

      // Calculate visits by year
      const visitsByYearMap = new Map<number, number>();
      filteredVisits.forEach(visit => {
        const year = new Date(visit.date).getFullYear();
        visitsByYearMap.set(year, (visitsByYearMap.get(year) || 0) + 1);
      });
      const visitsByYear = Array.from(visitsByYearMap.entries())
        .map(([year, count]) => ({ year, count }))
        .sort((a, b) => a.year - b.year);

      return {
        totalVisits: filteredVisits.length,
        landVisits: landVisits.length,
        seaVisits: seaVisits.length,
        averageVisitDuration,
        favoriteCompanions,
        visitsByMonth,
        visitsByYear,
      };
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, [getFilteredVisits]);

  const getCompanionVisitCount = useCallback(async (companionId: string): Promise<number> => {
    try {
      const companion = await storage.get<Companion>(STORAGE_KEYS.COMPANIONS, companionId);
      return companion?.visitIds.length || 0;
    } catch (err) {
      setError(err as StorageError);
      throw err;
    }
  }, []);

  const refreshData = useCallback(async () => {
    await loadData();
  }, []);

  return {
    // Data
    visits,
    companions,
    isLoading,
    error,

    // CRUD operations
    createVisit,
    updateVisit,
    deleteVisit,
    deleteAllVisits,
    getVisit,

    // Companion operations
    createCompanion,
    updateCompanion,
    deleteCompanion,

    // Query operations
    getVisitsByDateRange,
    getVisitsByCompanion,
    getVisitsByPark,
    getFilteredVisits,

    // Statistics
    getVisitStatistics,
    getCompanionVisitCount,

    // Utility
    refreshData,
  };
}
</file>

<file path="src/mocks/expo-screen-capture-mock.js">
// Mock implementation of expo-screen-capture to avoid permission issues
export function usePreventScreenCapture() {
  // No-op
}

export function addScreenshotListener(listener) {
  // Return a no-op subscription
  return {
    remove: () => {}
  };
}

export function removeScreenshotListener(subscription) {
  // No-op
}

export function allowScreenCaptureAsync() {
  return Promise.resolve();
}

export function preventScreenCaptureAsync() {
  return Promise.resolve();
}

export function isAvailableAsync() {
  return Promise.resolve(false);
}

// Default export
export default {
  usePreventScreenCapture,
  addScreenshotListener,
  removeScreenshotListener,
  allowScreenCaptureAsync,
  preventScreenCaptureAsync,
  isAvailableAsync
};
</file>

<file path="src/navigation/index.ts">
// Export all navigation components from a single point
export { AppNavigator } from './AppNavigator';
export { TabNavigator } from './TabNavigator';
export { DrawerNavigator } from './DrawerNavigator';
</file>

<file path="src/services/photoService.ts">
// import * as ImageManipulator from 'expo-image-manipulator'; // Removed dependency
import * as FileSystem from 'expo-file-system';
// import * as MediaLibrary from 'expo-media-library'; // Removed dependency
import * as ImagePicker from 'expo-image-picker';
import { Platform } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Photo-related types
export interface PhotoMetadata {
  id: string;
  uri: string;
  thumbnailUri?: string;
  width: number;
  height: number;
  takenAt: Date;
  location?: {
    latitude: number;
    longitude: number;
    altitude?: number;
  };
  exif?: {
    make?: string;
    model?: string;
    iso?: number;
    aperture?: number;
    exposureTime?: number;
    focalLength?: number;
    flash?: boolean;
    orientation?: number;
  };
  size: number; // File size in bytes
  mimeType: string;
  caption?: string;
  tags?: string[];
  album?: string;
  isFavorite?: boolean;
  editHistory?: PhotoEdit[];
}

export interface PhotoEdit {
  id: string;
  type: 'crop' | 'filter' | 'brightness' | 'contrast' | 'saturation' | 'rotation';
  params: any;
  timestamp: Date;
}

export interface PhotoFilter {
  id: string;
  name: string;
  matrix: number[];
}

export interface PhotoCompressionOptions {
  quality?: number; // 0-1
  maxWidth?: number;
  maxHeight?: number;
  format?: 'jpeg' | 'png';
  keepAspectRatio?: boolean;
}

export interface PhotoOrganizationOptions {
  groupBy?: 'date' | 'location' | 'album' | 'tags';
  sortBy?: 'date' | 'name' | 'size' | 'favorites';
  sortOrder?: 'asc' | 'desc';
}

// Cache configuration
const CACHE_KEY_PREFIX = 'photo_cache_';
const THUMBNAIL_CACHE_PREFIX = 'thumb_cache_';
const METADATA_CACHE_PREFIX = 'meta_cache_';
const CACHE_EXPIRY_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

// Photo filters
export const PHOTO_FILTERS: PhotoFilter[] = [
  {
    id: 'original',
    name: 'Original',
    matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
  },
  {
    id: 'grayscale',
    name: 'Grayscale',
    matrix: [0.299, 0.587, 0.114, 0, 0, 0.299, 0.587, 0.114, 0, 0, 0.299, 0.587, 0.114, 0, 0, 0, 0, 0, 1, 0],
  },
  {
    id: 'sepia',
    name: 'Sepia',
    matrix: [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0],
  },
  {
    id: 'vintage',
    name: 'Vintage',
    matrix: [0.5, 0.5, 0.1, 0, 0, 0.3, 0.5, 0.1, 0, 0, 0.1, 0.3, 0.5, 0, 0, 0, 0, 0, 1, 0],
  },
  {
    id: 'cold',
    name: 'Cold',
    matrix: [1, 0, 0, 0, 0, 0, 1, 0.1, 0, 0, 0, 0.1, 1.2, 0, 0, 0, 0, 0, 1, 0],
  },
  {
    id: 'warm',
    name: 'Warm',
    matrix: [1.2, 0.1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
  },
  {
    id: 'contrast',
    name: 'High Contrast',
    matrix: [1.5, 0, 0, 0, -0.25, 0, 1.5, 0, 0, -0.25, 0, 0, 1.5, 0, -0.25, 0, 0, 0, 1, 0],
  },
];

class PhotoService {
  private cacheDir: string;
  private thumbnailDir: string;

  constructor() {
    this.cacheDir = `${FileSystem.cacheDirectory}photos/`;
    this.thumbnailDir = `${FileSystem.cacheDirectory}thumbnails/`;
    this.initializeDirectories();
  }

  private async initializeDirectories() {
    try {
      await FileSystem.makeDirectoryAsync(this.cacheDir, { intermediates: true });
      await FileSystem.makeDirectoryAsync(this.thumbnailDir, { intermediates: true });
    } catch (error) {
      console.error('Failed to initialize photo directories:', error);
    }
  }

  // Photo compression and optimization
  async compressPhoto(uri: string, options: PhotoCompressionOptions = {}): Promise<string> {
    const {
      quality = 0.8,
      maxWidth = 1920,
      maxHeight = 1920,
      format = 'jpeg',
      keepAspectRatio = true,
    } = options;

    try {
      // Note: Image compression is not available without expo-image-manipulator
      // Returning original URI for now
      console.log('Compression would be applied with options:', { quality, maxWidth, maxHeight, format, keepAspectRatio });
      return uri;
    } catch (error) {
      console.error('Photo compression failed:', error);
      throw error;
    }
  }

  // Generate thumbnail
  async generateThumbnail(uri: string, size: number = 200): Promise<string> {
    const cacheKey = `${THUMBNAIL_CACHE_PREFIX}${size}_${this.getFileNameFromUri(uri)}`;
    
    // Check cache first
    const cachedThumbnail = await this.getCachedItem(cacheKey);
    if (cachedThumbnail) {
      return cachedThumbnail;
    }

    try {
      // Note: Thumbnail generation is not available without expo-image-manipulator
      // Returning original URI for now
      console.log('Thumbnail would be generated with size:', size);
      
      // Cache the original URI
      await this.setCachedItem(cacheKey, uri);
      
      return uri;
    } catch (error) {
      console.error('Thumbnail generation failed:', error);
      return uri; // Return original URI as fallback
    }
  }

  // Extract EXIF data
  async extractExifData(uri: string): Promise<PhotoMetadata['exif'] | undefined> {
    try {
      // Note: Expo doesn't provide direct EXIF reading, so we'll use ImagePicker's exif option
      // This is a placeholder for demonstration
      // In a real implementation, you might use a native module or server-side processing
      return {
        make: 'Unknown',
        model: 'Unknown',
        iso: undefined,
        aperture: undefined,
        exposureTime: undefined,
        focalLength: undefined,
        flash: false,
        orientation: 1,
      };
    } catch (error) {
      console.error('EXIF extraction failed:', error);
      return undefined;
    }
  }

  // Extract location from photo
  async extractLocation(uri: string): Promise<PhotoMetadata['location'] | undefined> {
    try {
      // This is a placeholder - actual implementation would require native modules
      // or server-side processing to extract GPS EXIF data
      return undefined;
    } catch (error) {
      console.error('Location extraction failed:', error);
      return undefined;
    }
  }

  // Apply photo filter
  async applyFilter(uri: string, filter: PhotoFilter): Promise<string> {
    if (filter.id === 'original') {
      return uri;
    }

    try {
      // Note: Filter application is not available without expo-image-manipulator
      // This would require a custom native module or server-side processing
      console.log('Filter would be applied:', filter.name);
      return uri;
    } catch (error) {
      console.error('Filter application failed:', error);
      throw error;
    }
  }

  // Adjust photo brightness
  async adjustBrightness(uri: string, brightness: number): Promise<string> {
    try {
      // Brightness should be between -1 and 1
      const adjustedBrightness = Math.max(-1, Math.min(1, brightness));
      
      // Note: Expo Image Manipulator doesn't support brightness adjustment directly
      // This would require a custom implementation
      return uri;
    } catch (error) {
      console.error('Brightness adjustment failed:', error);
      throw error;
    }
  }

  // Crop photo
  async cropPhoto(
    uri: string,
    cropData: { originX: number; originY: number; width: number; height: number }
  ): Promise<string> {
    try {
      // Note: Cropping is not available without expo-image-manipulator
      console.log('Crop would be applied with data:', cropData);
      return uri;
    } catch (error) {
      console.error('Photo crop failed:', error);
      throw error;
    }
  }

  // Rotate photo
  async rotatePhoto(uri: string, degrees: number): Promise<string> {
    try {
      // Note: Rotation is not available without expo-image-manipulator
      console.log('Rotation would be applied with degrees:', degrees);
      return uri;
    } catch (error) {
      console.error('Photo rotation failed:', error);
      throw error;
    }
  }

  // Batch process photos
  async batchProcess(
    uris: string[],
    processFunc: (uri: string) => Promise<string>,
    onProgress?: (current: number, total: number) => void
  ): Promise<string[]> {
    const results: string[] = [];
    const total = uris.length;

    for (let i = 0; i < total; i++) {
      try {
        const result = await processFunc(uris[i]);
        results.push(result);
        
        if (onProgress) {
          onProgress(i + 1, total);
        }
      } catch (error) {
        console.error(`Batch processing failed for photo ${i}:`, error);
        results.push(uris[i]); // Use original on failure
      }
    }

    return results;
  }

  // Organize photos by criteria
  async organizePhotos(
    photos: PhotoMetadata[],
    options: PhotoOrganizationOptions = {}
  ): Promise<Map<string, PhotoMetadata[]>> {
    const { groupBy = 'date', sortBy = 'date', sortOrder = 'desc' } = options;
    
    // Sort photos
    const sortedPhotos = [...photos].sort((a, b) => {
      let compareValue = 0;
      
      switch (sortBy) {
        case 'date':
          compareValue = a.takenAt.getTime() - b.takenAt.getTime();
          break;
        case 'name':
          compareValue = a.id.localeCompare(b.id);
          break;
        case 'size':
          compareValue = a.size - b.size;
          break;
        case 'favorites':
          compareValue = (a.isFavorite ? 1 : 0) - (b.isFavorite ? 1 : 0);
          break;
      }
      
      return sortOrder === 'asc' ? compareValue : -compareValue;
    });

    // Group photos
    const grouped = new Map<string, PhotoMetadata[]>();
    
    sortedPhotos.forEach(photo => {
      let key: string;
      
      switch (groupBy) {
        case 'date':
          key = photo.takenAt.toDateString();
          break;
        case 'location':
          key = photo.location 
            ? `${photo.location.latitude.toFixed(2)},${photo.location.longitude.toFixed(2)}`
            : 'No Location';
          break;
        case 'album':
          key = photo.album || 'Uncategorized';
          break;
        case 'tags':
          key = photo.tags?.join(', ') || 'No Tags';
          break;
        default:
          key = 'All Photos';
      }
      
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key)!.push(photo);
    });

    return grouped;
  }

  // Auto-categorize photos using basic heuristics
  async autoCategorizePhoto(metadata: PhotoMetadata): Promise<string[]> {
    const categories: string[] = [];
    
    // Time-based categories
    const hour = metadata.takenAt.getHours();
    if (hour >= 5 && hour < 12) {
      categories.push('morning');
    } else if (hour >= 12 && hour < 17) {
      categories.push('afternoon');
    } else if (hour >= 17 && hour < 21) {
      categories.push('evening');
    } else {
      categories.push('night');
    }
    
    // Size-based categories
    if (metadata.width > metadata.height * 1.5) {
      categories.push('landscape');
    } else if (metadata.height > metadata.width * 1.5) {
      categories.push('portrait');
    } else {
      categories.push('square');
    }
    
    // Location-based categories (if available)
    if (metadata.location) {
      categories.push('geotagged');
    }
    
    return categories;
  }

  // Cache management
  private async getCachedItem(key: string): Promise<string | null> {
    try {
      const cached = await AsyncStorage.getItem(key);
      if (cached) {
        const { uri, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp < CACHE_EXPIRY_MS) {
          return uri;
        }
        // Remove expired cache
        await AsyncStorage.removeItem(key);
      }
    } catch (error) {
      console.error('Cache retrieval failed:', error);
    }
    return null;
  }

  private async setCachedItem(key: string, uri: string): Promise<void> {
    try {
      await AsyncStorage.setItem(
        key,
        JSON.stringify({
          uri,
          timestamp: Date.now(),
        })
      );
    } catch (error) {
      console.error('Cache storage failed:', error);
    }
  }

  async clearCache(): Promise<void> {
    try {
      // Clear AsyncStorage cache
      const keys = await AsyncStorage.getAllKeys();
      const cacheKeys = keys.filter(key => 
        key.startsWith(CACHE_KEY_PREFIX) || 
        key.startsWith(THUMBNAIL_CACHE_PREFIX) || 
        key.startsWith(METADATA_CACHE_PREFIX)
      );
      await AsyncStorage.multiRemove(cacheKeys);
      
      // Clear file system cache
      await FileSystem.deleteAsync(this.cacheDir, { idempotent: true });
      await FileSystem.deleteAsync(this.thumbnailDir, { idempotent: true });
      
      // Recreate directories
      await this.initializeDirectories();
    } catch (error) {
      console.error('Cache clearing failed:', error);
    }
  }

  async getCacheSize(): Promise<number> {
    try {
      const cacheInfo = await FileSystem.getInfoAsync(this.cacheDir);
      const thumbnailInfo = await FileSystem.getInfoAsync(this.thumbnailDir);
      
      let totalSize = 0;
      if (cacheInfo.exists && cacheInfo.size) {
        totalSize += cacheInfo.size;
      }
      if (thumbnailInfo.exists && thumbnailInfo.size) {
        totalSize += thumbnailInfo.size;
      }
      
      return totalSize;
    } catch (error) {
      console.error('Failed to get cache size:', error);
      return 0;
    }
  }

  // Helper methods
  private getFileNameFromUri(uri: string): string {
    return uri.split('/').pop() || `photo_${Date.now()}`;
  }

  generatePhotoId(): string {
    return `photo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  async getPhotoInfo(uri: string): Promise<{ width: number; height: number; size: number }> {
    try {
      const fileInfo = await FileSystem.getInfoAsync(uri);
      
      // Note: Getting image dimensions would require additional implementation
      // Using placeholder values for demonstration
      return {
        width: 1920,
        height: 1080,
        size: fileInfo.exists && fileInfo.size ? fileInfo.size : 0,
      };
    } catch (error) {
      console.error('Failed to get photo info:', error);
      return { width: 0, height: 0, size: 0 };
    }
  }
}

export const photoService = new PhotoService();
</file>

<file path="src/services/storage.ts">
/**
 * AsyncStorage wrapper with type safety and error handling
 * Supports future Rails backend sync
 */

import AsyncStorage from '@react-native-async-storage/async-storage';
import { BaseModel, DataMigration, AppMetadata } from '../types/models';

// Storage key prefixes
const STORAGE_KEYS = {
  VISITS: '@tdr_days:visits',
  ACTIONS: '@tdr_days:actions',
  COMPANIONS: '@tdr_days:companions',
  METADATA: '@tdr_days:metadata',
  MIGRATIONS: '@tdr_days:migrations',
} as const;

// Error types
export class StorageError extends Error {
  constructor(message: string, public code: string, public originalError?: Error) {
    super(message);
    this.name = 'StorageError';
  }
}

// Storage service class
export class StorageService {
  private static instance: StorageService;

  private constructor() {}

  static getInstance(): StorageService {
    if (!StorageService.instance) {
      StorageService.instance = new StorageService();
    }
    return StorageService.instance;
  }

  // Generic CRUD operations
  async get<T extends BaseModel>(key: string, id: string): Promise<T | null> {
    try {
      const data = await this.getAll<T>(key);
      return data.find(item => item.id === id) || null;
    } catch (error) {
      throw new StorageError(
        `Failed to get item with id: ${id}`,
        'GET_ERROR',
        error as Error
      );
    }
  }

  async getAll<T extends BaseModel>(key: string): Promise<T[]> {
    try {
      const jsonData = await AsyncStorage.getItem(key);
      if (!jsonData) return [];
      
      const data = JSON.parse(jsonData);
      // Convert date strings back to Date objects
      return this.deserializeDates(data);
    } catch (error) {
      throw new StorageError(
        'Failed to get all items',
        'GET_ALL_ERROR',
        error as Error
      );
    }
  }

  async create<T extends BaseModel>(
    key: string,
    item: Omit<T, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<T> {
    try {
      const now = new Date();
      const newItem = {
        ...item,
        id: this.generateId(),
        createdAt: now,
        updatedAt: now,
      } as T;

      const data = await this.getAll<T>(key);
      data.push(newItem);
      await this.saveAll(key, data);

      return newItem;
    } catch (error) {
      throw new StorageError(
        'Failed to create item',
        'CREATE_ERROR',
        error as Error
      );
    }
  }

  async update<T extends BaseModel>(
    key: string,
    id: string,
    updates: Partial<Omit<T, 'id' | 'createdAt'>>
  ): Promise<T | null> {
    try {
      const data = await this.getAll<T>(key);
      const index = data.findIndex(item => item.id === id);
      
      if (index === -1) return null;

      const updatedItem = {
        ...data[index],
        ...updates,
        updatedAt: new Date(),
      } as T;

      data[index] = updatedItem;
      await this.saveAll(key, data);

      return updatedItem;
    } catch (error) {
      throw new StorageError(
        `Failed to update item with id: ${id}`,
        'UPDATE_ERROR',
        error as Error
      );
    }
  }

  async delete<T extends BaseModel>(key: string, id: string): Promise<boolean> {
    try {
      const data = await this.getAll<T>(key);
      const filteredData = data.filter(item => item.id !== id);
      
      if (data.length === filteredData.length) return false;

      await this.saveAll(key, filteredData);
      return true;
    } catch (error) {
      throw new StorageError(
        `Failed to delete item with id: ${id}`,
        'DELETE_ERROR',
        error as Error
      );
    }
  }

  // Batch operations
  async createMany<T extends BaseModel>(
    key: string,
    items: Array<Omit<T, 'id' | 'createdAt' | 'updatedAt'>>
  ): Promise<T[]> {
    try {
      const now = new Date();
      const newItems = items.map(item => ({
        ...item,
        id: this.generateId(),
        createdAt: now,
        updatedAt: now,
      })) as T[];

      const data = await this.getAll<T>(key);
      data.push(...newItems);
      await this.saveAll(key, data);

      return newItems;
    } catch (error) {
      throw new StorageError(
        'Failed to create multiple items',
        'CREATE_MANY_ERROR',
        error as Error
      );
    }
  }

  async updateMany<T extends BaseModel>(
    key: string,
    updates: Array<{ id: string; data: Partial<Omit<T, 'id' | 'createdAt'>> }>
  ): Promise<T[]> {
    try {
      const data = await this.getAll<T>(key);
      const updatedItems: T[] = [];
      const now = new Date();

      updates.forEach(({ id, data: updateData }) => {
        const index = data.findIndex(item => item.id === id);
        if (index !== -1) {
          data[index] = {
            ...data[index],
            ...updateData,
            updatedAt: now,
          } as T;
          updatedItems.push(data[index]);
        }
      });

      await this.saveAll(key, data);
      return updatedItems;
    } catch (error) {
      throw new StorageError(
        'Failed to update multiple items',
        'UPDATE_MANY_ERROR',
        error as Error
      );
    }
  }

  async deleteMany<T extends BaseModel>(key: string, ids: string[]): Promise<number> {
    try {
      const data = await this.getAll<T>(key);
      const originalLength = data.length;
      const filteredData = data.filter(item => !ids.includes(item.id));
      
      await this.saveAll(key, filteredData);
      return originalLength - filteredData.length;
    } catch (error) {
      throw new StorageError(
        'Failed to delete multiple items',
        'DELETE_MANY_ERROR',
        error as Error
      );
    }
  }

  // Query operations
  async find<T extends BaseModel>(
    key: string,
    predicate: (item: T) => boolean
  ): Promise<T[]> {
    try {
      const data = await this.getAll<T>(key);
      return data.filter(predicate);
    } catch (error) {
      throw new StorageError(
        'Failed to find items',
        'FIND_ERROR',
        error as Error
      );
    }
  }

  async findOne<T extends BaseModel>(
    key: string,
    predicate: (item: T) => boolean
  ): Promise<T | null> {
    try {
      const data = await this.getAll<T>(key);
      return data.find(predicate) || null;
    } catch (error) {
      throw new StorageError(
        'Failed to find item',
        'FIND_ONE_ERROR',
        error as Error
      );
    }
  }

  // Clear operations
  async clear(key: string): Promise<void> {
    try {
      await AsyncStorage.removeItem(key);
    } catch (error) {
      throw new StorageError(
        `Failed to clear storage for key: ${key}`,
        'CLEAR_ERROR',
        error as Error
      );
    }
  }

  async clearAll(): Promise<void> {
    try {
      const keys = Object.values(STORAGE_KEYS);
      await AsyncStorage.multiRemove(keys);
    } catch (error) {
      throw new StorageError(
        'Failed to clear all storage',
        'CLEAR_ALL_ERROR',
        error as Error
      );
    }
  }

  // Migration support
  async getDataVersion(): Promise<number> {
    try {
      const metadata = await this.getMetadata();
      return metadata?.dataVersion || 1;
    } catch (error) {
      return 1;
    }
  }

  async setDataVersion(version: number): Promise<void> {
    try {
      const metadata = await this.getMetadata();
      if (metadata) {
        await this.update(STORAGE_KEYS.METADATA, metadata.id, { dataVersion: version });
      } else {
        await this.create(STORAGE_KEYS.METADATA, {
          dataVersion: version,
          settings: {},
        } as Omit<AppMetadata, 'id' | 'createdAt' | 'updatedAt'>);
      }
    } catch (error) {
      throw new StorageError(
        'Failed to set data version',
        'SET_VERSION_ERROR',
        error as Error
      );
    }
  }

  async getMigrations(): Promise<DataMigration[]> {
    try {
      const jsonData = await AsyncStorage.getItem(STORAGE_KEYS.MIGRATIONS);
      if (!jsonData) return [];
      return JSON.parse(jsonData);
    } catch (error) {
      throw new StorageError(
        'Failed to get migrations',
        'GET_MIGRATIONS_ERROR',
        error as Error
      );
    }
  }

  async addMigration(migration: DataMigration): Promise<void> {
    try {
      const migrations = await this.getMigrations();
      migrations.push(migration);
      await AsyncStorage.setItem(STORAGE_KEYS.MIGRATIONS, JSON.stringify(migrations));
    } catch (error) {
      throw new StorageError(
        'Failed to add migration',
        'ADD_MIGRATION_ERROR',
        error as Error
      );
    }
  }

  // Export/Import support for future sync
  async exportData(): Promise<Record<string, any>> {
    try {
      const keys = Object.values(STORAGE_KEYS);
      const data: Record<string, any> = {};

      for (const key of keys) {
        const value = await AsyncStorage.getItem(key);
        if (value) {
          data[key] = JSON.parse(value);
        }
      }

      return data;
    } catch (error) {
      throw new StorageError(
        'Failed to export data',
        'EXPORT_ERROR',
        error as Error
      );
    }
  }

  async importData(data: Record<string, any>): Promise<void> {
    try {
      const entries = Object.entries(data).map(([key, value]) => [
        key,
        JSON.stringify(value),
      ]);
      await AsyncStorage.multiSet(entries);
    } catch (error) {
      throw new StorageError(
        'Failed to import data',
        'IMPORT_ERROR',
        error as Error
      );
    }
  }

  // Private helper methods
  private async saveAll<T>(key: string, data: T[]): Promise<void> {
    try {
      const jsonData = JSON.stringify(data);
      await AsyncStorage.setItem(key, jsonData);
    } catch (error) {
      throw new StorageError(
        'Failed to save data',
        'SAVE_ERROR',
        error as Error
      );
    }
  }

  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private async getMetadata(): Promise<AppMetadata | null> {
    const metadataList = await this.getAll<AppMetadata>(STORAGE_KEYS.METADATA);
    return metadataList[0] || null;
  }

  private deserializeDates<T>(data: T[]): T[] {
    return data.map(item => {
      const newItem = { ...item };
      
      // List of fields that should be converted to Date
      const dateFields = ['createdAt', 'updatedAt', 'syncedAt', 'date', 'time', 'startTime', 'endTime', 'takenAt', 'lastVisitDate'];
      
      Object.keys(newItem as any).forEach(key => {
        if (dateFields.includes(key) && (newItem as any)[key]) {
          (newItem as any)[key] = new Date((newItem as any)[key]);
        }
      });

      return newItem;
    });
  }
}

// Export singleton instance
export const storage = StorageService.getInstance();

// Export storage keys for direct access if needed
export { STORAGE_KEYS };
</file>

<file path="src/styles/colors.ts">
// Clean White-Based Design System
// Elegant, fresh, and user-friendly color palette

export const colors = {
  // Primary Purple Spectrum - Refined for clean white design
  purple: {
    50: '#fefefe',
    100: '#faf8ff',
    200: '#f4f0ff',
    300: '#e8d8ff',
    400: '#d1b3ff',
    500: '#9333ea', // Primary - More vibrant for white backgrounds
    600: '#7c3aed',
    700: '#6d28d9',
    800: '#5b21b6',
    900: '#4c1d95',
    950: '#3730a3',
    
    // Fresh Purple Variants
    soft: '#a78bfa',
    bright: '#8b5cf6',
    vivid: '#7c3aed',
  },
  
  // Clean Fresh Gradients - Perfect for white-based design
  gradients: {
    // Subtle Primary Gradients
    purpleFlow: 'linear-gradient(135deg, #8b5cf6 0%, #9333ea 100%)',
    purpleLight: 'linear-gradient(135deg, #f4f0ff 0%, #e8d8ff 100%)',
    purpleSoft: 'linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%)',
    
    // Multi-color Fresh Gradients
    fresh: 'linear-gradient(135deg, #8b5cf6 0%, #06b6d4 50%, #10b981 100%)',
    vibrant: 'linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #f59e0b 100%)',
    sunset: 'linear-gradient(135deg, #f59e0b 0%, #f97316 50%, #ec4899 100%)',
    
    // Gentle Card Gradients
    card: 'linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%)',
    cardHover: 'linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 246, 255, 0.8) 100%)',
    
    // Accent Gradients
    success: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)',
    warning: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
    error: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
    info: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
    
    // Glass Morphism for white backgrounds
    glass: 'linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 100%)',
    glassTinted: 'linear-gradient(135deg, rgba(139, 92, 246, 0.05) 0%, rgba(255, 255, 255, 0.1) 100%)',
  },
  
  // Vibrant Color Palettes - Optimized for white backgrounds
  orange: {
    50: '#fffbf7',
    100: '#fff3e6',
    200: '#ffe4c7',
    300: '#ffd19c',
    400: '#ffb366',
    500: '#f97316', // Bright and clear on white
    600: '#ea580c',
    700: '#dc2626',
    800: '#c2410c',
    900: '#9a3412',
    bright: '#ff8c42',
  },
  
  pink: {
    50: '#fdf8fc',
    100: '#fceff7',
    200: '#f8d7eb',
    300: '#f3b8d9',
    400: '#ec8cc8',
    500: '#ec4899', // Vibrant pink for contrast
    600: '#db2777',
    700: '#be185d',
    800: '#9d174d',
    900: '#831843',
    bright: '#ff6bb3',
  },
  
  yellow: {
    50: '#fffef7',
    100: '#fefce8',
    200: '#fef9c3',
    300: '#fef08a',
    400: '#facc15',
    500: '#eab308', // Warm golden yellow
    600: '#ca8a04',
    700: '#a16207',
    800: '#854d0e',
    900: '#713f12',
    bright: '#fbbf24',
  },
  
  green: {
    50: '#f7fcf9',
    100: '#ecfdf5',
    200: '#d1fae5',
    300: '#a7f3d0',
    400: '#6ee7b7',
    500: '#10b981', // Fresh green for vitality
    600: '#059669',
    700: '#047857',
    800: '#065f46',
    900: '#064e3b',
    bright: '#34d399',
  },

  blue: {
    50: '#f0f9ff',
    100: '#e0f2fe',
    200: '#bae6fd',
    300: '#7dd3fc',
    400: '#38bdf8',
    500: '#0ea5e9', // Clear sky blue
    600: '#0284c7',
    700: '#0369a1',
    800: '#075985',
    900: '#0c4a6e',
    bright: '#06b6d4',
  },

  red: {
    50: '#fef8f8',
    100: '#fef2f2',
    200: '#fecaca',
    300: '#fca5a5',
    400: '#f87171',
    500: '#ef4444', // Clear error red
    600: '#dc2626',
    700: '#b91c1c',
    800: '#991b1b',
    900: '#7f1d1d',
    bright: '#f56565',
  },

  teal: {
    50: '#f0fdfa',
    100: '#ccfbf1',
    200: '#99f6e4',
    300: '#5eead4',
    400: '#2dd4bf',
    500: '#14b8a6', // Ocean teal
    600: '#0d9488',
    700: '#0f766e',
    800: '#115e59',
    900: '#134e4a',
    bright: '#20d9bd',
  },

  amber: {
    50: '#fffbeb',
    100: '#fef3c7',
    200: '#fde68a',
    300: '#fcd34d',
    400: '#fbbf24',
    500: '#f59e0b',
    600: '#d97706',
    700: '#b45309',
    800: '#92400e',
    900: '#78350f',
    bright: '#fbbf24',
  },

  cyan: {
    50: '#ecfeff',
    100: '#cffafe',
    200: '#a5f3fc',
    300: '#67e8f9',
    400: '#22d3ee',
    500: '#06b6d4',
    600: '#0891b2',
    700: '#0e7490',
    800: '#155e75',
    900: '#164e63',
    bright: '#22d3ee',
  },

  indigo: {
    50: '#eef2ff',
    100: '#e0e7ff',
    200: '#c7d2fe',
    300: '#a5b4fc',
    400: '#818cf8',
    500: '#6366f1',
    600: '#4f46e5',
    700: '#4338ca',
    800: '#3730a3',
    900: '#312e81',
    bright: '#818cf8',
  },
  
  gray: {
    50: '#fdfdfd',
    100: '#f8fafc',
    200: '#f1f5f9',
    300: '#e2e8f0',
    400: '#cbd5e1',
    500: '#94a3b8', // Softer gray for white backgrounds
    600: '#64748b',
    700: '#475569',
    800: '#334155',
    900: '#1e293b',
    light: '#f8fafc',
  },

  // Fresh Accent Colors - Perfect for white backgrounds
  accent: {
    // Vibrant Accents
    coral: '#ff6b6b',
    mint: '#20d9bd',
    sunshine: '#fbbf24',
    lavender: '#a78bfa',
    
    // Soft Pastels
    peach: '#ffa8a8',
    seafoam: '#81e6d9',
    lemon: '#fed7aa',
    periwinkle: '#c7d2fe',
    
    // Natural Tones
    sage: '#68d391',
    rose: '#f687b3',
    sky: '#7dd3fc',
    warm: '#f6ad55',
  },
  
  // Semantic Colors - Clean and accessible
  semantic: {
    success: {
      light: '#a7f3d0',
      main: '#10b981',
      dark: '#059669',
      background: '#ecfdf5',
      border: '#6ee7b7',
    },
    error: {
      light: '#fecaca',
      main: '#ef4444',
      dark: '#dc2626',
      background: '#fef2f2',
      border: '#f87171',
    },
    warning: {
      light: '#fed7aa',
      main: '#f59e0b',
      dark: '#d97706',
      background: '#fffbeb',
      border: '#fbbf24',
    },
    info: {
      light: '#bae6fd',
      main: '#0ea5e9',
      dark: '#0284c7',
      background: '#f0f9ff',
      border: '#38bdf8',
    },
  },
  
  // Background Colors - Clean white-based design
  background: {
    // Primary white-based backgrounds
    primary: '#ffffff',
    secondary: '#fdfdfd',
    tertiary: '#f8fafc',
    elevated: '#ffffff',
    overlay: 'rgba(255, 255, 255, 0.95)',
    
    // Card and Component Backgrounds
    card: '#ffffff',
    cardHover: '#fefefe',
    surface: '#ffffff',
    
    // Tinted Backgrounds
    purpleTint: '#faf8ff',
    blueTint: '#f0f9ff',
    greenTint: '#f0fdf4',
    orangeTint: '#fffbf7',
    pinkTint: '#fdf8fc',
    
    // Subtle Gradients
    gradientSubtle: 'linear-gradient(180deg, #ffffff 0%, #fdfdfd 100%)',
    gradientPurple: 'linear-gradient(180deg, #ffffff 0%, #faf8ff 100%)',
    gradientBlue: 'linear-gradient(180deg, #ffffff 0%, #f0f9ff 100%)',
    
    // Dark mode (for theme switching)
    dark: {
      primary: '#0f172a',
      secondary: '#1e293b',
      tertiary: '#334155',
      elevated: '#1e293b',
      overlay: 'rgba(15, 23, 42, 0.95)',
      card: '#1e293b',
    },
  },
  
  // Text Colors - High contrast for white backgrounds
  text: {
    primary: '#0f172a',
    secondary: '#475569',
    tertiary: '#64748b',
    disabled: '#94a3b8',
    inverse: '#ffffff',
    
    // Accent text colors
    purple: '#7c3aed',
    blue: '#0ea5e9',
    green: '#10b981',
    orange: '#f59e0b',
    pink: '#ec4899',
    
    // Dark mode text
    dark: {
      primary: '#f1f5f9',
      secondary: '#cbd5e1',
      tertiary: '#94a3b8',
      disabled: '#64748b',
      inverse: '#0f172a',
    },
  },
  
  // Special Effects Colors - Clean and subtle
  effects: {
    // Gentle Shadows for white backgrounds
    shadowSoft: 'rgba(15, 23, 42, 0.04)',
    shadowMedium: 'rgba(15, 23, 42, 0.08)',
    shadowLarge: 'rgba(15, 23, 42, 0.12)',
    shadowXL: 'rgba(15, 23, 42, 0.16)',
    
    // Colored Shadows
    shadowPurple: 'rgba(124, 58, 237, 0.1)',
    shadowBlue: 'rgba(14, 165, 233, 0.1)',
    shadowGreen: 'rgba(16, 185, 129, 0.1)',
    shadowOrange: 'rgba(245, 158, 11, 0.1)',
    
    // Glow Effects (subtle)
    glowPurple: 'rgba(124, 58, 237, 0.2)',
    glowBlue: 'rgba(14, 165, 233, 0.2)',
    glowGreen: 'rgba(16, 185, 129, 0.2)',
    
    // Backdrop Filters
    backdrop: 'rgba(255, 255, 255, 0.8)',
    backdropTinted: 'rgba(250, 248, 255, 0.8)',
  },
  
  // Utility Colors
  utility: {
    transparent: 'transparent',
    current: 'currentColor',
    black: '#000000',
    white: '#ffffff',
    
    // Border Colors
    border: '#e2e8f0',
    borderLight: '#f1f5f9',
    borderFocus: '#7c3aed',
    
    // Divider Colors
    divider: '#e2e8f0',
    dividerLight: '#f1f5f9',
  },
} as const;

// Type exports for TypeScript
export type Colors = typeof colors;
export type ColorKey = keyof Colors;
export type PurpleShade = keyof typeof colors.purple;
export type GradientKey = keyof typeof colors.gradients;
</file>

<file path="src/styles/designStyles.ts.backup">
// Revolutionary Design Styles - Material Design & Neumorphism
// A genius-level design system that pushes boundaries with style mixing utilities

import { Platform } from 'react-native';
import { ThemeMode } from './theme';

// Design style types
export type DesignStyle = 'material' | 'neumorphism' | 'glassmorphism' | 'futuristic';

// Animation speed preferences
export type AnimationSpeed = 'instant' | 'fast' | 'normal' | 'slow' | 'cinematic';

// Border radius preferences
export type BorderRadiusPreference = 'sharp' | 'subtle' | 'rounded' | 'pill';

// Shadow intensity levels
export type ShadowIntensity = 'none' | 'subtle' | 'normal' | 'dramatic' | 'extreme';

// Accent color system
export interface AccentColors {
  primary: string;
  secondary: string;
  tertiary: string;
  gradient: string[];
}

// Design style configuration
export interface DesignStyleConfig {
  shadows: {
    sm: any;
    md: any;
    lg: any;
    xl: any;
    inner: any;
    button: any;
    card: any;
    modal: any;
  };
  surfaces: {
    primary: any;
    secondary: any;
    elevated: any;
    overlay: any;
    interactive: any;
  };
  borders: {
    default: any;
    subtle: any;
    prominent: any;
  };
  animations: {
    duration: {
      instant: number;
      fast: number;
      normal: number;
      slow: number;
      cinematic: number;
    };
    spring: {
      damping: number;
      stiffness: number;
      mass: number;
    };
  };
  effects: {
    blur: number;
    opacity: number;
    scale: number;
  };
}

// Material Design style definitions
export const materialDesignStyle: DesignStyleConfig = {
  shadows: {
    sm: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.18,
      shadowRadius: 1.0,
      elevation: 1,
    },
    md: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.20,
      shadowRadius: 2.2,
      elevation: 3,
    },
    lg: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.25,
      shadowRadius: 4.65,
      elevation: 8,
    },
    xl: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 8 },
      shadowOpacity: 0.30,
      shadowRadius: 8.5,
      elevation: 16,
    },
    inner: {
      shadowColor: 'transparent',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0,
      shadowRadius: 0,
      elevation: 0,
    },
    button: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 3 },
      shadowOpacity: 0.22,
      shadowRadius: 3.5,
      elevation: 6,
    },
    card: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.15,
      shadowRadius: 3.84,
      elevation: 5,
    },
    modal: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 10 },
      shadowOpacity: 0.35,
      shadowRadius: 12.5,
      elevation: 24,
    },
  },
  surfaces: {
    primary: {
      backgroundColor: 'transparent',
    },
    secondary: {
      backgroundColor: 'transparent',
    },
    elevated: {
      backgroundColor: 'transparent',
    },
    overlay: {
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    interactive: {
      backgroundColor: 'transparent',
    },
  },
  borders: {
    default: {
      borderWidth: 0,
      borderColor: 'transparent',
    },
    subtle: {
      borderWidth: 1,
      borderColor: 'rgba(0, 0, 0, 0.05)',
    },
    prominent: {
      borderWidth: 1,
      borderColor: 'rgba(0, 0, 0, 0.1)',
    },
  },
  animations: {
    duration: {
      instant: 0,
      fast: 150,
      normal: 300,
      slow: 500,
      cinematic: 1000,
    },
    spring: {
      damping: 15,
      stiffness: 100,
      mass: 1,
    },
  },
  effects: {
    blur: 0,
    opacity: 1,
    scale: 1,
  },
};

// Neumorphism style definitions
export const neumorphismStyle: DesignStyleConfig = {
  shadows: {
    sm: {
      shadowColor: '#000',
      shadowOffset: { width: 3, height: 3 },
      shadowOpacity: 0.15,
      shadowRadius: 6,
      elevation: 0,
    },
    md: {
      shadowColor: '#000',
      shadowOffset: { width: 6, height: 6 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
      elevation: 0,
    },
    lg: {
      shadowColor: '#000',
      shadowOffset: { width: 9, height: 9 },
      shadowOpacity: 0.2,
      shadowRadius: 18,
      elevation: 0,
    },
    xl: {
      shadowColor: '#000',
      shadowOffset: { width: 12, height: 12 },
      shadowOpacity: 0.25,
      shadowRadius: 24,
      elevation: 0,
    },
    inner: {
      shadowColor: '#000',
      shadowOffset: { width: -3, height: -3 },
      shadowOpacity: 0.1,
      shadowRadius: 6,
      elevation: 0,
    },
    button: {
      shadowColor: '#000',
      shadowOffset: { width: 5, height: 5 },
      shadowOpacity: 0.15,
      shadowRadius: 10,
      elevation: 0,
    },
    card: {
      shadowColor: '#000',
      shadowOffset: { width: 8, height: 8 },
      shadowOpacity: 0.15,
      shadowRadius: 16,
      elevation: 0,
    },
    modal: {
      shadowColor: '#000',
      shadowOffset: { width: 15, height: 15 },
      shadowOpacity: 0.3,
      shadowRadius: 30,
      elevation: 0,
    },
  },
  surfaces: {
    primary: {
      backgroundColor: 'transparent',
    },
    secondary: {
      backgroundColor: 'transparent',
    },
    elevated: {
      backgroundColor: 'transparent',
    },
    overlay: {
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    interactive: {
      backgroundColor: 'transparent',
    },
  },
  borders: {
    default: {
      borderWidth: 0,
      borderColor: 'transparent',
    },
    subtle: {
      borderWidth: 0,
      borderColor: 'transparent',
    },
    prominent: {
      borderWidth: 0,
      borderColor: 'transparent',
    },
  },
  animations: {
    duration: {
      instant: 0,
      fast: 200,
      normal: 400,
      slow: 600,
      cinematic: 1200,
    },
    spring: {
      damping: 20,
      stiffness: 80,
      mass: 1.2,
    },
  },
  effects: {
    blur: 5,
    opacity: 0.95,
    scale: 0.98,
  },
};

// Glassmorphism style definitions
export const glassmorphismStyle: DesignStyleConfig = {
  shadows: {
    sm: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.1,
      shadowRadius: 8,
      elevation: 2,
    },
    md: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 8 },
      shadowOpacity: 0.15,
      shadowRadius: 16,
      elevation: 4,
    },
    lg: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 12 },
      shadowOpacity: 0.2,
      shadowRadius: 24,
      elevation: 8,
    },
    xl: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 20 },
      shadowOpacity: 0.25,
      shadowRadius: 32,
      elevation: 16,
    },
    inner: {
      shadowColor: 'transparent',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0,
      shadowRadius: 0,
      elevation: 0,
    },
    button: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 6 },
      shadowOpacity: 0.12,
      shadowRadius: 12,
      elevation: 4,
    },
    card: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 10 },
      shadowOpacity: 0.15,
      shadowRadius: 20,
      elevation: 6,
    },
    modal: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 24 },
      shadowOpacity: 0.3,
      shadowRadius: 40,
      elevation: 24,
    },
  },
  surfaces: {
    primary: {
      backgroundColor: 'rgba(255, 255, 255, 0.1)',
      backdropFilter: 'blur(10px)',
    },
    secondary: {
      backgroundColor: 'rgba(255, 255, 255, 0.05)',
      backdropFilter: 'blur(8px)',
    },
    elevated: {
      backgroundColor: 'rgba(255, 255, 255, 0.15)',
      backdropFilter: 'blur(12px)',
    },
    overlay: {
      backgroundColor: 'rgba(0, 0, 0, 0.2)',
      backdropFilter: 'blur(20px)',
    },
    interactive: {
      backgroundColor: 'rgba(255, 255, 255, 0.08)',
      backdropFilter: 'blur(6px)',
    },
  },
  borders: {
    default: {
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.18)',
    },
    subtle: {
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.1)',
    },
    prominent: {
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.3)',
    },
  },
  animations: {
    duration: {
      instant: 0,
      fast: 180,
      normal: 350,
      slow: 550,
      cinematic: 1100,
    },
    spring: {
      damping: 18,
      stiffness: 90,
      mass: 1.1,
    },
  },
  effects: {
    blur: 20,
    opacity: 0.8,
    scale: 1,
  },
};

// Futuristic style definitions
export const futuristicStyle: DesignStyleConfig = {
  shadows: {
    sm: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.3,
      shadowRadius: 10,
      elevation: 0,
    },
    md: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.4,
      shadowRadius: 20,
      elevation: 0,
    },
    lg: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.5,
      shadowRadius: 30,
      elevation: 0,
    },
    xl: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.6,
      shadowRadius: 40,
      elevation: 0,
    },
    inner: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.2,
      shadowRadius: 15,
      elevation: 0,
    },
    button: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.5,
      shadowRadius: 15,
      elevation: 0,
    },
    card: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.4,
      shadowRadius: 25,
      elevation: 0,
    },
    modal: {
      shadowColor: '#a855f7',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0.7,
      shadowRadius: 50,
      elevation: 0,
    },
  },
  surfaces: {
    primary: {
      backgroundColor: 'rgba(168, 85, 247, 0.05)',
      borderWidth: 1,
      borderColor: 'rgba(168, 85, 247, 0.2)',
    },
    secondary: {
      backgroundColor: 'rgba(168, 85, 247, 0.02)',
      borderWidth: 1,
      borderColor: 'rgba(168, 85, 247, 0.15)',
    },
    elevated: {
      backgroundColor: 'rgba(168, 85, 247, 0.08)',
      borderWidth: 1,
      borderColor: 'rgba(168, 85, 247, 0.3)',
    },
    overlay: {
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
      borderWidth: 1,
      borderColor: 'rgba(168, 85, 247, 0.4)',
    },
    interactive: {
      backgroundColor: 'rgba(168, 85, 247, 0.03)',
      borderWidth: 1,
      borderColor: 'rgba(168, 85, 247, 0.25)',
    },
  },
  borders: {
    default: {
      borderWidth: 1,
      borderColor: 'rgba(168, 85, 247, 0.3)',
    },
    subtle: {
      borderWidth: 1,
      borderColor: 'rgba(168, 85, 247, 0.2)',
    },
    prominent: {
      borderWidth: 2,
      borderColor: 'rgba(168, 85, 247, 0.5)',
    },
  },
  animations: {
    duration: {
      instant: 0,
      fast: 100,
      normal: 250,
      slow: 450,
      cinematic: 900,
    },
    spring: {
      damping: 12,
      stiffness: 120,
      mass: 0.8,
    },
  },
  effects: {
    blur: 0,
    opacity: 0.95,
    scale: 1.02,
  },
};

// Get design style configuration
export const getDesignStyle = (style: DesignStyle): DesignStyleConfig => {
  switch (style) {
    case 'material':
      return materialDesignStyle;
    case 'neumorphism':
      return neumorphismStyle;
    case 'glassmorphism':
      return glassmorphismStyle;
    case 'futuristic':
      return futuristicStyle;
    default:
      return materialDesignStyle;
  }
};

// Style mixing utilities
export const mixStyles = (
  primary: DesignStyleConfig,
  secondary: DesignStyleConfig,
  ratio: number = 0.5
): DesignStyleConfig => {
  const primaryWeight = 1 - ratio;
  const secondaryWeight = ratio;

  return {
    shadows: {
      sm: mixShadow(primary.shadows.sm, secondary.shadows.sm, ratio),
      md: mixShadow(primary.shadows.md, secondary.shadows.md, ratio),
      lg: mixShadow(primary.shadows.lg, secondary.shadows.lg, ratio),
      xl: mixShadow(primary.shadows.xl, secondary.shadows.xl, ratio),
      inner: mixShadow(primary.shadows.inner, secondary.shadows.inner, ratio),
      button: mixShadow(primary.shadows.button, secondary.shadows.button, ratio),
      card: mixShadow(primary.shadows.card, secondary.shadows.card, ratio),
      modal: mixShadow(primary.shadows.modal, secondary.shadows.modal, ratio),
    },
    surfaces: {
      primary: mixSurface(primary.surfaces.primary, secondary.surfaces.primary, ratio),
      secondary: mixSurface(primary.surfaces.secondary, secondary.surfaces.secondary, ratio),
      elevated: mixSurface(primary.surfaces.elevated, secondary.surfaces.elevated, ratio),
      overlay: mixSurface(primary.surfaces.overlay, secondary.surfaces.overlay, ratio),
      interactive: mixSurface(primary.surfaces.interactive, secondary.surfaces.interactive, ratio),
    },
    borders: {
      default: mixBorder(primary.borders.default, secondary.borders.default, ratio),
      subtle: mixBorder(primary.borders.subtle, secondary.borders.subtle, ratio),
      prominent: mixBorder(primary.borders.prominent, secondary.borders.prominent, ratio),
    },
    animations: {
      duration: {
        instant: 0,
        fast: Math.round(primary.animations.duration.fast * primaryWeight + secondary.animations.duration.fast * secondaryWeight),
        normal: Math.round(primary.animations.duration.normal * primaryWeight + secondary.animations.duration.normal * secondaryWeight),
        slow: Math.round(primary.animations.duration.slow * primaryWeight + secondary.animations.duration.slow * secondaryWeight),
        cinematic: Math.round(primary.animations.duration.cinematic * primaryWeight + secondary.animations.duration.cinematic * secondaryWeight),
      },
      spring: {
        damping: primary.animations.spring.damping * primaryWeight + secondary.animations.spring.damping * secondaryWeight,
        stiffness: primary.animations.spring.stiffness * primaryWeight + secondary.animations.spring.stiffness * secondaryWeight,
        mass: primary.animations.spring.mass * primaryWeight + secondary.animations.spring.mass * secondaryWeight,
      },
    },
    effects: {
      blur: primary.effects.blur * primaryWeight + secondary.effects.blur * secondaryWeight,
      opacity: primary.effects.opacity * primaryWeight + secondary.effects.opacity * secondaryWeight,
      scale: primary.effects.scale * primaryWeight + secondary.effects.scale * secondaryWeight,
    },
  };
};

// Helper function to mix shadows
const mixShadow = (shadow1: any, shadow2: any, ratio: number): any => {
  if (!shadow1 || !shadow2) return shadow1 || shadow2;
  
  const weight1 = 1 - ratio;
  const weight2 = ratio;
  
  return {
    shadowColor: shadow1.shadowColor, // Keep primary color for now
    shadowOffset: {
      width: shadow1.shadowOffset.width * weight1 + shadow2.shadowOffset.width * weight2,
      height: shadow1.shadowOffset.height * weight1 + shadow2.shadowOffset.height * weight2,
    },
    shadowOpacity: shadow1.shadowOpacity * weight1 + shadow2.shadowOpacity * weight2,
    shadowRadius: shadow1.shadowRadius * weight1 + shadow2.shadowRadius * weight2,
    elevation: Math.round((shadow1.elevation || 0) * weight1 + (shadow2.elevation || 0) * weight2),
  };
};

// Helper function to mix surfaces
const mixSurface = (surface1: any, surface2: any, ratio: number): any => {
  if (!surface1 || !surface2) return surface1 || surface2;
  
  return {
    ...surface1,
    ...surface2,
    // Mix specific properties if they exist
    opacity: surface1.opacity !== undefined && surface2.opacity !== undefined
      ? surface1.opacity * (1 - ratio) + surface2.opacity * ratio
      : surface1.opacity || surface2.opacity,
  };
};

// Helper function to mix borders
const mixBorder = (border1: any, border2: any, ratio: number): any => {
  if (!border1 || !border2) return border1 || border2;
  
  const weight1 = 1 - ratio;
  const weight2 = ratio;
  
  return {
    borderWidth: border1.borderWidth * weight1 + border2.borderWidth * weight2,
    borderColor: border1.borderColor, // Keep primary color for now
  };
};

// Border radius configurations
export const borderRadiusConfigs = {
  sharp: {
    none: 0,
    sm: 2,
    base: 4,
    md: 6,
    lg: 8,
    xl: 12,
    '2xl': 16,
    '3xl': 20,
    '4xl': 24,
    full: 9999,
  },
  subtle: {
    none: 0,
    sm: 4,
    base: 8,
    md: 12,
    lg: 16,
    xl: 20,
    '2xl': 24,
    '3xl': 32,
    '4xl': 40,
    full: 9999,
  },
  rounded: {
    none: 0,
    sm: 6,
    base: 12,
    md: 16,
    lg: 20,
    xl: 24,
    '2xl': 32,
    '3xl': 40,
    '4xl': 48,
    full: 9999,
  },
  pill: {
    none: 0,
    sm: 12,
    base: 16,
    md: 20,
    lg: 24,
    xl: 32,
    '2xl': 40,
    '3xl': 48,
    '4xl': 56,
    full: 9999,
  },
};

// Shadow intensity configurations
export const shadowIntensityConfigs = {
  none: {
    multiplier: 0,
  },
  subtle: {
    multiplier: 0.5,
  },
  normal: {
    multiplier: 1,
  },
  dramatic: {
    multiplier: 1.5,
  },
  extreme: {
    multiplier: 2,
  },
};

// Apply shadow intensity
export const applyShadowIntensity = (shadow: any, intensity: ShadowIntensity): any => {
  const config = shadowIntensityConfigs[intensity];
  
  if (config.multiplier === 0) {
    return {
      shadowColor: 'transparent',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0,
      shadowRadius: 0,
      elevation: 0,
    };
  }
  
  return {
    ...shadow,
    shadowOpacity: Math.min(shadow.shadowOpacity * config.multiplier, 1),
    shadowRadius: shadow.shadowRadius * config.multiplier,
    elevation: Math.round((shadow.elevation || 0) * config.multiplier),
  };
};

// Animation speed configurations
export const getAnimationDuration = (
  speed: AnimationSpeed,
  baseConfig: DesignStyleConfig['animations']['duration']
): DesignStyleConfig['animations']['duration'] => {
  const speedMultipliers = {
    instant: 0,
    fast: 0.5,
    normal: 1,
    slow: 1.5,
    cinematic: 2,
  };
  
  const multiplier = speedMultipliers[speed];
  
  return {
    instant: 0,
    fast: Math.round(baseConfig.fast * multiplier),
    normal: Math.round(baseConfig.normal * multiplier),
    slow: Math.round(baseConfig.slow * multiplier),
    cinematic: Math.round(baseConfig.cinematic * multiplier),
  };
};

// Dynamic accent color generator
export const generateAccentColors = (baseColor: string): AccentColors => {
  // This is a simplified version - in a real app, you'd use a color manipulation library
  return {
    primary: baseColor,
    secondary: baseColor + '99', // 60% opacity
    tertiary: baseColor + '66', // 40% opacity
    gradient: [
      baseColor,
      adjustColor(baseColor, 0.2), // Lighter
      adjustColor(baseColor, -0.2), // Darker
    ],
  };
};

// Helper function to adjust color brightness
const adjustColor = (color: string, amount: number): string => {
  // This is a placeholder - in a real app, you'd use a proper color manipulation library
  return color;
};

// Create a complete theme configuration
export const createThemeConfig = (
  mode: ThemeMode,
  designStyle: DesignStyle,
  accentColor: string,
  animationSpeed: AnimationSpeed,
  borderRadius: BorderRadiusPreference,
  shadowIntensity: ShadowIntensity
) => {
  const baseStyle = getDesignStyle(designStyle);
  const accentColors = generateAccentColors(accentColor);
  const borderRadiusConfig = borderRadiusConfigs[borderRadius];
  
  return {
    mode,
    designStyle,
    accentColors,
    animationSpeed,
    borderRadius: borderRadiusConfig,
    shadowIntensity,
    style: {
      ...baseStyle,
      animations: {
        ...baseStyle.animations,
        duration: getAnimationDuration(animationSpeed, baseStyle.animations.duration),
      },
    },
  };
};

// Export all configurations
export default {
  getDesignStyle,
  mixStyles,
  borderRadiusConfigs,
  shadowIntensityConfigs,
  applyShadowIntensity,
  getAnimationDuration,
  generateAccentColors,
  createThemeConfig,
};
</file>

<file path="src/styles/index.ts">
// Centralized style exports for the TDR Days application
// This index file provides a single entry point for all styling needs

// Core style modules
export * from './colors';
export * from './typography';
export * from './theme';

// Re-export commonly used items with more convenient names
export { colors as Colors } from './colors';
export { typography as Typography } from './typography';
export { 
  lightTheme as LightTheme, 
  darkTheme as DarkTheme,
  createTheme as CreateTheme,
  spacing as Spacing,
  borderRadius as BorderRadius
} from './theme';

// Type exports for better development experience
export type {
  Colors as ColorsType,
  ColorKey,
  PurpleShade,
  GradientKey
} from './colors';

export type {
  Typography as TypographyType,
  FontSize,
  FontWeight,
  TextStyle
} from './typography';

export type {
  Theme,
  ThemeMode
} from './theme';
</file>

<file path="src/styles/theme.ts">
// Ultra-Minimal Theme System
export type ThemeMode = 'light' | 'dark';

// Fallback colors in case colors.ts fails
const fallbackColors = {
  purple: {
    500: '#9333ea',
    bright: '#8b5cf6',
  },
  background: {
    primary: '#ffffff',
    secondary: '#fdfdfd',
    card: '#ffffff',
    elevated: '#ffffff',
    tertiary: '#f8fafc',
  },
  text: {
    primary: '#1f2937',
    secondary: '#6b7280',
    tertiary: '#9ca3af',
    disabled: '#d1d5db',
  },
  utility: {
    borderLight: '#f3f4f6',
    white: '#ffffff',
    gridLight: '#f9fafb',
  },
  border: '#e5e7eb',
};

// Try to import colors, fallback if it fails
let importedColors;
try {
  importedColors = require('./colors').colors;
} catch (error) {
  console.warn('Failed to import colors, using fallback');
  importedColors = fallbackColors;
}

export const colors = importedColors || fallbackColors;

// Spacing system
export const spacing = {
  0: 0,
  1: 4,
  2: 8,
  3: 12,
  4: 16,
  5: 20,
  6: 24,
  8: 32,
};

// Border radius system
export const borderRadius = {
  sm: 4,
  md: 6,
  lg: 8,
  xl: 12,
  '2xl': 16,
  '3xl': 24,
  full: 9999,
};

// Basic theme structure
export interface Theme {
  mode: ThemeMode;
  colors: typeof colors;
}

// Create theme function
export const createTheme = (mode: ThemeMode): Theme => ({
  mode,
  colors,
});

// Export default themes
export const lightTheme = createTheme('light');
export const darkTheme = createTheme('dark');
</file>

<file path="src/styles/typography.ts">
// Revolutionary Typography System
// Next-generation type design for digital experiences

export const typography = {
  // Font Families - Cutting-edge type combinations
  fontFamily: {
    // Primary Font Stacks
    sans: [
      'Inter',
      '-apple-system',
      'BlinkMacSystemFont',
      'Segoe UI',
      'Roboto',
      'Helvetica Neue',
      'Arial',
      'sans-serif',
    ].join(', '),
    
    // Display Fonts - For headlines and impact
    display: [
      'Clash Display',
      'Space Grotesk',
      'Inter',
      '-apple-system',
      'sans-serif',
    ].join(', '),
    
    // Mono Fonts - For code and technical content
    mono: [
      'JetBrains Mono',
      'Fira Code',
      'SF Mono',
      'Monaco',
      'Consolas',
      'Liberation Mono',
      'Courier New',
      'monospace',
    ].join(', '),
    
    // Experimental Fonts
    experimental: [
      'Satoshi',
      'General Sans',
      'Inter',
      'sans-serif',
    ].join(', '),
  },
  
  // Font Sizes - Fluid Typography Scale
  fontSize: {
    // Base sizes
    '2xs': '0.625rem',    // 10px
    xs: '0.75rem',        // 12px
    sm: '0.875rem',       // 14px
    base: '1rem',         // 16px
    lg: '1.125rem',       // 18px
    xl: '1.25rem',        // 20px
    '2xl': '1.5rem',      // 24px
    '3xl': '1.875rem',    // 30px
    '4xl': '2.25rem',     // 36px
    '5xl': '3rem',        // 48px
    '6xl': '3.75rem',     // 60px
    '7xl': '4.5rem',      // 72px
    '8xl': '6rem',        // 96px
    '9xl': '8rem',        // 128px
    
    // Fluid sizes using clamp()
    fluid: {
      xs: 'clamp(0.75rem, 0.7rem + 0.25vw, 0.875rem)',
      sm: 'clamp(0.875rem, 0.825rem + 0.25vw, 1rem)',
      base: 'clamp(1rem, 0.95rem + 0.25vw, 1.125rem)',
      lg: 'clamp(1.125rem, 1.05rem + 0.375vw, 1.25rem)',
      xl: 'clamp(1.25rem, 1.15rem + 0.5vw, 1.5rem)',
      '2xl': 'clamp(1.5rem, 1.35rem + 0.75vw, 1.875rem)',
      '3xl': 'clamp(1.875rem, 1.65rem + 1.125vw, 2.25rem)',
      '4xl': 'clamp(2.25rem, 1.9rem + 1.75vw, 3rem)',
      '5xl': 'clamp(3rem, 2.4rem + 3vw, 4.5rem)',
      '6xl': 'clamp(3.75rem, 2.75rem + 5vw, 6rem)',
      '7xl': 'clamp(4.5rem, 3rem + 7.5vw, 8rem)',
    },
  },
  
  // Line Heights - Optimized for readability
  lineHeight: {
    none: '1',
    tight: '1.25',
    snug: '1.375',
    normal: '1.5',
    relaxed: '1.625',
    loose: '1.75',
    extra: '2',
    
    // Specific use cases
    body: '1.625',
    heading: '1.2',
    display: '1.1',
    code: '1.5',
  },
  
  // Font Weights - Full spectrum
  fontWeight: {
    thin: 100,
    extralight: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900,
    
    // Semantic weights
    body: 400,
    heading: 700,
    display: 800,
    emphasis: 600,
  },
  
  // Letter Spacing - Precision tracking
  letterSpacing: {
    tighter: '-0.05em',
    tight: '-0.025em',
    normal: '0',
    wide: '0.025em',
    wider: '0.05em',
    widest: '0.1em',
    
    // Specific use cases
    heading: '-0.025em',
    display: '-0.03em',
    body: '0',
    caps: '0.1em',
  },
  
  // Text Styles - Pre-composed combinations
  textStyles: {
    // Display Styles - Maximum impact
    displayXL: {
      fontFamily: 'display',
      fontSize: 'clamp(4.5rem, 3rem + 7.5vw, 8rem)',
      fontWeight: 800,
      lineHeight: '1.1',
      letterSpacing: '-0.03em',
    },
    displayLarge: {
      fontFamily: 'display',
      fontSize: 'clamp(3rem, 2.4rem + 3vw, 4.5rem)',
      fontWeight: 800,
      lineHeight: '1.1',
      letterSpacing: '-0.03em',
    },
    displayMedium: {
      fontFamily: 'display',
      fontSize: 'clamp(2.25rem, 1.9rem + 1.75vw, 3rem)',
      fontWeight: 700,
      lineHeight: '1.2',
      letterSpacing: '-0.025em',
    },
    displaySmall: {
      fontFamily: 'display',
      fontSize: 'clamp(1.875rem, 1.65rem + 1.125vw, 2.25rem)',
      fontWeight: 700,
      lineHeight: '1.2',
      letterSpacing: '-0.025em',
    },
    
    // Heading Styles
    h1: {
      fontFamily: 'sans',
      fontSize: 'clamp(2.25rem, 1.9rem + 1.75vw, 3rem)',
      fontWeight: 700,
      lineHeight: '1.2',
      letterSpacing: '-0.025em',
    },
    h2: {
      fontFamily: 'sans',
      fontSize: 'clamp(1.875rem, 1.65rem + 1.125vw, 2.25rem)',
      fontWeight: 600,
      lineHeight: '1.25',
      letterSpacing: '-0.025em',
    },
    h3: {
      fontFamily: 'sans',
      fontSize: 'clamp(1.5rem, 1.35rem + 0.75vw, 1.875rem)',
      fontWeight: 600,
      lineHeight: '1.375',
      letterSpacing: '-0.025em',
    },
    h4: {
      fontFamily: 'sans',
      fontSize: 'clamp(1.25rem, 1.15rem + 0.5vw, 1.5rem)',
      fontWeight: 600,
      lineHeight: '1.375',
      letterSpacing: '0',
    },
    h5: {
      fontFamily: 'sans',
      fontSize: 'clamp(1.125rem, 1.05rem + 0.375vw, 1.25rem)',
      fontWeight: 600,
      lineHeight: '1.5',
      letterSpacing: '0',
    },
    h6: {
      fontFamily: 'sans',
      fontSize: 'clamp(1rem, 0.95rem + 0.25vw, 1.125rem)',
      fontWeight: 600,
      lineHeight: '1.5',
      letterSpacing: '0',
    },
    
    // Body Styles
    bodyLarge: {
      fontFamily: 'sans',
      fontSize: 'clamp(1.125rem, 1.05rem + 0.375vw, 1.25rem)',
      fontWeight: 400,
      lineHeight: '1.625',
      letterSpacing: '0',
    },
    bodyMedium: {
      fontFamily: 'sans',
      fontSize: 'clamp(1rem, 0.95rem + 0.25vw, 1.125rem)',
      fontWeight: 400,
      lineHeight: '1.625',
      letterSpacing: '0',
    },
    bodySmall: {
      fontFamily: 'sans',
      fontSize: 'clamp(0.875rem, 0.825rem + 0.25vw, 1rem)',
      fontWeight: 400,
      lineHeight: '1.5',
      letterSpacing: '0',
    },
    
    // Special Styles
    label: {
      fontFamily: 'sans',
      fontSize: '0.875rem',
      fontWeight: 500,
      lineHeight: '1.5',
      letterSpacing: '0.025em',
      textTransform: 'uppercase' as const,
    },
    caption: {
      fontFamily: 'sans',
      fontSize: '0.75rem',
      fontWeight: 400,
      lineHeight: '1.5',
      letterSpacing: '0',
    },
    overline: {
      fontFamily: 'sans',
      fontSize: '0.75rem',
      fontWeight: 600,
      lineHeight: '1.5',
      letterSpacing: '0.1em',
      textTransform: 'uppercase' as const,
    },
    code: {
      fontFamily: 'mono',
      fontSize: '0.875rem',
      fontWeight: 400,
      lineHeight: '1.5',
      letterSpacing: '0',
    },
    
    // Experimental Styles
    glitch: {
      fontFamily: 'experimental',
      fontSize: 'clamp(2.25rem, 1.9rem + 1.75vw, 3rem)',
      fontWeight: 900,
      lineHeight: '1.1',
      letterSpacing: '-0.05em',
      textTransform: 'uppercase' as const,
    },
    neon: {
      fontFamily: 'display',
      fontSize: 'clamp(1.875rem, 1.65rem + 1.125vw, 2.25rem)',
      fontWeight: 700,
      lineHeight: '1.2',
      letterSpacing: '0.05em',
      textTransform: 'uppercase' as const,
    },
  },
  
  // Text Decoration Styles
  textDecoration: {
    underline: {
      textDecoration: 'underline',
      textUnderlineOffset: '0.2em',
      textDecorationThickness: '0.1em',
    },
    strikethrough: {
      textDecoration: 'line-through',
      textDecorationThickness: '0.1em',
    },
    wavy: {
      textDecoration: 'underline wavy',
      textUnderlineOffset: '0.3em',
    },
  },
  
  // Text Effects
  textEffects: {
    // Gradient Text
    gradient: {
      backgroundClip: 'text',
      WebkitBackgroundClip: 'text',
      color: 'transparent',
      WebkitTextFillColor: 'transparent',
    },
    
    // Text Shadow Effects
    shadow: {
      subtle: '0 1px 2px rgba(0, 0, 0, 0.1)',
      medium: '0 2px 4px rgba(0, 0, 0, 0.2)',
      strong: '0 4px 8px rgba(0, 0, 0, 0.3)',
      glow: '0 0 20px rgba(168, 85, 247, 0.5)',
      neon: '0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px currentColor',
    },
    
    // Text Stroke
    stroke: {
      thin: '-webkit-text-stroke: 1px currentColor',
      medium: '-webkit-text-stroke: 2px currentColor',
      thick: '-webkit-text-stroke: 3px currentColor',
    },
  },
} as const;

// Type exports
export type Typography = typeof typography;
export type FontSize = keyof typeof typography.fontSize;
export type FontWeight = keyof typeof typography.fontWeight;
export type TextStyle = keyof typeof typography.textStyles;
</file>

<file path="src/types/models.ts">
/**
 * Data models for TDR Days app
 * Designed to support future Rails backend sync
 */

// Park type enum
export enum ParkType {
  LAND = 'LAND',
  SEA = 'SEA',
}

// Action category enum
export enum ActionCategory {
  ATTRACTION = 'ATTRACTION',
  RESTAURANT = 'RESTAURANT',
  SHOW = 'SHOW',
  GREETING = 'GREETING',
  SHOPPING = 'SHOPPING',
  CUSTOM = 'CUSTOM',
}

// Area definitions for both parks
export enum LandArea {
  WORLD_BAZAAR = 'ワールドバザール',
  ADVENTURELAND = 'アドベンチャーランド',
  WESTERNLAND = 'ウエスタンランド',
  CRITTER_COUNTRY = 'クリッターカントリー',
  FANTASYLAND = 'ファンタジーランド',
  TOONTOWN = 'トゥーンタウン',
  TOMORROWLAND = 'トゥモローランド',
}

export enum SeaArea {
  MEDITERRANEAN_HARBOR = 'メディテレーニアンハーバー',
  AMERICAN_WATERFRONT = 'アメリカンウォーターフロント',
  PORT_DISCOVERY = 'ポートディスカバリー',
  LOST_RIVER_DELTA = 'ロストリバーデルタ',
  ARABIAN_COAST = 'アラビアンコースト',
  MERMAID_LAGOON = 'マーメイドラグーン',
  MYSTERIOUS_ISLAND = 'ミステリアスアイランド',
  FANTASY_SPRINGS = 'ファンタジースプリングス',
}

export type ParkArea = LandArea | SeaArea;

// Base model interface with common fields
interface BaseModel {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  // For future Rails sync
  syncedAt?: Date;
  remoteId?: string;
}

// Companion model
export interface Companion extends BaseModel {
  name: string;
  visitIds: string[]; // Array of visit IDs
  avatar?: string; // Optional avatar URL/path
  notes?: string;
}

// Visit model
export interface Visit extends BaseModel {
  date: Date;
  parkType: ParkType;
  companionIds: string[]; // Array of companion IDs
  numberOfPeople?: number; // Optional total number of people
  notes?: string;
  weather?: 'SUNNY' | 'CLOUDY' | 'RAINY' | 'SNOWY';
  startTime?: Date;
  endTime?: Date;
  // Cached values for performance
  actionCount?: number;
  totalPhotoCount?: number;
}

// Photo model for timeline actions
export interface Photo {
  id: string;
  uri: string; // Local URI or URL
  thumbnailUri?: string;
  width?: number;
  height?: number;
  takenAt?: Date;
  caption?: string;
}

// Timeline action model
export interface TimelineAction extends BaseModel {
  visitId: string;
  category: ActionCategory;
  area: ParkArea;
  locationName?: string; // e.g., "Space Mountain", "Queen of Hearts Banquet Hall" - optional for GREETING and CUSTOM
  locationId?: string; // For future preset location reference
  time: Date;
  duration?: number; // Duration in minutes
  waitTime?: number; // Wait time in minutes (for attractions)
  notes?: string;
  photos: Photo[];
  // For shopping actions
  purchaseAmount?: number;
  purchasedItems?: string[];
  // For restaurant actions
  mealType?: 'BREAKFAST' | 'LUNCH' | 'DINNER' | 'SNACK';
  // For show/greeting actions
  performerNames?: string[];
  showTime?: string; // Specific show time if applicable
  // For custom actions
  customTitle?: string; // Title for custom actions when locationName is not used
  // Sorting support
  sortOrder?: number;
}

// Analytics data types
export interface VisitStats {
  totalVisits: number;
  landVisits: number;
  seaVisits: number;
  averageVisitDuration?: number;
  favoriteCompanions: Array<{
    companion: Companion;
    visitCount: number;
  }>;
  visitsByMonth: Array<{
    month: string; // YYYY-MM format
    count: number;
  }>;
  visitsByYear: Array<{
    year: number;
    count: number;
  }>;
}

export interface ActionStats {
  totalActions: number;
  actionsByCategory: Record<ActionCategory, number>;
  topAttractions: Array<{
    locationName: string;
    count: number;
    averageWaitTime?: number;
  }>;
  topRestaurants: Array<{
    locationName: string;
    count: number;
  }>;
  areaDistribution: Array<{
    area: ParkArea;
    visitCount: number;
    timeSpent?: number; // in minutes
  }>;
  averageActionsPerVisit: number;
  photoCount: number;
}

export interface CompanionStats {
  companion: Companion;
  visitCount: number;
  lastVisitDate: Date;
  favoriteAreas: ParkArea[];
  commonActivities: Array<{
    category: ActionCategory;
    count: number;
  }>;
}

// Date range for analytics queries
export interface DateRange {
  startDate: Date;
  endDate: Date;
}

// Filter options for queries
export interface VisitFilter {
  dateRange?: DateRange;
  parkType?: ParkType;
  companionIds?: string[];
}

export interface ActionFilter {
  visitId?: string;
  category?: ActionCategory;
  area?: ParkArea;
  dateRange?: DateRange;
  locationName?: string;
}

// Sort options
export type SortDirection = 'ASC' | 'DESC';

export interface SortOptions<T> {
  field: keyof T;
  direction: SortDirection;
}

// Migration support
export interface DataMigration {
  version: number;
  appliedAt: Date;
  description: string;
}

// App metadata
export interface AppMetadata extends BaseModel {
  dataVersion: number;
  lastSyncDate?: Date;
  userId?: string; // For future user accounts
  settings?: Record<string, any>;
}

// Preset location data (for future implementation)
export interface PresetLocation {
  id: string;
  name: string;
  nameEn?: string;
  category: ActionCategory;
  parkType: ParkType;
  area: ParkArea;
  isActive: boolean;
  openingDate?: Date;
  closingDate?: Date;
  tags?: string[];
}

// Export utility types
export type CreateInput<T extends BaseModel> = Omit<T, keyof BaseModel>;
export type UpdateInput<T extends BaseModel> = Partial<Omit<T, 'id' | 'createdAt'>>;
</file>

<file path="src/utils/responsive.ts">
import { Dimensions, Platform } from 'react-native';

// Breakpoints for responsive design
export const BREAKPOINTS = {
  mobile: 0,
  mobileL: 428,
  tablet: 768,
  laptop: 1024,
  desktop: 1440,
  desktopL: 1920,
  ultraWide: 2560,
} as const;

// Grid configurations
export const GRID_CONFIG = {
  mobile: { columns: 4, gutter: 16, margin: 16 },
  mobileL: { columns: 4, gutter: 20, margin: 20 },
  tablet: { columns: 8, gutter: 24, margin: 24 },
  laptop: { columns: 12, gutter: 24, margin: 32 },
  desktop: { columns: 12, gutter: 32, margin: 48 },
  desktopL: { columns: 12, gutter: 32, margin: 64 },
  ultraWide: { columns: 16, gutter: 40, margin: 80 },
} as const;

// Platform detection
export const PLATFORM = {
  isIOS: Platform.OS === 'ios',
  isAndroid: Platform.OS === 'android',
  isWeb: Platform.OS === 'web',
  isMobile: Platform.OS === 'ios' || Platform.OS === 'android',
  isTablet: (Platform.OS === 'ios' && Dimensions.get('window').width >= 768) || (Platform.OS === 'android' && !Platform.isTV),
  isDesktop: Platform.OS === 'web' && typeof window !== 'undefined',
};

// Get current screen dimensions
export const getScreenDimensions = () => {
  const { width, height } = Dimensions.get('window');
  return {
    width,
    height,
    isLandscape: width > height,
    isPortrait: width <= height,
    aspectRatio: width / height,
  };
};

// Get current breakpoint
export const getCurrentBreakpoint = (width?: number): keyof typeof BREAKPOINTS => {
  const screenWidth = width || getScreenDimensions().width;
  
  if (screenWidth >= BREAKPOINTS.ultraWide) return 'ultraWide';
  if (screenWidth >= BREAKPOINTS.desktopL) return 'desktopL';
  if (screenWidth >= BREAKPOINTS.desktop) return 'desktop';
  if (screenWidth >= BREAKPOINTS.laptop) return 'laptop';
  if (screenWidth >= BREAKPOINTS.tablet) return 'tablet';
  if (screenWidth >= BREAKPOINTS.mobileL) return 'mobileL';
  return 'mobile';
};

// Responsive value calculator
export const responsiveValue = <T>(
  values: Partial<Record<keyof typeof BREAKPOINTS, T>>,
  width?: number
): T => {
  const breakpoint = getCurrentBreakpoint(width);
  const breakpointKeys = Object.keys(BREAKPOINTS) as Array<keyof typeof BREAKPOINTS>;
  const currentIndex = breakpointKeys.indexOf(breakpoint);
  
  // Find the value for current or nearest lower breakpoint
  for (let i = currentIndex; i >= 0; i--) {
    const key = breakpointKeys[i];
    if (values[key] !== undefined) {
      return values[key]!;
    }
  }
  
  // Return the first available value
  return Object.values(values)[0] as T;
};

// Responsive dimension calculator
export const responsiveDimension = (
  base: number,
  scale: Partial<Record<keyof typeof BREAKPOINTS, number>> = {}
): number => {
  const defaultScale = {
    mobile: 1,
    mobileL: 1.05,
    tablet: 1.2,
    laptop: 1.3,
    desktop: 1.4,
    desktopL: 1.5,
    ultraWide: 1.8,
  };
  
  const mergedScale = { ...defaultScale, ...scale };
  const multiplier = responsiveValue(mergedScale);
  
  return Math.round(base * multiplier);
};

// Grid system utilities
export const getGridConfig = (width?: number) => {
  const breakpoint = getCurrentBreakpoint(width);
  return GRID_CONFIG[breakpoint];
};

export const calculateColumnWidth = (
  columns: number = 1,
  width?: number,
  includeGutter: boolean = true
): number => {
  const screenWidth = width || getScreenDimensions().width;
  const config = getGridConfig(screenWidth);
  const availableWidth = screenWidth - (config.margin * 2);
  const totalGutters = includeGutter ? (config.columns - 1) * config.gutter : 0;
  const columnWidth = (availableWidth - totalGutters) / config.columns;
  
  return Math.floor(columnWidth * columns + (includeGutter ? config.gutter * (columns - 1) : 0));
};

// Responsive spacing calculator
export const responsiveSpacing = (base: number): number => {
  return responsiveDimension(base, {
    mobile: 1,
    mobileL: 1.1,
    tablet: 1.25,
    laptop: 1.4,
    desktop: 1.5,
    desktopL: 1.6,
    ultraWide: 2,
  });
};

// Responsive font size calculator
export const responsiveFontSize = (base: number): number => {
  return responsiveDimension(base, {
    mobile: 1,
    mobileL: 1.02,
    tablet: 1.1,
    laptop: 1.15,
    desktop: 1.2,
    desktopL: 1.25,
    ultraWide: 1.4,
  });
};

// Container width calculator
export const getContainerWidth = (maxWidth?: number): number => {
  const { width } = getScreenDimensions();
  const breakpoint = getCurrentBreakpoint();
  
  const containerMaxWidths = {
    mobile: width,
    mobileL: width,
    tablet: 720,
    laptop: 960,
    desktop: 1200,
    desktopL: 1400,
    ultraWide: 1800,
  };
  
  const defaultMaxWidth = containerMaxWidths[breakpoint];
  const finalMaxWidth = maxWidth || defaultMaxWidth;
  
  return Math.min(width, finalMaxWidth);
};

// Adaptive layout configurations
export const getLayoutConfig = (width?: number) => {
  const breakpoint = getCurrentBreakpoint(width);
  
  const configs = {
    mobile: {
      navigation: 'bottom',
      sidebar: false,
      columns: 1,
      cardColumns: 1,
      analyticsColumns: 1,
    },
    mobileL: {
      navigation: 'bottom',
      sidebar: false,
      columns: 1,
      cardColumns: 1,
      analyticsColumns: 1,
    },
    tablet: {
      navigation: 'top',
      sidebar: false,
      columns: 2,
      cardColumns: 2,
      analyticsColumns: 2,
    },
    laptop: {
      navigation: 'sidebar',
      sidebar: true,
      columns: 3,
      cardColumns: 3,
      analyticsColumns: 3,
    },
    desktop: {
      navigation: 'sidebar',
      sidebar: true,
      columns: 4,
      cardColumns: 3,
      analyticsColumns: 4,
    },
    desktopL: {
      navigation: 'sidebar',
      sidebar: true,
      columns: 4,
      cardColumns: 4,
      analyticsColumns: 4,
    },
    ultraWide: {
      navigation: 'sidebar',
      sidebar: true,
      columns: 6,
      cardColumns: 5,
      analyticsColumns: 6,
    },
  };
  
  return configs[breakpoint];
};

// Media query helper
export const mediaQuery = (breakpoint: keyof typeof BREAKPOINTS): string => {
  return `@media (min-width: ${BREAKPOINTS[breakpoint]}px)`;
};

// Orientation utilities
export const isLandscape = (): boolean => {
  const { isLandscape } = getScreenDimensions();
  return isLandscape;
};

export const isPortrait = (): boolean => {
  const { isPortrait } = getScreenDimensions();
  return isPortrait;
};

// Safe area calculations
export const getSafeAreaPadding = () => {
  const breakpoint = getCurrentBreakpoint();
  
  return {
    top: responsiveValue({
      mobile: 44,
      tablet: 24,
      laptop: 0,
      desktop: 0,
    }),
    bottom: responsiveValue({
      mobile: 34,
      tablet: 24,
      laptop: 0,
      desktop: 0,
    }),
    left: responsiveValue({
      mobile: 0,
      tablet: 24,
      laptop: 32,
      desktop: 48,
    }),
    right: responsiveValue({
      mobile: 0,
      tablet: 24,
      laptop: 32,
      desktop: 48,
    }),
  };
};

// Animation duration based on screen size
export const getAnimationDuration = (base: number = 300): number => {
  return responsiveValue({
    mobile: base,
    tablet: base * 0.9,
    laptop: base * 0.8,
    desktop: base * 0.7,
  });
};

// Touch target sizes
export const getTouchTargetSize = (): number => {
  return responsiveValue({
    mobile: 44,
    tablet: 48,
    laptop: 40,
    desktop: 36,
  });
};

// Export all utilities
export default {
  BREAKPOINTS,
  GRID_CONFIG,
  PLATFORM,
  getScreenDimensions,
  getCurrentBreakpoint,
  responsiveValue,
  responsiveDimension,
  getGridConfig,
  calculateColumnWidth,
  responsiveSpacing,
  responsiveFontSize,
  getContainerWidth,
  getLayoutConfig,
  mediaQuery,
  isLandscape,
  isPortrait,
  getSafeAreaPadding,
  getAnimationDuration,
  getTouchTargetSize,
};
</file>

<file path="src/utils/validation.ts">
/**
 * Validation utilities for TDR Days app
 * Provides comprehensive validation for action registration
 */

import { ActionCategory, ParkArea, ParkType } from '../types/models';

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface ActionFormData {
  // Basic fields
  category: ActionCategory;
  area?: ParkArea;
  locationName: string;
  time: Date;
  duration: string;
  notes: string;
  rating: number;
  
  // Attraction-specific
  waitTime: string;
  fastPass: boolean;
  
  // Restaurant-specific
  mealType: 'BREAKFAST' | 'LUNCH' | 'DINNER' | 'SNACK';
  reservationMade: boolean;
  partySize: string;
  
  // Shopping-specific
  purchaseAmount: string;
  purchasedItems: string;
  
  // Show/Greeting-specific
  performerNames: string;
  showTime: string;
  meetingDuration: string;
}

export class ActionValidator {
  private errors: string[] = [];
  private warnings: string[] = [];

  /**
   * Validate complete action form data
   */
  validateAction(data: Partial<ActionFormData>, visitDate: Date): ValidationResult {
    this.errors = [];
    this.warnings = [];

    // Required field validation
    this.validateRequiredFields(data);
    
    // Time validation
    this.validateTime(data.time, visitDate);
    
    // Duration validation
    this.validateDuration(data.duration);
    
    // Category-specific validation
    this.validateCategorySpecificFields(data);
    
    // Business logic validation
    this.validateBusinessLogic(data);

    return {
      isValid: this.errors.length === 0,
      errors: this.errors,
      warnings: this.warnings,
    };
  }

  /**
   * Validate step completion for wizard flow
   */
  validateStep(step: number, data: Partial<ActionFormData>): ValidationResult {
    this.errors = [];
    this.warnings = [];

    switch (step) {
      case 0: // Category
        this.validateCategory(data.category);
        break;
      case 1: // Area
        this.validateArea(data.area);
        break;
      case 2: // Location
        this.validateLocation(data.locationName);
        break;
      case 3: // Details
        this.validateDetails(data);
        break;
      case 4: // Photos
        // Photos are optional, no validation needed
        break;
    }

    return {
      isValid: this.errors.length === 0,
      errors: this.errors,
      warnings: this.warnings,
    };
  }

  private validateRequiredFields(data: Partial<ActionFormData>) {
    if (!data.category) {
      this.errors.push('Category is required');
    }

    if (!data.area) {
      this.errors.push('Area is required');
    }

    if (!data.locationName?.trim()) {
      this.errors.push('Location name is required');
    } else if (data.locationName.trim().length < 2) {
      this.errors.push('Location name must be at least 2 characters');
    } else if (data.locationName.trim().length > 100) {
      this.errors.push('Location name must be less than 100 characters');
    }

    if (!data.time) {
      this.errors.push('Time is required');
    }
  }

  private validateCategory(category?: ActionCategory) {
    if (!category) {
      this.errors.push('Please select a category');
      return;
    }

    if (!Object.values(ActionCategory).includes(category)) {
      this.errors.push('Invalid category selected');
    }
  }

  private validateArea(area?: ParkArea) {
    if (!area) {
      this.errors.push('Please select an area');
      return;
    }

    // Area validation would depend on park type, but we don't have that context here
    // This would be handled at a higher level
  }

  private validateLocation(locationName?: string) {
    if (!locationName?.trim()) {
      this.errors.push('Please enter or select a location');
      return;
    }

    if (locationName.trim().length < 2) {
      this.errors.push('Location name must be at least 2 characters');
    }

    if (locationName.trim().length > 100) {
      this.errors.push('Location name must be less than 100 characters');
    }

    // Check for potentially invalid characters
    const invalidChars = /[<>{}[\]\\]/;
    if (invalidChars.test(locationName)) {
      this.errors.push('Location name contains invalid characters');
    }
  }

  private validateTime(time?: Date, visitDate?: Date) {
    if (!time) {
      return; // Already handled in required fields
    }

    if (!(time instanceof Date) || isNaN(time.getTime())) {
      this.errors.push('Invalid time format');
      return;
    }

    if (visitDate) {
      const timeDate = new Date(time);
      const visit = new Date(visitDate);
      
      // Check if time is on the same day as visit
      if (timeDate.toDateString() !== visit.toDateString()) {
        this.warnings.push('Time is not on the same day as your visit');
      }
      
      // Check for reasonable time ranges (4 AM to 11:59 PM)
      const hours = timeDate.getHours();
      if (hours < 4 || hours >= 24) {
        this.warnings.push('Time seems outside typical park hours');
      }
    }

    // Check if time is in the future for today's visits
    const now = new Date();
    if (visitDate && 
        visitDate.toDateString() === now.toDateString() && 
        time > now) {
      this.warnings.push('Time is in the future');
    }
  }

  private validateDuration(duration?: string) {
    if (!duration?.trim()) {
      return; // Duration is optional
    }

    const durationNum = parseFloat(duration);
    if (isNaN(durationNum)) {
      this.errors.push('Duration must be a valid number');
      return;
    }

    if (durationNum < 0) {
      this.errors.push('Duration cannot be negative');
    } else if (durationNum > 720) { // 12 hours
      this.warnings.push('Duration seems very long (over 12 hours)');
    } else if (durationNum > 0 && durationNum < 1) {
      this.warnings.push('Duration seems very short (less than 1 minute)');
    }
  }

  private validateDetails(data: Partial<ActionFormData>) {
    // Notes validation
    if (data.notes && data.notes.length > 1000) {
      this.errors.push('Notes must be less than 1000 characters');
    }

    // Rating validation
    if (data.rating !== undefined && data.rating !== 0) {
      if (data.rating < 1 || data.rating > 5) {
        this.errors.push('Rating must be between 1 and 5');
      }
    }
  }

  private validateCategorySpecificFields(data: Partial<ActionFormData>) {
    switch (data.category) {
      case ActionCategory.ATTRACTION:
        this.validateAttractionFields(data);
        break;
      case ActionCategory.RESTAURANT:
        this.validateRestaurantFields(data);
        break;
      case ActionCategory.SHOPPING:
        this.validateShoppingFields(data);
        break;
      case ActionCategory.SHOW:
      case ActionCategory.GREETING:
        this.validateShowGreetingFields(data);
        break;
    }
  }

  private validateAttractionFields(data: Partial<ActionFormData>) {
    // Wait time validation
    if (data.waitTime?.trim()) {
      const waitTimeNum = parseFloat(data.waitTime);
      if (isNaN(waitTimeNum)) {
        this.errors.push('Wait time must be a valid number');
      } else if (waitTimeNum < 0) {
        this.errors.push('Wait time cannot be negative');
      } else if (waitTimeNum > 300) { // 5 hours
        this.warnings.push('Wait time seems very long (over 5 hours)');
      }
    }
  }

  private validateRestaurantFields(data: Partial<ActionFormData>) {
    // Meal type validation
    const validMealTypes = ['BREAKFAST', 'LUNCH', 'DINNER', 'SNACK'];
    if (data.mealType && !validMealTypes.includes(data.mealType)) {
      this.errors.push('Invalid meal type');
    }

    // Party size validation
    if (data.partySize?.trim()) {
      const partySizeNum = parseInt(data.partySize);
      if (isNaN(partySizeNum)) {
        this.errors.push('Party size must be a valid number');
      } else if (partySizeNum < 1) {
        this.errors.push('Party size must be at least 1');
      } else if (partySizeNum > 20) {
        this.warnings.push('Very large party size');
      }
    }
  }

  private validateShoppingFields(data: Partial<ActionFormData>) {
    // Purchase amount validation
    if (data.purchaseAmount?.trim()) {
      const amountNum = parseFloat(data.purchaseAmount);
      if (isNaN(amountNum)) {
        this.errors.push('Purchase amount must be a valid number');
      } else if (amountNum < 0) {
        this.errors.push('Purchase amount cannot be negative');
      } else if (amountNum > 1000000) { // 1 million yen
        this.warnings.push('Very large purchase amount');
      }
    }

    // Items validation
    if (data.purchasedItems && data.purchasedItems.length > 500) {
      this.errors.push('Purchased items description is too long');
    }
  }

  private validateShowGreetingFields(data: Partial<ActionFormData>) {
    // Performer names validation
    if (data.performerNames && data.performerNames.length > 200) {
      this.errors.push('Performer names list is too long');
    }

    // Show time validation
    if (data.showTime && data.showTime.length > 50) {
      this.errors.push('Show time description is too long');
    }

    // Meeting duration validation (for greetings)
    if (data.meetingDuration?.trim()) {
      const durationNum = parseFloat(data.meetingDuration);
      if (isNaN(durationNum)) {
        this.errors.push('Meeting duration must be a valid number');
      } else if (durationNum < 0) {
        this.errors.push('Meeting duration cannot be negative');
      } else if (durationNum > 60) {
        this.warnings.push('Very long meeting duration');
      }
    }
  }

  private validateBusinessLogic(data: Partial<ActionFormData>) {
    // Fast Pass logic for attractions
    if (data.category === ActionCategory.ATTRACTION && data.fastPass) {
      if (data.waitTime && parseFloat(data.waitTime) > 10) {
        this.warnings.push('Fast Pass usually reduces wait time significantly');
      }
    }

    // Meal type vs time consistency
    if (data.category === ActionCategory.RESTAURANT && data.time && data.mealType) {
      const hours = data.time.getHours();
      const mealTime = this.getMealTimeRange(data.mealType);
      
      if (hours < mealTime.start || hours > mealTime.end) {
        this.warnings.push(`${data.mealType.toLowerCase()} time seems unusual for ${hours}:00`);
      }
    }

    // Shopping amount vs items consistency
    if (data.category === ActionCategory.SHOPPING) {
      const hasAmount = data.purchaseAmount?.trim() && parseFloat(data.purchaseAmount) > 0;
      const hasItems = data.purchasedItems?.trim();
      
      if (hasAmount && !hasItems) {
        this.warnings.push('Consider adding what items you purchased');
      } else if (hasItems && !hasAmount) {
        this.warnings.push('Consider adding the purchase amount');
      }
    }
  }

  private getMealTimeRange(mealType: string): { start: number; end: number } {
    switch (mealType) {
      case 'BREAKFAST':
        return { start: 6, end: 11 };
      case 'LUNCH':
        return { start: 11, end: 15 };
      case 'DINNER':
        return { start: 17, end: 22 };
      case 'SNACK':
        return { start: 8, end: 21 };
      default:
        return { start: 0, end: 23 };
    }
  }
}

// Convenience functions
export const validateAction = (data: Partial<ActionFormData>, visitDate: Date): ValidationResult => {
  const validator = new ActionValidator();
  return validator.validateAction(data, visitDate);
};

export const validateStep = (step: number, data: Partial<ActionFormData>): ValidationResult => {
  const validator = new ActionValidator();
  return validator.validateStep(step, data);
};

// Location name sanitization
export const sanitizeLocationName = (name: string): string => {
  return name
    .trim()
    .replace(/[<>{}[\]\\]/g, '') // Remove invalid characters
    .replace(/\s+/g, ' ') // Normalize whitespace
    .substring(0, 100); // Limit length
};

// Time validation helpers
export const isValidTime = (time: Date, visitDate: Date): boolean => {
  if (!(time instanceof Date) || isNaN(time.getTime())) {
    return false;
  }
  
  // Should be on the same day or reasonable nearby
  const timeDiff = Math.abs(time.getTime() - visitDate.getTime());
  const oneDayMs = 24 * 60 * 60 * 1000;
  
  return timeDiff <= oneDayMs;
};

// Duration validation helpers
export const isValidDuration = (duration: string): boolean => {
  if (!duration.trim()) return true; // Optional field
  
  const num = parseFloat(duration);
  return !isNaN(num) && num >= 0 && num <= 720;
};

// Amount validation helpers
export const isValidAmount = (amount: string): boolean => {
  if (!amount.trim()) return true; // Optional field
  
  const num = parseFloat(amount);
  return !isNaN(num) && num >= 0 && num <= 1000000;
};
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo
</file>

<file path="app.json">
{
  "expo": {
    "name": "TDR-Days",
    "slug": "TDR-Days",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true,
      "icon": "./assets/AppIcons/appstore.png"
    },
    "android": {
      "icon": "./assets/AppIcons/playstore.png",
      "adaptiveIcon": {
        "foregroundImage": "./assets/AppIcons/android/mipmap-xxxhdpi/ic_launcher.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "package": "com.hayatonakamura.TDRDays"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "extra": {
      "eas": {
        "projectId": "3722fcb4-a34c-4d31-ba52-723b382a2a4b"
      }
    },
    "owner": "hayatonakamura"
  }
}
</file>

<file path="App.tsx">
import React, { useState, useEffect } from 'react';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { ThemeProvider } from './src/contexts/ThemeContext';
import { LanguageProvider } from './src/contexts/LanguageContext';
import { AppNavigator } from './src/navigation/AppNavigator';
import { ProfileSetupModal } from './src/components/ProfileSetupModal';
import { profileService, UserProfile } from './src/services/profileService';

export default function App() {
  const [isProfileChecked, setIsProfileChecked] = useState(false);
  const [showProfileSetup, setShowProfileSetup] = useState(false);
  const [currentProfile, setCurrentProfile] = useState<UserProfile | null>(null);

  useEffect(() => {
    checkProfileStatus();
  }, []);

  const checkProfileStatus = async () => {
    try {
      const hasProfile = await profileService.hasProfile();
      if (!hasProfile) {
        setShowProfileSetup(true);
      } else {
        const profile = await profileService.getProfile();
        setCurrentProfile(profile);
      }
    } catch (error) {
      console.error('Error checking profile status:', error);
    } finally {
      setIsProfileChecked(true);
    }
  };

  const handleProfileComplete = (profile: UserProfile) => {
    setCurrentProfile(profile);
    setShowProfileSetup(false);
  };

  if (!isProfileChecked) {
    return null; // Show loading or splash screen if needed
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <LanguageProvider>
          <ThemeProvider>
            <AppNavigator />
            <ProfileSetupModal
              visible={showProfileSetup}
              onComplete={handleProfileComplete}
            />
            <StatusBar style="auto" />
          </ThemeProvider>
        </LanguageProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
</file>

<file path="babel.config.js">
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      'react-native-reanimated/plugin',
    ],
  };
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {},
  "extends": "expo/tsconfig.base"
}
</file>

<file path="src/navigation/TabNavigator.tsx">
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Dimensions,
  Platform,
} from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';

// Import screens
import { HomeScreen } from '../screens/HomeScreen';
import { RecordScreen } from '../screens/RecordScreen';
import { AnalyticsScreen } from '../screens/AnalyticsScreen';
import { ProfileScreen } from '../screens/ProfileScreen';
import { VisitListScreen } from '../screens/VisitListScreen';

const Tab = createBottomTabNavigator();
const { width } = Dimensions.get('window');

// Simple Material Design Tab Bar
const CustomTabBar = ({ state, descriptors, navigation }: any) => {
  const insets = useSafeAreaInsets();
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';

  return (
    <View style={[
      styles.tabBarContainer,
      {
        backgroundColor: isDark ? theme.colors.background.card : '#ffffff',
        paddingBottom: insets.bottom,
        borderTopColor: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
      }
    ]}>
      <View style={styles.tabBar}>
        {state.routes.map((route: any, index: number) => {
          const { options } = descriptors[route.key];
          const isFocused = state.index === index;

          const onPress = () => {
            const event = navigation.emit({
              type: 'tabPress',
              target: route.key,
              canPreventDefault: true,
            });

            if (!isFocused && !event.defaultPrevented) {
              navigation.navigate(route.name);
            }
          };

          return (
            <TouchableOpacity
              key={index}
              accessibilityRole="button"
              accessibilityState={isFocused ? { selected: true } : {}}
              onPress={onPress}
              style={styles.tabButton}
              activeOpacity={0.6}
            >
              <View style={styles.tabContent}>
                <View style={[
                  styles.iconContainer,
                  isFocused && styles.iconContainerActive,
                ]}>
                  <Ionicons
                    name={options.tabBarIcon}
                    size={24}
                    color={
                      isFocused
                        ? colors.purple[600]
                        : theme.colors.text.secondary
                    }
                  />
                </View>
                <Text
                  style={[
                    styles.tabLabel,
                    {
                      color: isFocused
                        ? colors.purple[600]
                        : theme.colors.text.secondary,
                      fontWeight: isFocused ? '600' : '500',
                    },
                  ]}
                >
                  {options.tabBarLabel}
                </Text>
              </View>
            </TouchableOpacity>
          );
        })}
      </View>
    </View>
  );
};

export const TabNavigator = () => {
  const { theme } = useTheme();
  const { t } = useLanguage();

  return (
    <Tab.Navigator
      tabBar={(props) => <CustomTabBar {...props} />}
      screenOptions={{
        headerShown: false,
      }}
    >
      <Tab.Screen
        name="Home"
        component={HomeScreen}
        options={{
          tabBarLabel: t('nav.home'),
          tabBarIcon: 'home' as any,
        }}
      />
      <Tab.Screen
        name="VisitList"
        component={VisitListScreen}
        options={{
          tabBarLabel: t('nav.visitList'),
          tabBarIcon: 'list' as any,
        }}
      />
      <Tab.Screen
        name="Record"
        component={RecordScreen}
        options={{
          tabBarLabel: t('nav.record'),
          tabBarIcon: 'add-circle' as any,
        }}
      />
      <Tab.Screen
        name="Analytics"
        component={AnalyticsScreen}
        options={{
          tabBarLabel: t('nav.analytics'),
          tabBarIcon: 'stats-chart' as any,
        }}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
        options={{
          tabBarLabel: t('nav.profile'),
          tabBarIcon: 'person' as any,
        }}
      />
    </Tab.Navigator>
  );
};

const styles = StyleSheet.create({
  tabBarContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    borderTopWidth: 1,
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: -2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 8,
  },
  tabBar: {
    flexDirection: 'row',
    height: Platform.OS === 'ios' ? 65 : 60,
    paddingTop: spacing[2],
    paddingHorizontal: spacing[2],
  },
  tabButton: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: spacing[1],
  },
  tabContent: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  iconContainer: {
    marginBottom: 2,
  },
  iconContainerActive: {
    // Material design ripple effect could be added here
  },
  tabLabel: {
    fontSize: 11,
    textAlign: 'center',
  },
});
</file>

<file path="src/screens/AnalyticsScreen.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Alert,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { Header } from '../components/Header';
import { SwipeableScreen } from '../components/SwipeableScreen';
import { DrawerMenu } from '../components/DrawerMenu';
import { useVisits } from '../hooks/useVisits';
import { useActions } from '../hooks/useActions';
import { useResponsive, useColumns } from '../hooks/useResponsive';
import { ResponsiveContainer, ResponsiveSection, ResponsiveRow } from '../components/layouts/ResponsiveContainer';
import {
  StatsCard,
  SimplePieChart,
  BarChart,
  LineChart,
  HeatMap,
  TopRankingList,
  type SimplePieChartData,
  type BarChartData,
  type LineChartData,
  type HeatMapData,
  type RankingItem,
} from '../components/charts';
import {
  Visit,
  TimelineAction,
  ActionCategory,
  ParkType,
  ParkArea,
  VisitFilter,
  ActionFilter,
  DateRange,
} from '../types/models';

// Period types for analytics
type PeriodType = 'monthly' | 'yearly' | 'all-time' | 'custom';

// Custom date range state
interface CustomDateRange {
  startDate: Date;
  endDate: Date;
}

// Specific period selector
interface SpecificPeriod {
  type: 'month' | 'year';
  value: number; // month: 0-11, year: actual year
}

export const AnalyticsScreen = () => {
  const { theme } = useTheme();
  const { t } = useLanguage();
  const isDark = theme.mode === 'dark';
  
  // Add error state for crash handling
  const [hasError, setHasError] = useState(false);
  
  // Error boundary effect
  useEffect(() => {
    const handleError = (error: any) => {
      console.error('Analytics screen error:', error);
      setHasError(true);
    };
    
    // Reset error state when component mounts
    setHasError(false);
    
    return () => {
      // Cleanup if needed
    };
  }, []);
  const { 
    dimensions, 
    breakpoint, 
    rSpacing, 
    rFontSize,
    isBreakpoint,
    layoutConfig 
  } = useResponsive();
  
  // Memoize column calculations to prevent excessive re-renders
  const statsColumns = useMemo(() => {
    if (!breakpoint) return 2; // Fallback
    const config = {
      mobile: 2,
      mobileL: 2,
      tablet: 4,
      laptop: 4,
      desktop: 4,
      desktopL: 4,
      ultraWide: 6,
    };
    return config[breakpoint] || 2;
  }, [breakpoint]);
  
  const chartColumns = useMemo(() => {
    if (!breakpoint) return 1; // Fallback
    const config = {
      mobile: 1,
      mobileL: 1,
      tablet: 2,
      laptop: 3,
      desktop: 3,
      desktopL: 4,
      ultraWide: 4,
    };
    return config[breakpoint] || 1;
  }, [breakpoint]);
  
  // Data hooks
  const {
    visits,
    companions,
    isLoading: visitsLoading,
    getVisitStatistics,
    getFilteredVisits,
  } = useVisits();
  
  const {
    actions,
    isLoading: actionsLoading,
    getActionStatistics,
    getFilteredActions,
  } = useActions();

  // State
  const [selectedPeriod, setSelectedPeriod] = useState<PeriodType>('yearly');
  const [specificPeriod, setSpecificPeriod] = useState<SpecificPeriod>({
    type: 'year',
    value: new Date().getFullYear(),
  });
  const [customDateRange, setCustomDateRange] = useState<CustomDateRange>({
    startDate: new Date(new Date().getFullYear(), 0, 1),
    endDate: new Date(),
  });
  const [selectedChart, setSelectedChart] = useState<string | null>(null);
  const [isExporting, setIsExporting] = useState(false);
  const [menuVisible, setMenuVisible] = useState(false);

  // Responsive states
  const isTabletOrLarger = isBreakpoint('tablet');
  const isLaptopOrLarger = isBreakpoint('laptop');

  const periods: { key: PeriodType; label: string; icon: keyof typeof Ionicons.glyphMap }[] = [
    { key: 'monthly', label: t('analytics.monthly'), icon: 'calendar' },
    { key: 'yearly', label: t('analytics.yearly'), icon: 'calendar-outline' },
    { key: 'all-time', label: t('analytics.allTime'), icon: 'infinite' },
    { key: 'custom', label: t('analytics.custom'), icon: 'options' },
  ];

  // Loading state
  const isLoading = visitsLoading || actionsLoading;

  // Calculate current period filter
  const currentFilter = useMemo((): { visitFilter?: VisitFilter; actionFilter?: ActionFilter } => {
    let dateRange: DateRange | undefined;

    switch (selectedPeriod) {
      case 'monthly':
        if (specificPeriod.type === 'month') {
          const year = Math.floor(specificPeriod.value / 100);
          const month = specificPeriod.value % 100;
          dateRange = {
            startDate: new Date(year, month, 1),
            endDate: new Date(year, month + 1, 0),
          };
        } else {
          const now = new Date();
          dateRange = {
            startDate: new Date(now.getFullYear(), now.getMonth(), 1),
            endDate: new Date(now.getFullYear(), now.getMonth() + 1, 0),
          };
        }
        break;
      case 'yearly':
        if (specificPeriod.type === 'year') {
          dateRange = {
            startDate: new Date(specificPeriod.value, 0, 1),
            endDate: new Date(specificPeriod.value, 11, 31),
          };
        } else {
          const now = new Date();
          dateRange = {
            startDate: new Date(now.getFullYear(), 0, 1),
            endDate: new Date(now.getFullYear(), 11, 31),
          };
        }
        break;
      case 'custom':
        dateRange = {
          startDate: customDateRange.startDate,
          endDate: customDateRange.endDate,
        };
        break;
      case 'all-time':
      default:
        dateRange = undefined;
        break;
    }

    return {
      visitFilter: dateRange ? { dateRange } : undefined,
      actionFilter: dateRange ? { dateRange } : undefined,
    };
  }, [selectedPeriod, specificPeriod, customDateRange]);

  // Analytics data
  const [visitStats, setVisitStats] = useState<any>(null);
  const [actionStats, setActionStats] = useState<any>(null);

  // Load analytics data with comprehensive error handling
  useEffect(() => {
    let isMounted = true; // Prevent state updates if component unmounted
    
    const loadAnalytics = async () => {
      try {
        // Add timeout protection
        const timeout = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Analytics loading timeout')), 10000)
        );
        
        const analyticsPromise = Promise.all([
          getVisitStatistics(currentFilter.visitFilter),
          getActionStatistics(currentFilter.actionFilter),
        ]);
        
        const [visitData, actionData] = await Promise.race([analyticsPromise, timeout]);
        
        // Only update state if component is still mounted
        if (isMounted) {
          // Validate data structure before setting state
          if (visitData && typeof visitData === 'object' && !Array.isArray(visitData)) {
            setVisitStats(visitData);
          } else {
            console.warn('Invalid visit statistics data received:', visitData);
            setVisitStats(null);
          }
          
          if (actionData && typeof actionData === 'object' && !Array.isArray(actionData)) {
            setActionStats(actionData);
          } else {
            console.warn('Invalid action statistics data received:', actionData);
            setActionStats(null);
          }
        }
      } catch (error) {
        console.error('Failed to load analytics:', error);
        // Only update state if component is still mounted
        if (isMounted) {
          setVisitStats(null);
          setActionStats(null);
          setHasError(true);
        }
      }
    };

    if (!isLoading && getVisitStatistics && getActionStatistics && typeof getVisitStatistics === 'function' && typeof getActionStatistics === 'function') {
      loadAnalytics();
    }
    
    // Cleanup function
    return () => {
      isMounted = false;
    };
  }, [currentFilter, isLoading, getVisitStatistics, getActionStatistics]);

  // Statistics cards data
  const statsCards = useMemo(() => {
    if (!visitStats || !actionStats) return [];

    // Add safety checks for all data access
    const safeVisitStats = {
      totalVisits: visitStats?.totalVisits || 0,
      averageVisitDuration: visitStats?.averageVisitDuration || null,
    };

    const safeActionStats = {
      totalActions: actionStats?.totalActions || 0,
      averageActionsPerVisit: actionStats?.averageActionsPerVisit || 0,
      photoCount: actionStats?.photoCount || 0,
    };

    return [
      {
        title: t('analytics.totalVisits'),
        value: safeVisitStats.totalVisits,
        icon: 'calendar' as keyof typeof Ionicons.glyphMap,
        color: colors.purple[500],
        subtitle: selectedPeriod === 'all-time' ? t('analytics.allTime') : t('analytics.thisPeriod'),
      },
      {
        title: t('analytics.totalActions'),
        value: safeActionStats.totalActions,
        icon: 'rocket' as keyof typeof Ionicons.glyphMap,
        color: '#3b82f6',
        subtitle: `${safeActionStats.averageActionsPerVisit.toFixed(1)} ${t('analytics.perVisit')}`,
      },
      {
        title: t('analytics.photosTaken'),
        value: safeActionStats.photoCount,
        icon: 'camera' as keyof typeof Ionicons.glyphMap,
        color: '#22c55e',
        subtitle: t('analytics.memoriesCaptured'),
      },
      {
        title: t('analytics.avgVisitDuration'),
        value: safeVisitStats.averageVisitDuration
          ? `${Math.round(safeVisitStats.averageVisitDuration / 60)}h`
          : 'N/A',
        icon: 'time' as keyof typeof Ionicons.glyphMap,
        color: '#facc15',
        subtitle: t('analytics.hoursPerVisit'),
      },
    ];
  }, [visitStats, actionStats, selectedPeriod, t]);

  // Pie chart data for park visits
  const parkVisitsData = useMemo((): SimplePieChartData[] => {
    if (!visitStats || typeof visitStats.totalVisits !== 'number') return [];

    const totalVisits = visitStats.totalVisits || 0;
    const landVisits = visitStats.landVisits || 0;
    const seaVisits = visitStats.seaVisits || 0;

    const data = [
      {
        label: t('home.tokyoDisneyland'),
        value: landVisits,
        color: colors.purple[500],
        percentage: totalVisits > 0 ? Math.round((landVisits / totalVisits) * 100 * 10) / 10 : 0,
      },
      {
        label: t('home.tokyoDisneysea'),
        value: seaVisits,
        color: '#06b6d4',
        percentage: totalVisits > 0 ? Math.round((seaVisits / totalVisits) * 100 * 10) / 10 : 0,
      },
    ];

    const filteredData = data.filter(item => item.value > 0);
    
    return filteredData;
  }, [visitStats]);

  // Action categories pie chart
  const actionCategoriesData = useMemo((): SimplePieChartData[] => {
    try {
      if (!actionStats || 
          !actionStats.actionsByCategory || 
          typeof actionStats.actionsByCategory !== 'object' ||
          actionStats.actionsByCategory === null) {
        return [];
      }

      const categoryColors = {
        [ActionCategory.ATTRACTION]: colors.purple[500],
        [ActionCategory.RESTAURANT]: '#22c55e',
        [ActionCategory.SHOW]: '#3b82f6',
        [ActionCategory.GREETING]: '#ec4899',
        [ActionCategory.SHOPPING]: '#facc15',
      };

      // Safely get entries with additional validation
      const entries = Object.entries(actionStats.actionsByCategory || {});
      if (!Array.isArray(entries) || entries.length === 0) {
        return [];
      }

      return entries
        .filter(([category, count]) => {
          return category && 
                 typeof category === 'string' && 
                 typeof count === 'number' && 
                 !isNaN(count) && 
                 count > 0;
        })
        .map(([category, count]) => {
          try {
            return {
              label: category.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase()),
              value: count as number,
              color: categoryColors[category as ActionCategory] || '#64748b',
            };
          } catch (error) {
            console.warn('Error processing category:', category, error);
            return null;
          }
        })
        .filter(Boolean) // Remove null entries
        .sort((a, b) => (b?.value || 0) - (a?.value || 0));
    } catch (error) {
      console.error('Error in actionCategoriesData:', error);
      return [];
    }
  }, [actionStats]);

  // Top attractions ranking
  const topAttractionsData = useMemo((): RankingItem[] => {
    try {
      if (!actionStats || 
          !actionStats.topAttractions || 
          !Array.isArray(actionStats.topAttractions) ||
          actionStats.topAttractions.length === 0) {
        return [];
      }

      return actionStats.topAttractions
        .filter(attraction => attraction && typeof attraction === 'object')
        .map((attraction: any, index: number) => {
          try {
            const waitTime = attraction?.averageWaitTime;
            return {
              id: attraction?.id || `attraction-${index}`,
              name: attraction?.locationName || 'Unknown',
              value: typeof attraction?.count === 'number' ? attraction.count : 0,
              subtitle: waitTime && typeof waitTime === 'number' && !isNaN(waitTime)
                ? `${Math.round(waitTime)}min avg wait`
                : undefined,
              color: colors.purple[500],
              trend: index < 3 ? 'up' : 'neutral' as const,
            };
          } catch (error) {
            console.warn('Error processing attraction:', attraction, error);
            return null;
          }
        })
        .filter(Boolean); // Remove null entries
    } catch (error) {
      console.error('Error in topAttractionsData:', error);
      return [];
    }
  }, [actionStats]);

  // Top restaurants ranking
  const topRestaurantsData = useMemo((): RankingItem[] => {
    try {
      if (!actionStats || 
          !actionStats.topRestaurants || 
          !Array.isArray(actionStats.topRestaurants) ||
          actionStats.topRestaurants.length === 0) {
        return [];
      }

      return actionStats.topRestaurants
        .filter(restaurant => restaurant && typeof restaurant === 'object')
        .map((restaurant: any, index: number) => {
          try {
            return {
              id: restaurant?.id || `restaurant-${index}`,
              name: restaurant?.locationName || 'Unknown',
              value: typeof restaurant?.count === 'number' ? restaurant.count : 0,
              subtitle: t('analytics.visits'),
              color: '#22c55e',
              trend: index < 3 ? 'up' : 'neutral' as const,
            };
          } catch (error) {
            console.warn('Error processing restaurant:', restaurant, error);
            return null;
          }
        })
        .filter(Boolean); // Remove null entries
    } catch (error) {
      console.error('Error in topRestaurantsData:', error);
      return [];
    }
  }, [actionStats, t]);

  // Area distribution bar chart
  const areaDistributionData = useMemo((): BarChartData[] => {
    if (!actionStats || !actionStats.areaDistribution || !Array.isArray(actionStats.areaDistribution)) {
      return [];
    }

    return actionStats.areaDistribution
      .slice(0, 10) // Top 10 areas
      .map((area: any) => ({
        label: area?.area ? area.area.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, (l: string) => l.toUpperCase()) : 'Unknown',
        value: area?.visitCount || 0,
        description: area?.timeSpent ? `${Math.round(area.timeSpent / 60)}h spent` : undefined,
      }));
  }, [actionStats]);

  // Visits over time line chart
  const visitsTimelineData = useMemo((): LineChartData[] => {
    try {
      if (!visitStats || typeof visitStats !== 'object') return [];

      if (selectedPeriod === 'yearly' || selectedPeriod === 'all-time') {
        if (!visitStats.visitsByYear || !Array.isArray(visitStats.visitsByYear)) {
          return [];
        }
        return visitStats.visitsByYear
          .filter(item => item && typeof item === 'object')
          .map((item: any) => {
            try {
              return {
                x: item?.year?.toString() || '0',
                y: typeof item?.count === 'number' ? item.count : 0,
                label: item?.year?.toString() || '0',
              };
            } catch (error) {
              console.warn('Error processing year data:', item, error);
              return { x: '0', y: 0, label: '0' };
            }
          });
      } else {
        if (!visitStats.visitsByMonth || !Array.isArray(visitStats.visitsByMonth)) {
          return [];
        }
        return visitStats.visitsByMonth
          .filter(item => item && typeof item === 'object')
          .map((item: any) => {
            try {
              let label = '';
              if (item?.month && typeof item.month === 'string') {
                try {
                  label = new Date(item.month + '-01').toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                } catch (dateError) {
                  label = item.month;
                }
              }
              return {
                x: item?.month || '',
                y: typeof item?.count === 'number' ? item.count : 0,
                label,
              };
            } catch (error) {
              console.warn('Error processing month data:', item, error);
              return { x: '', y: 0, label: '' };
            }
          });
      }
    } catch (error) {
      console.error('Error in visitsTimelineData:', error);
      return [];
    }
  }, [visitStats, selectedPeriod]);

  // Heat map data for visit frequency
  const visitHeatMapData = useMemo((): HeatMapData[] => {
    if (!visits || !Array.isArray(visits)) {
      return [];
    }
    
    return visits.map(visit => ({
      date: new Date(visit?.date || new Date()),
      value: 1, // Each visit counts as 1
      label: `Visit to ${visit?.parkType === ParkType.LAND ? t('park.disneyland') : t('park.disneysea')}`,
      description: visit?.notes || undefined,
    }));
  }, [visits]);

  // Companion analysis
  const companionData = useMemo((): RankingItem[] => {
    if (!visitStats || !visitStats.favoriteCompanions || !Array.isArray(visitStats.favoriteCompanions)) {
      return [];
    }

    return visitStats.favoriteCompanions.map((item: any, index: number) => ({
      id: item?.companion?.id || `companion-${index}`,
      name: item?.companion?.name || 'Unknown',
      value: item?.visitCount || 0,
      subtitle: t('analytics.visitsTogether'),
      color: '#ec4899',
      trend: index < 3 ? 'up' : 'neutral' as const,
    }));
  }, [visitStats]);

  // Export functionality
  const handleExport = async () => {
    try {
      setIsExporting(true);
      
      // Create a simple analytics report
      const report = {
        period: selectedPeriod,
        generatedAt: new Date().toISOString(),
        stats: {
          totalVisits: visitStats?.totalVisits || 0,
          totalActions: actionStats?.totalActions || 0,
          photoCount: actionStats?.photoCount || 0,
        },
        topAttractions: topAttractionsData.slice(0, 5),
        topRestaurants: topRestaurantsData.slice(0, 5),
      };

      // For now, just show the data in an alert
      const topAttraction = topAttractionsData.length > 0 ? topAttractionsData[0]?.name : 'None';
      const topRestaurant = topRestaurantsData.length > 0 ? topRestaurantsData[0]?.name : 'None';
      
      const summary = `${t('analytics.title')} (${selectedPeriod}):\n\n` +
        `• ${t('analytics.totalVisits')}: ${report.stats.totalVisits}\n` +
        `• ${t('analytics.totalActions')}: ${report.stats.totalActions}\n` +
        `• ${t('analytics.photosTaken')}: ${report.stats.photoCount}\n\n` +
        `${t('analytics.topAttractions')}: ${topAttraction}\n` +
        `${t('analytics.favoriteRestaurants')}: ${topRestaurant}`;
      
      Alert.alert(t('analytics.exportSuccess'), summary);
    } catch (error) {
      Alert.alert(t('analytics.exportError'), t('analytics.exportErrorMessage'));
    } finally {
      setIsExporting(false);
    }
  };

  // Render stat card
  const renderStatCard = (stat: any, index: number) => (
    <StatsCard
      key={index}
      title={stat.title}
      value={stat.value}
      icon={stat.icon}
      color={stat.color}
      subtitle={stat.subtitle}
      animationDelay={index * 100}
    />
  );

  // Render chart component
  const renderChart = (chart: any, index: number) => {
    // Additional safety checks for chart rendering
    if (!chart || typeof chart !== 'object') {
      return null;
    }

    switch (chart.type) {
      case 'pie':
        // Validate pie chart data before rendering
        if (!Array.isArray(chart.data) || chart.data.length === 0) {
          return null;
        }
        
        // Extra validation for PieChart data
        const validPieData = chart.data.filter(item => 
          item &&
          typeof item.value === 'number' &&
          !isNaN(item.value) &&
          item.value > 0 &&
          typeof item.label === 'string' &&
          typeof item.color === 'string'
        );
        
        if (validPieData.length === 0) {
          return null;
        }
        
        try {
          return (
            <SimplePieChart
              key={chart.key || `pie-${index}`}
              data={validPieData}
              title={chart.title || 'Chart'}
              size={isTabletOrLarger ? 280 : 250}
            />
          );
        } catch (error) {
          console.error('Error rendering SimplePieChart:', error);
          return null;
        }
      case 'line':
        return (
          <LineChart
            key={chart.key}
            data={chart.data}
            title={chart.title}
            color={chart.color}
            height={isTabletOrLarger ? 320 : 280}
            animationDelay={chart.delay}
          />
        );
      case 'bar':
        return (
          <BarChart
            key={chart.key}
            data={chart.data}
            title={chart.title}
            orientation="horizontal"
            height={isTabletOrLarger ? 360 : 300}
            animationDelay={chart.delay}
          />
        );
      case 'heatmap':
        return (
          <HeatMap
            key={chart.key}
            data={chart.data}
            title={chart.title}
            color={chart.color}
            animationDelay={chart.delay}
          />
        );
      default:
        return null;
    }
  };

  // Prepare charts data for grid rendering
  const chartsData = useMemo(() => {
    const charts = [];
    
    // Validate and sanitize park visits data before adding to charts
    if (Array.isArray(parkVisitsData) && parkVisitsData.length > 0) {
      const validParkData = parkVisitsData.filter(item => 
        item && 
        typeof item === 'object' && 
        typeof item.value === 'number' && 
        !isNaN(item.value) && 
        item.value > 0 &&
        typeof item.label === 'string' &&
        typeof item.color === 'string'
      );
      
      if (validParkData.length > 0) {
        charts.push({
          key: 'park-visits',
          type: 'pie',
          data: validParkData,
          title: t('analytics.parkVisitsDistribution'),
          delay: 400,
        });
      }
    }
    
    // Validate and sanitize action categories data before adding to charts
    if (Array.isArray(actionCategoriesData) && actionCategoriesData.length > 0) {
      const validActionData = actionCategoriesData.filter(item => 
        item && 
        typeof item === 'object' && 
        typeof item.value === 'number' && 
        !isNaN(item.value) && 
        item.value > 0 &&
        typeof item.label === 'string' &&
        typeof item.color === 'string'
      );
      
      if (validActionData.length > 0) {
        charts.push({
          key: 'action-categories',
          type: 'pie',
          data: validActionData,
          title: t('analytics.activityBreakdown'),
          delay: 600,
        });
      }
    }
    
    if (visitsTimelineData.length > 0) {
      charts.push({
        key: 'visits-timeline',
        type: 'line',
        data: visitsTimelineData,
        title: t('analytics.visitsOverTime'),
        color: colors.purple[500],
        delay: 800,
      });
    }
    
    if (areaDistributionData.length > 0) {
      charts.push({
        key: 'area-distribution',
        type: 'bar',
        data: areaDistributionData,
        title: t('analytics.popularAreas'),
        delay: 1000,
      });
    }
    
    if (visitHeatMapData.length > 0) {
      charts.push({
        key: 'visit-heatmap',
        type: 'heatmap',
        data: visitHeatMapData,
        title: t('analytics.visitCalendar'),
        color: colors.purple[500],
        delay: 1200,
      });
    }
    
    return charts;
  }, [parkVisitsData, actionCategoriesData, visitsTimelineData, areaDistributionData, visitHeatMapData]);

  // Handle error state
  if (hasError) {
    return (
      <View style={[styles.container, { justifyContent: 'center', alignItems: 'center', padding: 20 }]}>
        <Text style={{ color: theme.colors.text.primary, fontSize: 18, marginBottom: 10 }}>
          {t('analytics.error') || 'エラーが発生しました'}
        </Text>
        <Text style={{ color: theme.colors.text.secondary, textAlign: 'center', marginBottom: 20 }}>
          {t('analytics.errorMessage') || '分析データの読み込みに失敗しました'}
        </Text>
        <TouchableOpacity
          style={{ 
            backgroundColor: colors.purple[500], 
            paddingHorizontal: 20, 
            paddingVertical: 10, 
            borderRadius: 8 
          }}
          onPress={() => setHasError(false)}
        >
          <Text style={{ color: 'white' }}>
            {t('common.retry') || '再試行'}
          </Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Early return if necessary dependencies are missing
  if (!t) {
    return (
      <View style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>
        <Text>Loading...</Text>
      </View>
    );
  }

  return (
    <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
      <View style={styles.container}>
        <Header 
          title={t('nav.analytics')} 
          onMenuOpen={() => setMenuVisible(true)}
          rightComponent={
            <TouchableOpacity
              onPress={handleExport}
              style={[
                styles.exportButton,
                {
                  backgroundColor: colors.purple.bright + '15',
                  padding: rSpacing(12),
                  borderRadius: rSpacing(12),
                  borderWidth: 1,
                  borderColor: colors.purple.bright + '30',
                }
              ]}
              disabled={isExporting || isLoading}
            >
              <Ionicons
                name={isExporting ? 'hourglass' : 'download'}
                size={20}
                color={colors.purple.bright}
              />
            </TouchableOpacity>
          }
        />
        
        <ResponsiveContainer
          padding={false}
          style={styles.scrollableContent}
        >

      {/* Period Selector */}
      <ResponsiveSection spacing="lg" style={{ marginTop: rSpacing(24) }}>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={{ paddingHorizontal: rSpacing(20) }}
        >
          <View style={[styles.periodButtons, { gap: rSpacing(12) }]}>
            {periods.map((period) => (
              <TouchableOpacity
                key={period.key}
                onPress={() => {
                  setSelectedPeriod(period.key);
                  if (period.key === 'monthly') {
                    setSpecificPeriod({ type: 'month', value: new Date().getFullYear() * 100 + new Date().getMonth() });
                  } else if (period.key === 'yearly') {
                    setSpecificPeriod({ type: 'year', value: new Date().getFullYear() });
                  }
                }}
                style={[
                  styles.periodButton,
                  selectedPeriod === period.key && styles.periodButtonActive,
                  {
                    minWidth: isTabletOrLarger ? 120 : 100,
                    borderRadius: rSpacing(24),
                  }
                ]}
              >
                <LinearGradient
                  colors={
                    selectedPeriod === period.key
                      ? ['#a855f7', '#9333ea']
                      : ['transparent', 'transparent']
                  }
                  style={[
                    styles.periodGradient,
                    {
                      paddingVertical: rSpacing(12),
                      paddingHorizontal: rSpacing(16),
                    }
                  ]}
                >
                  <Ionicons
                    name={period.icon}
                    size={16}
                    color={
                      selectedPeriod === period.key
                        ? colors.text.dark.primary
                        : theme.colors.text.secondary
                    }
                    style={{ marginRight: rSpacing(4) }}
                  />
                  <Text
                    style={[
                      styles.periodText,
                      {
                        color:
                          selectedPeriod === period.key
                            ? colors.text.dark.primary
                            : theme.colors.text.secondary,
                        fontSize: rFontSize(14),
                      },
                    ]}
                  >
                    {period.label}
                  </Text>
                </LinearGradient>
              </TouchableOpacity>
            ))}
          </View>
        </ScrollView>
        
        {/* Specific Period Selector */}
        {(selectedPeriod === 'monthly' || selectedPeriod === 'yearly') && (
          <View style={[styles.specificPeriodContainer, { paddingHorizontal: rSpacing(20), marginTop: rSpacing(20) }]}>
            {selectedPeriod === 'yearly' && (
              <View style={styles.yearSelector}>
                <TouchableOpacity
                  onPress={() => setSpecificPeriod(prev => ({ ...prev, value: prev.value - 1 }))}
                  style={[styles.periodArrow, { backgroundColor: theme.colors.background.elevated }]}
                >
                  <Ionicons name="chevron-back" size={20} color={theme.colors.text.secondary} />
                </TouchableOpacity>
                
                <View style={[styles.periodDisplay, { backgroundColor: theme.colors.background.elevated }]}>
                  <Text style={[styles.periodDisplayText, { color: theme.colors.text.primary }]}>
                    {specificPeriod.value}年
                  </Text>
                </View>
                
                <TouchableOpacity
                  onPress={() => setSpecificPeriod(prev => ({ ...prev, value: prev.value + 1 }))}
                  style={[styles.periodArrow, { backgroundColor: theme.colors.background.elevated }]}
                  disabled={specificPeriod.value >= new Date().getFullYear()}
                >
                  <Ionicons 
                    name="chevron-forward" 
                    size={20} 
                    color={specificPeriod.value >= new Date().getFullYear() ? theme.colors.text.disabled : theme.colors.text.secondary} 
                  />
                </TouchableOpacity>
              </View>
            )}
            
            {selectedPeriod === 'monthly' && (
              <View style={styles.monthSelector}>
                <TouchableOpacity
                  onPress={() => {
                    const currentYear = Math.floor(specificPeriod.value / 100);
                    const currentMonth = specificPeriod.value % 100;
                    const newMonth = currentMonth === 0 ? 11 : currentMonth - 1;
                    const newYear = currentMonth === 0 ? currentYear - 1 : currentYear;
                    setSpecificPeriod({ type: 'month', value: newYear * 100 + newMonth });
                  }}
                  style={[styles.periodArrow, { backgroundColor: theme.colors.background.elevated }]}
                >
                  <Ionicons name="chevron-back" size={20} color={theme.colors.text.secondary} />
                </TouchableOpacity>
                
                <View style={[styles.periodDisplay, { backgroundColor: theme.colors.background.elevated }]}>
                  <Text style={[styles.periodDisplayText, { color: theme.colors.text.primary }]}>
                    {Math.floor(specificPeriod.value / 100)}年{(specificPeriod.value % 100) + 1}月
                  </Text>
                </View>
                
                <TouchableOpacity
                  onPress={() => {
                    const currentYear = Math.floor(specificPeriod.value / 100);
                    const currentMonth = specificPeriod.value % 100;
                    const now = new Date();
                    const isCurrentOrFuture = currentYear > now.getFullYear() || 
                      (currentYear === now.getFullYear() && currentMonth >= now.getMonth());
                    
                    if (!isCurrentOrFuture) {
                      const newMonth = currentMonth === 11 ? 0 : currentMonth + 1;
                      const newYear = currentMonth === 11 ? currentYear + 1 : currentYear;
                      setSpecificPeriod({ type: 'month', value: newYear * 100 + newMonth });
                    }
                  }}
                  style={[styles.periodArrow, { backgroundColor: theme.colors.background.elevated }]}
                  disabled={(() => {
                    const currentYear = Math.floor(specificPeriod.value / 100);
                    const currentMonth = specificPeriod.value % 100;
                    const now = new Date();
                    return currentYear > now.getFullYear() || 
                      (currentYear === now.getFullYear() && currentMonth >= now.getMonth());
                  })()}
                >
                  <Ionicons 
                    name="chevron-forward" 
                    size={20} 
                    color={(() => {
                      const currentYear = Math.floor(specificPeriod.value / 100);
                      const currentMonth = specificPeriod.value % 100;
                      const now = new Date();
                      const isDisabled = currentYear > now.getFullYear() || 
                        (currentYear === now.getFullYear() && currentMonth >= now.getMonth());
                      return isDisabled ? theme.colors.text.disabled : theme.colors.text.secondary;
                    })()}
                  />
                </TouchableOpacity>
              </View>
            )}
          </View>
        )}
      </ResponsiveSection>

      {/* Loading State */}
      {isLoading ? (
        <View style={[styles.loadingContainer, { padding: rSpacing(32) }]}>
          <Text style={[
            styles.loadingText, 
            { 
              color: theme.colors.text.secondary,
              fontSize: rFontSize(16),
            }
          ]}>
            {t('analytics.loading')}
          </Text>
        </View>
      ) : (
        <>
          {/* Stats Cards */}
          <ResponsiveSection spacing="lg">
            <View style={[styles.statsGrid, { paddingHorizontal: rSpacing(20) }]}>
              {statsCards.map((stat, index) => {
                // Safe width calculation with fallbacks
                const safeStatsColumns = Math.max(1, statsColumns || 2);
                const safeDimensionsWidth = Math.max(300, dimensions?.width || 300);
                const safeSpacing = rSpacing ? rSpacing(52) : 52;
                const cardWidth = Math.max(100, (safeDimensionsWidth - safeSpacing) / safeStatsColumns);
                
                // Additional validation
                const finalCardWidth = isNaN(cardWidth) ? 150 : cardWidth;
                
                return (
                  <View key={index} style={[styles.statCardWrapper, { width: finalCardWidth }]}>
                    {renderStatCard(stat, index)}
                  </View>
                );
              })}
            </View>
          </ResponsiveSection>

          {/* Charts Section */}
          <ResponsiveSection spacing="lg">
            <View style={[styles.chartsSection, { paddingHorizontal: rSpacing(20) }]}>
              {chartsData.length > 0 ? (
                chartsData.map((chart, index) => renderChart(chart, index))
              ) : (
                <View style={{ padding: rSpacing(32), alignItems: 'center' }}>
                  <Text style={[{ color: theme.colors.text.secondary, fontSize: rFontSize(16) }]}>
                    {t('analytics.loading')}
                  </Text>
                </View>
              )}
            </View>
          </ResponsiveSection>

          {/* Rankings Section */}
          <ResponsiveSection spacing="lg">
            <View style={[styles.rankingsSection, { paddingHorizontal: rSpacing(20) }]}>
              {/* Top Attractions */}
              {Array.isArray(topAttractionsData) && topAttractionsData.length > 0 && (
                <TopRankingList
                  data={topAttractionsData}
                  title={t('analytics.topAttractions')}
                  limit={10}
                  animationDelay={1400}
                />
              )}

              {/* Top Restaurants */}
              {Array.isArray(topRestaurantsData) && topRestaurantsData.length > 0 && (
                <TopRankingList
                  data={topRestaurantsData}
                  title={t('analytics.favoriteRestaurants')}
                  limit={8}
                  animationDelay={1600}
                />
              )}

              {/* Favorite Companions */}
              {Array.isArray(companionData) && companionData.length > 0 && (
                <TopRankingList
                  data={companionData}
                  title={t('analytics.favoriteCompanions')}
                  limit={6}
                  animationDelay={1800}
                />
              )}
              
              {/* Show message if no ranking data */}
              {(!Array.isArray(topAttractionsData) || topAttractionsData.length === 0) && 
               (!Array.isArray(topRestaurantsData) || topRestaurantsData.length === 0) && 
               (!Array.isArray(companionData) || companionData.length === 0) && (
                <View style={{ padding: rSpacing(32), alignItems: 'center' }}>
                  <Text style={[{ color: theme.colors.text.secondary, fontSize: rFontSize(16) }]}>
                    {t('analytics.loading')}
                  </Text>
                </View>
              )}
            </View>
          </ResponsiveSection>
        </>
      )}

        {/* Bottom spacing */}
        <View style={{ height: rSpacing(100) }} />
        </ResponsiveContainer>
      </View>
      
      <DrawerMenu
        visible={menuVisible}
        onClose={() => setMenuVisible(false)}
      />
    </SwipeableScreen>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollableContent: {
    flex: 1,
  },
  exportButton: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  periodButtons: {
    flexDirection: 'row',
  },
  periodButton: {
    overflow: 'hidden',
  },
  periodButtonActive: {
  },
  periodGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  periodText: {
    fontWeight: '600',
  },
  loadingContainer: {
    alignItems: 'center',
  },
  loadingText: {
    fontWeight: '500',
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
  },
  statCardWrapper: {
    // Width calculated dynamically
  },
  chartsSection: {
    gap: 24,
  },
  rankingsSection: {
    gap: 24,
  },
  specificPeriodContainer: {
    alignItems: 'center',
  },
  yearSelector: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  monthSelector: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  periodArrow: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  periodDisplay: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 120,
    alignItems: 'center',
  },
  periodDisplayText: {
    fontSize: 16,
    fontWeight: '600',
  },
});
</file>

<file path="src/screens/VisitDetailScreen.tsx">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Share,
  Image,
} from 'react-native';
import { Ionicons, FontAwesome5 } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation, useRoute } from '@react-navigation/native';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { useVisits } from '../hooks/useVisits';
import { useActions } from '../hooks/useActions';
import { Visit, ParkType, TimelineAction, ActionCategory, LandArea, SeaArea } from '../types/models';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { Header } from '../components/Header';
import { SwipeableScreen } from '../components/SwipeableScreen';
import { DrawerMenu } from '../components/DrawerMenu';
import { ActionModal } from '../components/ActionModal';
import { ActionDetailModal } from '../components/ActionDetailModal';

interface RouteParams {
  visitId: string;
}

export const VisitDetailScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { theme } = useTheme();
  const { language } = useLanguage();
  const { getVisit, deleteVisit, companions } = useVisits();
  const { getActionsByVisit } = useActions();
  
  const { visitId } = route.params as RouteParams;
  const [visit, setVisit] = useState<Visit | null>(null);
  const [actions, setActions] = useState<TimelineAction[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [menuVisible, setMenuVisible] = useState(false);
  const [actionModalVisible, setActionModalVisible] = useState(false);
  const [editingAction, setEditingAction] = useState<TimelineAction | undefined>();
  const [actionDetailModalVisible, setActionDetailModalVisible] = useState(false);
  const [selectedAction, setSelectedAction] = useState<TimelineAction | undefined>();
  const [isEditMode, setIsEditMode] = useState(false);
  const [sortedActions, setSortedActions] = useState<TimelineAction[]>([]);

  useEffect(() => {
    loadVisitData();
  }, [visitId]);

  useEffect(() => {
    // Use actions as-is (in order they were added/arranged)
    setSortedActions([...actions]);
  }, [actions]);

  const loadVisitData = async () => {
    try {
      setIsLoading(true);
      const [visitData, actionsData] = await Promise.all([
        getVisit(visitId),
        getActionsByVisit(visitId)
      ]);
      
      setVisit(visitData);
      setActions(actionsData || []);
    } catch (error) {
      Alert.alert(
        language === 'ja' ? 'エラー' : 'Error', 
        language === 'ja' ? '来園記録の読み込みに失敗しました' : 'Failed to load visit record'
      );
      navigation.goBack();
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteVisit = () => {
    Alert.alert(
      language === 'ja' ? '来園記録を削除' : 'Delete Visit Record',
      language === 'ja' ? 'この来園記録を削除しますか？この操作は取り消せません。' : 'Are you sure you want to delete this visit record? This action cannot be undone.',
      [
        { text: language === 'ja' ? 'キャンセル' : 'Cancel', style: 'cancel' },
        {
          text: language === 'ja' ? '削除' : 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteVisit(visitId);
              navigation.goBack();
            } catch (error) {
              Alert.alert(
                language === 'ja' ? 'エラー' : 'Error', 
                language === 'ja' ? '来園記録の削除に失敗しました' : 'Failed to delete visit record'
              );
            }
          }
        }
      ]
    );
  };

  const handleShareVisit = async () => {
    if (!visit) return;

    const shareText = `${formatDate(visit.date)}の${getParkName(visit.parkType)}来園記録\n\n` +
      `アクション数: ${actions.length}件\n` +
      `写真数: ${getTotalPhotoCount()}枚\n` +
      (visit.notes ? `\nメモ: ${visit.notes}` : '') +
      '\n\n#TDRDays #ディズニー';

    try {
      await Share.share({
        message: shareText,
      });
    } catch (error) {
      console.error('Share failed:', error);
    }
  };

  const formatDate = (date: Date): string => {
    const locale = language === 'ja' ? 'ja-JP' : 'en-US';
    return new Date(date).toLocaleDateString(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      weekday: 'long'
    });
  };

  const getParkName = (parkType: ParkType): string => {
    if (language === 'ja') {
      return parkType === ParkType.LAND ? 'ディズニーランド' : 'ディズニーシー';
    } else {
      return parkType === ParkType.LAND ? 'Tokyo Disneyland' : 'Tokyo DisneySea';
    }
  };

  const getParkIcon = (parkType: ParkType): string => {
    return parkType === ParkType.LAND ? 'castle' : 'boat';
  };

  const getParkColor = (parkType: ParkType): string => {
    return parkType === ParkType.LAND ? colors.orange[500] : colors.blue[500];
  };

  const getCategoryIcon = (category: ActionCategory): string => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return 'rocket';
      case ActionCategory.RESTAURANT:
        return 'restaurant';
      case ActionCategory.SHOW:
        return 'musical-notes';
      case ActionCategory.GREETING:
        return 'hand-left';
      case ActionCategory.SHOPPING:
        return 'bag';
      case ActionCategory.CUSTOM:
        return 'create';
      default:
        return 'ellipse';
    }
  };

  const getCategoryColor = (category: ActionCategory): string => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return colors.purple[500];
      case ActionCategory.RESTAURANT:
        return colors.orange[500];
      case ActionCategory.SHOW:
        return colors.pink[500];
      case ActionCategory.GREETING:
        return colors.yellow[500];
      case ActionCategory.SHOPPING:
        return colors.green[500];
      case ActionCategory.CUSTOM:
        return colors.blue[500];
      default:
        return colors.gray[500];
    }
  };

  const translateAreaName = (area: string): string => {
    if (language === 'ja') return area;
    
    const areaTranslations: { [key: string]: string } = {
      // Disneyland areas
      'ワールドバザール': 'World Bazaar',
      'アドベンチャーランド': 'Adventureland', 
      'ウエスタンランド': 'Westernland',
      'クリッターカントリー': 'Critter Country',
      'ファンタジーランド': 'Fantasyland',
      'トゥーンタウン': 'Toontown',
      'トゥモローランド': 'Tomorrowland',
      // DisneySea areas
      'メディテレーニアンハーバー': 'Mediterranean Harbor',
      'アメリカンウォーターフロント': 'American Waterfront',
      'ポートディスカバリー': 'Port Discovery',
      'ロストリバーデルタ': 'Lost River Delta',
      'アラビアンコースト': 'Arabian Coast',
      'マーメイドラグーン': 'Mermaid Lagoon',
      'ミステリアスアイランド': 'Mysterious Island',
      'ファンタジースプリングス': 'Fantasy Springs',
    };
    
    return areaTranslations[area] || area;
  };

  const translateFacilityName = (name: string): string => {
    if (language === 'ja') return name;
    
    const facilityTranslations: { [key: string]: string } = {
      // Popular attractions - Disneyland
      'ビッグサンダーマウンテン': 'Big Thunder Mountain',
      'スプラッシュマウンテン': 'Splash Mountain',
      'スペースマウンテン': 'Space Mountain',
      'プーさんのハニーハント': 'Pooh\'s Hunny Hunt',
      'ホーンテッドマンション': 'Haunted Mansion',
      'イッツ・ア・スモールワールド': 'It\'s a Small World',
      'ジャングルクルーズ': 'Jungle Cruise',
      'カリブの海賊': 'Pirates of the Caribbean',
      'ビッグサンダーマウンテン': 'Big Thunder Mountain Railroad',
      // Popular attractions - DisneySea
      'タワー・オブ・テラー': 'Tower of Terror',
      'センター・オブ・ジ・アース': 'Journey to the Center of the Earth',
      'トイ・ストーリー・マニア!': 'Toy Story Midway Mania!',
      'インディ・ジョーンズ・アドベンチャー': 'Indiana Jones Adventure',
      'レイジングスピリッツ': 'Raging Spirits',
      'フランダーのフライングフィッシュコースター': 'Flounder\'s Flying Fish Coaster',
      '20000リーグ・アンダー・ザ・シー': '20,000 Leagues Under the Sea',
      // Popular restaurants
      'クイーン・オブ・ハートのバンケットホール': 'Queen of Hearts Banquet Hall',
      'クリスタルパレス・レストラン': 'Crystal Palace Restaurant',
      'ブルーバイユー・レストラン': 'Blue Bayou Restaurant',
      'マゼランズ': 'Magellan\'s',
      'リストランテ・ディ・カナレット': 'Ristorante di Canaletto',
      'ケープコッド・クックオフ': 'Cape Cod Cook-Off',
      // Shows
      'ビッグバンドビート': 'Big Band Beat',
      'ミッキーとダッフィーのスプリングヴォヤッジ': 'Mickey and Duffy\'s Spring Voyage',
      'フェアリーテイル・フォレスト': 'Fairytale Forest',
      'エレクトリカルパレード・ドリームライツ': 'Tokyo Disneyland Electrical Parade Dreamlights',
    };
    
    return facilityTranslations[name] || name;
  };

  const getCategoryName = (category: ActionCategory): string => {
    switch (category) {
      case ActionCategory.ATTRACTION:
        return language === 'ja' ? 'アトラクション' : 'Attraction';
      case ActionCategory.RESTAURANT:
        return language === 'ja' ? 'レストラン' : 'Restaurant';
      case ActionCategory.SHOW:
        return language === 'ja' ? 'ショー' : 'Show';
      case ActionCategory.GREETING:
        return language === 'ja' ? 'グリーティング' : 'Greeting';
      case ActionCategory.SHOPPING:
        return language === 'ja' ? 'ショッピング' : 'Shopping';
      case ActionCategory.CUSTOM:
        return language === 'ja' ? 'カスタム' : 'Custom';
      default:
        return language === 'ja' ? 'その他' : 'Other';
    }
  };

  const getTotalPhotoCount = (): number => {
    return actions.reduce((total, action) => total + action.photos.length, 0);
  };

  const handleAddAction = () => {
    setEditingAction(undefined);
    setActionModalVisible(true);
  };

  const handleActionPress = (action: TimelineAction) => {
    setSelectedAction(action);
    setActionDetailModalVisible(true);
  };

  const handleEditAction = (action: TimelineAction) => {
    setEditingAction(action);
    setActionModalVisible(true);
    setActionDetailModalVisible(false);
  };

  const handleActionSave = (savedAction: TimelineAction) => {
    if (editingAction) {
      // Update existing action
      setActions(prev => prev.map(a => a.id === savedAction.id ? savedAction : a));
    } else {
      // Add new action
      setActions(prev => [...prev, savedAction]);
    }
    setActionModalVisible(false);
    setEditingAction(undefined);
  };

  const handleActionModalClose = () => {
    setActionModalVisible(false);
    setEditingAction(undefined);
  };


  const toggleEditMode = () => {
    setIsEditMode(!isEditMode);
  };


  const moveAction = (fromIndex: number, toIndex: number) => {
    const newActions = [...sortedActions];
    const [movedAction] = newActions.splice(fromIndex, 1);
    newActions.splice(toIndex, 0, movedAction);
    setSortedActions(newActions);
    setActions(newActions);
  };

  const renderTimelineItem = (action: TimelineAction, index: number) => {
    const isFirst = index === 0;
    const isLast = index === sortedActions.length - 1;
    const categoryColor = getCategoryColor(action.category);
    
    return (
      <View key={action.id} style={styles.timelineItem}>
        {/* Step Number */}
        <View style={styles.stepIndicator}>
          <View style={[styles.stepNumber, { backgroundColor: categoryColor }]}>
            <Text style={styles.stepNumberText}>{index + 1}</Text>
          </View>
          
          {/* Arrow pointing down to next item */}
          {!isLast && (
            <View style={styles.stepConnector}>
              <View style={[styles.stepLine, { backgroundColor: theme.colors.border }]} />
              <Ionicons 
                name="chevron-down" 
                size={16} 
                color={theme.colors.border} 
                style={styles.stepArrow}
              />
            </View>
          )}
        </View>

        {/* Move Buttons (only in edit mode) */}
        {isEditMode && (
          <View style={styles.moveButtons}>
            {!isFirst && (
              <TouchableOpacity
                style={[styles.moveButton, { backgroundColor: theme.colors.background.secondary }]}
                onPress={() => moveAction(index, index - 1)}
              >
                <Ionicons name="chevron-up" size={16} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            )}
            {!isLast && (
              <TouchableOpacity
                style={[styles.moveButton, { backgroundColor: theme.colors.background.secondary }]}
                onPress={() => moveAction(index, index + 1)}
              >
                <Ionicons name="chevron-down" size={16} color={theme.colors.text.secondary} />
              </TouchableOpacity>
            )}
          </View>
        )}

        {/* Action Card */}
        <TouchableOpacity
          style={[
            styles.actionCard, 
            { backgroundColor: theme.colors.background.card },
          ]}
          onPress={() => handleActionPress(action)}
          activeOpacity={0.7}
          disabled={isEditMode}
        >
          <View style={styles.actionCardHeader}>
            <View style={styles.actionCardTitle}>
              <Ionicons 
                name={getCategoryIcon(action.category) as any} 
                size={16} 
                color={categoryColor} 
              />
              <Text style={[styles.actionCategory, { color: categoryColor }]}>
                {getCategoryName(action.category)}
              </Text>
            </View>
            {action.time && (
              <Text style={[styles.actionTime, { color: theme.colors.text.secondary }]}>
                {new Date(action.time).toLocaleTimeString(language === 'ja' ? 'ja-JP' : 'en-US', { 
                  hour: '2-digit', 
                  minute: '2-digit' 
                })}
              </Text>
            )}
          </View>

          <Text style={[styles.actionName, { color: theme.colors.text.primary }]}>
            {action.customTitle || (action.locationName ? translateFacilityName(action.locationName) : getCategoryName(action.category))}
          </Text>
          
          <Text style={[styles.actionArea, { color: theme.colors.text.secondary }]}>
            {translateAreaName(action.area)}
          </Text>

          {/* Action Details */}
          <View style={styles.actionCardDetails}>

            {action.waitTime && (
              <View style={styles.actionDetail}>
                <Ionicons name="hourglass" size={12} color={theme.colors.text.secondary} />
                <Text style={[styles.actionDetailText, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' 
                    ? `待ち${action.waitTime}分` 
                    : `${action.waitTime}min wait`
                  }
                </Text>
              </View>
            )}

            {action.photos.length > 0 && (
              <View style={styles.actionDetail}>
                <Ionicons name="image" size={12} color={theme.colors.text.secondary} />
                <Text style={[styles.actionDetailText, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' 
                    ? `${action.photos.length}枚` 
                    : `${action.photos.length} photos`
                  }
                </Text>
              </View>
            )}
          </View>

          {/* Photo Preview */}
          {action.photos.length > 0 && (
            <View style={styles.photoPreview}>
              {action.photos.slice(0, 3).map((photo, photoIndex) => (
                <View 
                  key={photo.id} 
                  style={[
                    styles.photoPreviewItem, 
                    { zIndex: 3 - photoIndex, marginLeft: photoIndex > 0 ? -spacing[2] : 0 }
                  ]}
                >
                  <Image 
                    source={{ uri: photo.uri }} 
                    style={styles.photoPreviewImage} 
                  />
                </View>
              ))}
              {action.photos.length > 3 && (
                <View style={[styles.photoPreviewMore, { backgroundColor: theme.colors.background.secondary }]}>
                  <Text style={[styles.photoPreviewMoreText, { color: theme.colors.text.secondary }]}>
                    +{action.photos.length - 3}
                  </Text>
                </View>
              )}
            </View>
          )}

          {action.notes && (
            <Text 
              style={[styles.actionNotes, { color: theme.colors.text.secondary }]}
              numberOfLines={2}
            >
              {action.notes}
            </Text>
          )}
        </TouchableOpacity>
      </View>
    );
  };

  const getVisitDuration = (): string | null => {
    if (!visit?.startTime || !visit?.endTime) return null;
    
    const start = new Date(visit.startTime);
    const end = new Date(visit.endTime);
    const diffMs = end.getTime() - start.getTime();
    const hours = Math.floor(diffMs / (1000 * 60 * 60));
    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (language === 'ja') {
      return `${hours}時間${minutes}分`;
    } else {
      return `${hours}h ${minutes}m`;
    }
  };

  const getCompanionNames = (): string => {
    if (!visit?.companionIds.length) {
      return language === 'ja' ? '一人' : 'Solo';
    }
    
    const visitCompanions = companions.filter(c => 
      visit.companionIds.includes(c.id)
    );
    
    return visitCompanions.map(c => c.name).join(', ');
  };

  if (isLoading) {
    return (
      <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
        <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
          <Header 
            title={language === 'ja' ? '来園記録詳細' : 'Visit Details'} 
            showBackButton 
            onBackPress={() => navigation.goBack()}
            onMenuOpen={() => setMenuVisible(true)}
          />
          <View style={styles.loadingContainer}>
            <Text style={[styles.loadingText, { color: theme.colors.text.secondary }]}>
              {language === 'ja' ? '読み込み中...' : 'Loading...'}
            </Text>
          </View>
        </View>
        
        <DrawerMenu
          visible={menuVisible}
          onClose={() => setMenuVisible(false)}
        />
      </SwipeableScreen>
    );
  }

  if (!visit) {
    return (
      <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
        <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
          <Header 
            title={language === 'ja' ? '来園記録詳細' : 'Visit Details'} 
            showBackButton 
            onBackPress={() => navigation.goBack()}
            onMenuOpen={() => setMenuVisible(true)}
          />
          <View style={styles.errorContainer}>
            <Text style={[styles.errorText, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? '来園記録が見つかりません' : 'Visit record not found'}
            </Text>
          </View>
        </View>
        
        <DrawerMenu
          visible={menuVisible}
          onClose={() => setMenuVisible(false)}
        />
      </SwipeableScreen>
    );
  }

  return (
    <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
      <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
        <Header 
          title={language === 'ja' ? '来園記録詳細' : 'Visit Details'} 
          showBackButton 
          onBackPress={() => navigation.goBack()}
          onMenuOpen={() => setMenuVisible(true)}
          rightActions={[
            {
              icon: 'share-outline',
              onPress: handleShareVisit,
            },
            {
              icon: 'trash-outline',
              onPress: handleDeleteVisit,
            },
          ]}
        />
      
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Park Header */}
        <LinearGradient
          colors={[
            getParkColor(visit.parkType) + '20',
            getParkColor(visit.parkType) + '10',
          ]}
          style={styles.parkHeader}
        >
          <View style={styles.parkInfo}>
            <View style={[
              styles.parkIcon,
              { backgroundColor: getParkColor(visit.parkType) + '30' }
            ]}>
              {visit.parkType === ParkType.LAND ? (
                <FontAwesome5 
                  name="fort-awesome" 
                  size={32} 
                  color={getParkColor(visit.parkType)} 
                />
              ) : (
                <FontAwesome5 
                  name="globe" 
                  size={32} 
                  color={getParkColor(visit.parkType)} 
                />
              )}
            </View>
            <View style={styles.parkDetails}>
              <Text style={[styles.parkName, { color: theme.colors.text.primary }]}>
                {getParkName(visit.parkType)}
              </Text>
              <Text style={[styles.visitDate, { color: theme.colors.text.secondary }]}>
                {formatDate(visit.date)}
              </Text>
            </View>
          </View>
        </LinearGradient>

        {/* Visit Information */}
        <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
          <View style={styles.sectionHeader}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? '来園情報' : 'Visit Information'}
            </Text>
            <TouchableOpacity
              style={[styles.editRecordButton, { backgroundColor: colors.purple[500] }]}
              onPress={() => {
                // Navigate back to the main tab navigator first, then to Record screen
                navigation.navigate('Main' as never, {
                  screen: 'Record',
                  params: {
                    visitId: visitId,
                    parkType: visit.parkType,
                    date: new Date(visit.date).toISOString().split('T')[0]
                  }
                } as never);
              }}
            >
              <Ionicons name="pencil" size={14} color="white" />
              <Text style={styles.editRecordButtonText}>
                {language === 'ja' ? '編集' : 'Edit'}
              </Text>
            </TouchableOpacity>
          </View>
          
          <View style={styles.infoGrid}>
            <View style={styles.infoItem}>
              <Ionicons name="people" size={20} color={theme.colors.text.secondary} />
              <Text style={[styles.infoLabel, { color: theme.colors.text.secondary }]}>
                {language === 'ja' ? '同行者' : 'Companions'}
              </Text>
              <Text style={[styles.infoValue, { color: theme.colors.text.primary }]}>
                {getCompanionNames()}
              </Text>
            </View>

            {visit.startTime && visit.endTime && (
              <View style={styles.infoItem}>
                <Ionicons name="time" size={20} color={theme.colors.text.secondary} />
                <Text style={[styles.infoLabel, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '滞在時間' : 'Duration'}
                </Text>
                <Text style={[styles.infoValue, { color: theme.colors.text.primary }]}>
                  {getVisitDuration()}
                </Text>
              </View>
            )}

            {visit.weather && (
              <View style={styles.infoItem}>
                <Ionicons name="partly-sunny" size={20} color={theme.colors.text.secondary} />
                <Text style={[styles.infoLabel, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '天気' : 'Weather'}
                </Text>
                <Text style={[styles.infoValue, { color: theme.colors.text.primary }]}>
                  {visit.weather}
                </Text>
              </View>
            )}
          </View>

          {visit.notes && (
            <View style={styles.notesContainer}>
              <Text style={[styles.notesLabel, { color: theme.colors.text.secondary }]}>
                {language === 'ja' ? 'メモ' : 'Notes'}
              </Text>
              <Text style={[styles.notesText, { color: theme.colors.text.primary }]}>
                {visit.notes}
              </Text>
            </View>
          )}
        </View>

        {/* Statistics */}
        <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
            {language === 'ja' ? '統計情報' : 'Statistics'}
          </Text>
          
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <LinearGradient
                colors={['rgba(168, 85, 247, 0.1)', 'rgba(147, 51, 234, 0.1)']}
                style={styles.statCardGradient}
              >
                <Ionicons name="list" size={24} color={colors.purple[500]} />
                <Text style={[styles.statValue, { color: theme.colors.text.primary }]}>
                  {actions.length}
                </Text>
                <Text style={[styles.statLabel, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? 'アクション' : 'Actions'}
                </Text>
              </LinearGradient>
            </View>

            <View style={styles.statCard}>
              <LinearGradient
                colors={['rgba(34, 197, 94, 0.1)', 'rgba(22, 163, 74, 0.1)']}
                style={styles.statCardGradient}
              >
                <Ionicons name="image" size={24} color={colors.green[500]} />
                <Text style={[styles.statValue, { color: theme.colors.text.primary }]}>
                  {getTotalPhotoCount()}
                </Text>
                <Text style={[styles.statLabel, { color: theme.colors.text.secondary }]}>
                  {language === 'ja' ? '写真' : 'Photos'}
                </Text>
              </LinearGradient>
            </View>
          </View>
        </View>

        {/* Photo Gallery */}
        {getTotalPhotoCount() > 0 && (
          <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
            <View style={styles.sectionHeader}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
                {language === 'ja' 
                  ? `今日の写真 (${getTotalPhotoCount()}枚)` 
                  : `Photos (${getTotalPhotoCount()})` 
                }
              </Text>
            </View>
            
            <ScrollView 
              horizontal 
              showsHorizontalScrollIndicator={false}
              style={styles.photoGalleryContainer}
              contentContainerStyle={styles.photoGalleryContent}
            >
              {sortedActions
                .filter(action => action.photos.length > 0)
                .map(action => 
                  action.photos.map((photo, photoIndex) => (
                    <TouchableOpacity
                      key={`${action.id}-${photo.id}`}
                      style={styles.photoGalleryItem}
                      onPress={() => {
                        setSelectedAction(action);
                        setActionDetailModalVisible(true);
                      }}
                    >
                      <Image 
                        source={{ uri: photo.uri }} 
                        style={styles.photoGalleryImage} 
                      />
                      <View style={styles.photoGalleryOverlay}>
                        <View style={[styles.photoGalleryCategory, { backgroundColor: getCategoryColor(action.category) }]}>
                          <Ionicons 
                            name={getCategoryIcon(action.category) as any} 
                            size={12} 
                            color="white" 
                          />
                        </View>
                        <Text style={styles.photoGalleryTime}>
                          {new Date(action.time).toLocaleTimeString(language === 'ja' ? 'ja-JP' : 'en-US', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                          })}
                        </Text>
                      </View>
                    </TouchableOpacity>
                  ))
                )}
            </ScrollView>
          </View>
        )}

        {/* Actions */}
        <View style={[styles.section, { backgroundColor: theme.colors.background.card }]}>
          <View style={styles.sectionHeader}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
              {language === 'ja' ? 'アクション履歴' : 'Action History'}
            </Text>
            <View style={styles.actionButtons}>
              {actions.length > 1 && (
                <TouchableOpacity
                  style={[
                    styles.editButton, 
                    { 
                      backgroundColor: isEditMode ? colors.orange[500] : theme.colors.background.secondary,
                      borderColor: isEditMode ? colors.orange[500] : theme.colors.border,
                    }
                  ]}
                  onPress={toggleEditMode}
                >
                  <Ionicons 
                    name={isEditMode ? "checkmark" : "reorder-three"} 
                    size={14} 
                    color={isEditMode ? "white" : theme.colors.text.secondary} 
                  />
                  <Text style={[
                    styles.editButtonText, 
                    { color: isEditMode ? "white" : theme.colors.text.secondary }
                  ]}>
                    {isEditMode 
                      ? (language === 'ja' ? '完了' : 'Done') 
                      : (language === 'ja' ? '並替' : 'Sort')
                    }
                  </Text>
                </TouchableOpacity>
              )}
              <TouchableOpacity
                style={[styles.addButton, { backgroundColor: colors.blue[500] }]}
                onPress={handleAddAction}
              >
                <Ionicons name="add" size={16} color="white" />
                <Text style={styles.addButtonText}>
                  {language === 'ja' ? '追加' : 'Add'}
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          {isEditMode && (
            <View style={[styles.editModeNotice, { backgroundColor: colors.orange[500] + '20' }]}>
              <Ionicons name="information-circle" size={16} color={colors.orange[500]} />
              <Text style={[styles.editModeNoticeText, { color: colors.orange[500] }]}>
                {language === 'ja' 
                  ? '右側の矢印ボタンで並び替えできます' 
                  : 'Use arrow buttons on the right to reorder'
                }
              </Text>
            </View>
          )}
          
          {sortedActions.length > 0 ? (
            <View style={styles.timeline}>
              {sortedActions.map((action, index) => renderTimelineItem(action, index))}
            </View>
          ) : (
            <View style={styles.emptyState}>
              <Ionicons name="calendar-outline" size={48} color={theme.colors.text.secondary} />
              <Text style={[styles.emptyStateText, { color: theme.colors.text.secondary }]}>
                {language === 'ja' 
                  ? 'まだアクションが記録されていません' 
                  : 'No actions recorded yet'
                }
              </Text>
              <Text style={[styles.emptyStateSubtext, { color: theme.colors.text.secondary }]}>
                {language === 'ja' 
                  ? '上の「追加」ボタンから最初のアクションを追加しましょう' 
                  : 'Add your first action using the "Add" button above'
                }
              </Text>
            </View>
          )}
        </View>
      </ScrollView>
      </View>
      
      <DrawerMenu
        visible={menuVisible}
        onClose={() => setMenuVisible(false)}
      />
      
      {visit && (
        <ActionModal
          visible={actionModalVisible}
          onClose={handleActionModalClose}
          visitId={visitId}
          parkType={visit.parkType}
          action={editingAction}
          onSave={handleActionSave}
        />
      )}

      <ActionDetailModal
        visible={actionDetailModalVisible}
        onClose={() => setActionDetailModalVisible(false)}
        action={selectedAction || null}
        onEdit={handleEditAction}
      />
    </SwipeableScreen>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    fontSize: 16,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    fontSize: 16,
  },
  content: {
    flex: 1,
  },
  parkHeader: {
    paddingHorizontal: spacing[4],
    paddingVertical: spacing[6],
  },
  parkInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  parkIcon: {
    width: 64,
    height: 64,
    borderRadius: borderRadius.xl,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: spacing[4],
  },
  parkDetails: {
    flex: 1,
  },
  parkName: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: spacing[1],
  },
  visitDate: {
    fontSize: 16,
  },
  section: {
    margin: spacing[4],
    borderRadius: borderRadius.xl,
    padding: spacing[4],
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: spacing[4],
  },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: spacing[4],
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.md,
  },
  addButtonText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
    marginLeft: spacing[1],
  },
  actionButtons: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[2],
  },
  editButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[2],
    paddingVertical: spacing[1],
    borderRadius: borderRadius.sm,
    borderWidth: 1,
  },
  editButtonText: {
    fontSize: 12,
    fontWeight: '600',
    marginLeft: spacing[1],
  },
  editRecordButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[2],
    paddingVertical: spacing[1],
    borderRadius: borderRadius.sm,
  },
  editRecordButtonText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
    marginLeft: spacing[1],
  },
  editModeNotice: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing[3],
    paddingVertical: spacing[2],
    borderRadius: borderRadius.md,
    marginBottom: spacing[3],
  },
  editModeNoticeText: {
    fontSize: 12,
    fontWeight: '500',
    marginLeft: spacing[2],
  },
  infoGrid: {
    gap: spacing[4],
  },
  infoItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  infoLabel: {
    fontSize: 14,
    marginLeft: spacing[3],
    minWidth: 80,
  },
  infoValue: {
    fontSize: 14,
    fontWeight: '500',
    flex: 1,
    marginLeft: spacing[2],
  },
  notesContainer: {
    marginTop: spacing[4],
    paddingTop: spacing[4],
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 0, 0, 0.1)',
  },
  notesLabel: {
    fontSize: 14,
    marginBottom: spacing[2],
  },
  notesText: {
    fontSize: 14,
    lineHeight: 20,
  },
  statsGrid: {
    flexDirection: 'row',
    gap: spacing[3],
  },
  statCard: {
    flex: 1,
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
  },
  statCardGradient: {
    padding: spacing[4],
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: '700',
    marginTop: spacing[2],
  },
  statLabel: {
    fontSize: 12,
    marginTop: spacing[1],
  },
  timeline: {
    paddingLeft: spacing[2],
    paddingRight: spacing[2],
  },
  timelineItem: {
    flexDirection: 'column',
    marginBottom: spacing[4],
    position: 'relative',
  },
  stepIndicator: {
    position: 'absolute',
    left: 0,
    top: 0,
    alignItems: 'center',
    zIndex: 1,
  },
  stepNumber: {
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
  },
  stepNumberText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '700',
  },
  stepConnector: {
    alignItems: 'center',
    marginTop: spacing[2],
  },
  stepLine: {
    width: 2,
    height: spacing[6],
  },
  stepArrow: {
    marginTop: -4,
  },
  moveButtons: {
    position: 'absolute',
    right: 0,
    top: spacing[2],
    flexDirection: 'column',
    gap: spacing[1],
    zIndex: 2,
  },
  moveButton: {
    padding: spacing[1],
    borderRadius: borderRadius.sm,
    width: 32,
    height: 32,
    justifyContent: 'center',
    alignItems: 'center',
  },
  actionCard: {
    marginLeft: 40, // Space for step indicator
    marginRight: 8, // Reduced space for wider cards
    borderRadius: borderRadius.lg,
    padding: spacing[4],
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  actionCardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing[2],
  },
  actionCardTitle: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[2],
  },
  actionTime: {
    fontSize: 12,
    fontWeight: '600',
  },
  actionCategory: {
    fontSize: 12,
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  actionName: {
    fontSize: 18,
    fontWeight: '700',
    marginBottom: spacing[1],
  },
  actionArea: {
    fontSize: 14,
    marginBottom: spacing[3],
  },
  actionCardDetails: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing[2],
    marginBottom: spacing[3],
  },
  actionDetail: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing[1],
  },
  actionDetailText: {
    fontSize: 12,
  },
  photoPreview: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: spacing[2],
  },
  photoPreviewItem: {
    width: 40,
    height: 40,
    borderRadius: borderRadius.md,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: 'white',
  },
  photoPreviewImage: {
    width: '100%',
    height: '100%',
  },
  photoPreviewMore: {
    width: 40,
    height: 40,
    borderRadius: borderRadius.md,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: -spacing[2],
    borderWidth: 2,
    borderColor: 'white',
  },
  photoPreviewMoreText: {
    fontSize: 10,
    fontWeight: '600',
  },
  actionNotes: {
    fontSize: 13,
    lineHeight: 18,
    fontStyle: 'italic',
  },
  photoGalleryContainer: {
    marginTop: spacing[2],
  },
  photoGalleryContent: {
    paddingRight: spacing[2],
  },
  photoGalleryItem: {
    marginRight: spacing[2],
    position: 'relative',
  },
  photoGalleryImage: {
    width: 120,
    height: 120,
    borderRadius: borderRadius.lg,
  },
  photoGalleryOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    borderBottomLeftRadius: borderRadius.lg,
    borderBottomRightRadius: borderRadius.lg,
    padding: spacing[2],
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  photoGalleryCategory: {
    width: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
  },
  photoGalleryTime: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  emptyState: {
    alignItems: 'center',
    paddingVertical: spacing[8],
  },
  emptyStateText: {
    fontSize: 16,
    fontWeight: '500',
    marginTop: spacing[3],
    textAlign: 'center',
  },
  emptyStateSubtext: {
    fontSize: 14,
    marginTop: spacing[2],
    textAlign: 'center',
    lineHeight: 20,
  },
});
</file>

<file path="src/screens/VisitListScreen.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  RefreshControl,
  SectionList,
  Platform,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Ionicons, FontAwesome5 } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation } from '@react-navigation/native';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { useVisits } from '../hooks/useVisits';
import { Visit, ParkType } from '../types/models';
import { colors } from '../styles/colors';
import { spacing, borderRadius } from '../styles/theme';
import { Header } from '../components/Header';
import { SwipeableScreen } from '../components/SwipeableScreen';
import { DrawerMenu } from '../components/DrawerMenu';

interface VisitSection {
  title: string;
  data: Visit[];
}

export const VisitListScreen = () => {
  const navigation = useNavigation();
  const { theme } = useTheme();
  const { language } = useLanguage();
  const { visits, isLoading, refreshData } = useVisits();
  const [refreshing, setRefreshing] = useState(false);
  const [menuVisible, setMenuVisible] = useState(false);
  const insets = useSafeAreaInsets();

  const handleRefresh = async () => {
    setRefreshing(true);
    await refreshData();
    setRefreshing(false);
  };

  // 日本時間での今日の日付を取得
  const getTodayInJST = () => {
    const now = new Date();
    const jstOffset = 9 * 60; // JST is UTC+9
    const jstTime = new Date(now.getTime() + (jstOffset * 60 * 1000));
    return jstTime.toISOString().split('T')[0]; // YYYY-MM-DD format
  };

  // 日本時間での日付文字列を取得
  const getDateStringInJST = (date: Date): string => {
    const visitDate = new Date(date);
    const jstOffset = 9 * 60; // JST is UTC+9
    const jstTime = new Date(visitDate.getTime() + (jstOffset * 60 * 1000));
    return jstTime.toISOString().split('T')[0]; // YYYY-MM-DD format
  };

  const getRelativeTimeLabel = (date: Date): string => {
    const todayJST = getTodayInJST();
    const visitDateJST = getDateStringInJST(date);
    
    // 日付文字列での比較
    const today = new Date(todayJST);
    const visitDate = new Date(visitDateJST);
    const diffInDays = Math.floor((today.getTime() - visitDate.getTime()) / (1000 * 60 * 60 * 24));


    if (diffInDays === 0) return language === 'ja' ? '今日' : 'Today';
    if (diffInDays === 1) return language === 'ja' ? '昨日' : 'Yesterday';
    if (diffInDays <= 7) return language === 'ja' ? '1週間以内' : 'Within a week';
    if (diffInDays <= 30) return language === 'ja' ? '1ヶ月以内' : 'Within a month';
    if (diffInDays <= 90) return language === 'ja' ? '3ヶ月以内' : 'Within 3 months';
    if (diffInDays <= 180) return language === 'ja' ? '6ヶ月以内' : 'Within 6 months';
    if (diffInDays <= 365) return language === 'ja' ? '1年以内' : 'Within a year';
    return language === 'ja' ? '1年以上前' : 'Over a year ago';
  };

  const getSectionOrder = (title: string): number => {
    const orderJa: { [key: string]: number } = {
      '今日': 1, '昨日': 2, '1週間以内': 3, '1ヶ月以内': 4,
      '3ヶ月以内': 5, '6ヶ月以内': 6, '1年以内': 7, '1年以上前': 8,
    };
    const orderEn: { [key: string]: number } = {
      'Today': 1, 'Yesterday': 2, 'Within a week': 3, 'Within a month': 4,
      'Within 3 months': 5, 'Within 6 months': 6, 'Within a year': 7, 'Over a year ago': 8,
    };
    return (language === 'ja' ? orderJa[title] : orderEn[title]) || 999;
  };

  const visitSections: VisitSection[] = useMemo(() => {
    const sortedVisits = [...visits].sort((a, b) => 
      new Date(b.date).getTime() - new Date(a.date).getTime()
    );

    const sectionsMap = new Map<string, Visit[]>();

    sortedVisits.forEach(visit => {
      const label = getRelativeTimeLabel(visit.date);
      if (!sectionsMap.has(label)) {
        sectionsMap.set(label, []);
      }
      sectionsMap.get(label)!.push(visit);
    });

    return Array.from(sectionsMap.entries())
      .map(([title, data]) => ({ title, data }))
      .sort((a, b) => getSectionOrder(a.title) - getSectionOrder(b.title));
  }, [visits]);

  const formatDate = (date: Date): string => {
    const locale = language === 'ja' ? 'ja-JP' : 'en-US';
    return new Date(date).toLocaleDateString(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      weekday: 'short'
    });
  };

  const getParkName = (parkType: ParkType): string => {
    if (language === 'ja') {
      return parkType === ParkType.LAND ? 'ディズニーランド' : 'ディズニーシー';
    } else {
      return parkType === ParkType.LAND ? 'Disneyland' : 'DisneySea';
    }
  };

  const getParkIcon = (parkType: ParkType): string => {
    return parkType === ParkType.LAND ? 'castle' : 'boat';
  };

  const getParkColor = (parkType: ParkType): string => {
    return parkType === ParkType.LAND ? colors.orange[500] : colors.blue[500];
  };

  const renderVisitItem = ({ item }: { item: Visit }) => (
    <TouchableOpacity
      style={[
        styles.visitCard,
        { backgroundColor: theme.colors.background.card }
      ]}
      onPress={() => (navigation as any).navigate('VisitDetail', { visitId: item.id })}
    >
      <LinearGradient
        colors={[
          'rgba(168, 85, 247, 0.05)',
          'rgba(147, 51, 234, 0.05)'
        ]}
        style={styles.visitCardGradient}
      >
        <View style={styles.visitHeader}>
          <View style={styles.visitInfo}>
            <View style={styles.parkInfo}>
              <View style={[
                styles.parkIcon,
                { backgroundColor: getParkColor(item.parkType) + '20' }
              ]}>
                {item.parkType === ParkType.LAND ? (
                  <FontAwesome5 
                    name="fort-awesome" 
                    size={20} 
                    color={getParkColor(item.parkType)} 
                  />
                ) : (
                  <FontAwesome5 
                    name="globe" 
                    size={20} 
                    color={getParkColor(item.parkType)} 
                  />
                )}
              </View>
              <Text style={[styles.parkName, { color: theme.colors.text.primary }]}>
                {getParkName(item.parkType)}
              </Text>
            </View>
            <Text style={[styles.visitDate, { color: theme.colors.text.secondary }]}>
              {formatDate(item.date)}
            </Text>
          </View>
          <Ionicons 
            name="chevron-forward" 
            size={20} 
            color={theme.colors.text.secondary} 
          />
        </View>


        <View style={styles.visitStats}>
          {item.actionCount !== undefined && (
            <View style={styles.statItem}>
              <Ionicons name="list" size={14} color={theme.colors.text.secondary} />
              <Text style={[styles.statText, { color: theme.colors.text.secondary }]}>
                {language === 'ja' ? `${item.actionCount}件のアクション` : `${item.actionCount} actions`}
              </Text>
            </View>
          )}
          {item.totalPhotoCount !== undefined && (
            <View style={styles.statItem}>
              <Ionicons name="image" size={14} color={theme.colors.text.secondary} />
              <Text style={[styles.statText, { color: theme.colors.text.secondary }]}>
                {language === 'ja' ? `${item.totalPhotoCount}枚の写真` : `${item.totalPhotoCount} photos`}
              </Text>
            </View>
          )}
          {item.startTime && item.endTime && (
            <View style={styles.statItem}>
              <Ionicons name="time" size={14} color={theme.colors.text.secondary} />
              <Text style={[styles.statText, { color: theme.colors.text.secondary }]}>
                {new Date(item.startTime).toLocaleTimeString(language === 'ja' ? 'ja-JP' : 'en-US', { 
                  hour: '2-digit', 
                  minute: '2-digit' 
                })} - {new Date(item.endTime).toLocaleTimeString(language === 'ja' ? 'ja-JP' : 'en-US', { 
                  hour: '2-digit', 
                  minute: '2-digit' 
                })}
              </Text>
            </View>
          )}
        </View>
      </LinearGradient>
    </TouchableOpacity>
  );

  const renderSectionHeader = ({ section }: { section: VisitSection }) => (
    <View style={[
      styles.sectionHeader,
      { backgroundColor: theme.colors.background.primary }
    ]}>
      <LinearGradient
        colors={['rgba(168, 85, 247, 0.1)', 'rgba(147, 51, 234, 0.1)']}
        style={styles.sectionHeaderGradient}
      >
        <Text style={[styles.sectionTitle, { color: theme.colors.text.primary }]}>
          {section.title}
        </Text>
        <Text style={[styles.sectionCount, { color: theme.colors.text.secondary }]}>
          {language === 'ja' ? `${section.data.length}件` : `${section.data.length} records`}
        </Text>
      </LinearGradient>
    </View>
  );

  if (isLoading && visits.length === 0) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
        <Header 
          title={language === 'ja' ? '来園記録' : 'Visit Records'} 
          onMenuOpen={() => setMenuVisible(true)}
        />
        <View style={styles.loadingContainer}>
          <Text style={[styles.loadingText, { color: theme.colors.text.secondary }]}>
            {language === 'ja' ? '読み込み中...' : 'Loading...'}
          </Text>
        </View>
      </View>
    );
  }

  if (visits.length === 0) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
        <Header 
          title={language === 'ja' ? '来園記録' : 'Visit Records'} 
          onMenuOpen={() => setMenuVisible(true)}
        />
        <View style={styles.emptyContainer}>
          <Ionicons name="calendar-outline" size={64} color={theme.colors.text.secondary} />
          <Text style={[styles.emptyTitle, { color: theme.colors.text.primary }]}>
            {language === 'ja' ? 'まだ来園記録がありません' : 'No visit records yet'}
          </Text>
          <Text style={[styles.emptySubtitle, { color: theme.colors.text.secondary }]}>
            {language === 'ja' ? '最初の来園記録を作成しましょう' : "Let's create your first visit record"}
          </Text>
          <TouchableOpacity
            style={styles.createButton}
            onPress={() => {
              // Navigate to main tabs and then record screen
              navigation.navigate('Main' as never);
            }}
          >
            <LinearGradient
              colors={['#a855f7', '#9333ea']}
              style={styles.createButtonGradient}
            >
              <Ionicons name="add" size={20} color={colors.utility.white} />
              <Text style={styles.createButtonText}>
                {language === 'ja' ? '新しい記録を作成' : 'Create New Record'}
              </Text>
            </LinearGradient>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  return (
    <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
      <View style={{ flex: 1, backgroundColor: theme.colors.background.primary }}>
        <Header 
          title={language === 'ja' ? '来園記録' : 'Visit Records'} 
          onMenuOpen={() => setMenuVisible(true)}
        />
        <SectionList
        sections={visitSections}
        renderItem={renderVisitItem}
        renderSectionHeader={renderSectionHeader}
        keyExtractor={(item) => item.id}
        style={{ flex: 1 }}
        contentContainerStyle={{ 
          paddingHorizontal: spacing[4], 
          paddingBottom: (Platform.OS === 'ios' ? 65 : 60) + insets.bottom + 20 
        }}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            tintColor={colors.purple[500]}
          />
        }
        showsVerticalScrollIndicator={true}
        scrollEnabled={true}
      />
      </View>
      
      <DrawerMenu
        visible={menuVisible}
        onClose={() => setMenuVisible(false)}
      />
    </SwipeableScreen>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  sectionList: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: spacing[6],
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: '600',
    marginTop: spacing[6],
    marginBottom: spacing[2],
  },
  emptySubtitle: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: spacing[8],
  },
  createButton: {
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  createButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: spacing[4],
    paddingHorizontal: spacing[6],
  },
  createButtonText: {
    color: colors.utility.white,
    fontSize: 16,
    fontWeight: '600',
    marginLeft: spacing[2],
  },
  listContent: {
    paddingHorizontal: spacing[4],
    paddingBottom: spacing[8],
  },
  sectionHeader: {
    marginTop: spacing[4],
    marginBottom: spacing[2],
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
  },
  sectionHeaderGradient: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: spacing[3],
    paddingHorizontal: spacing[4],
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  sectionCount: {
    fontSize: 14,
  },
  visitCard: {
    marginBottom: spacing[3],
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  visitCardGradient: {
    padding: spacing[4],
  },
  visitHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: spacing[3],
  },
  visitInfo: {
    flex: 1,
  },
  parkInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: spacing[2],
  },
  parkIcon: {
    width: 32,
    height: 32,
    borderRadius: borderRadius.md,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: spacing[3],
  },
  parkName: {
    fontSize: 16,
    fontWeight: '600',
  },
  visitDate: {
    fontSize: 14,
  },
  visitStats: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing[3],
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statText: {
    fontSize: 12,
    marginLeft: spacing[1],
  },
});
</file>

<file path="index.js">
import { registerRootComponent } from 'expo';

import App from './App.tsx';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
</file>

<file path="package.json">
{
  "name": "tdr-days",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^6.7.2",
    "@fortawesome/free-solid-svg-icons": "^6.7.2",
    "@fortawesome/react-native-fontawesome": "^0.3.2",
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "^8.4.1",
    "@react-navigation/bottom-tabs": "^7.3.14",
    "@react-navigation/drawer": "^7.4.1",
    "@react-navigation/native": "^7.1.10",
    "@react-navigation/stack": "^7.3.3",
    "expo": "~53.0.9",
    "expo-blur": "^14.1.4",
    "expo-file-system": "^18.1.10",
    "expo-image-manipulator": "^13.1.7",
    "expo-image-picker": "^16.1.4",
    "expo-linear-gradient": "^14.1.4",
    "expo-status-bar": "~2.2.3",
    "react": "19.0.0",
    "react-native": "0.79.2",
    "react-native-calendars": "^1.1312.1",
    "react-native-chart-kit": "^6.12.0",
    "react-native-draggable-flatlist": "^4.0.3",
    "react-native-fontawesome": "^7.0.0",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-paper": "^5.14.5",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-svg": "15.11.2",
    "react-native-vector-icons": "^10.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "~19.0.10",
    "typescript": "~5.8.3"
  },
  "private": true
}
</file>

<file path="src/components/DrawerMenu.tsx">
// 美しいドロワーメニューコンポーネント
// ハンバーガーメニューから開くサイドメニュー

import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Animated,
  ScrollView,
  Dimensions,
  Platform,
  Image,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons, FontAwesome5 } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { useResponsive } from '../hooks/useResponsive';
import { ParkType } from '../types/models';

const { width: screenWidth } = Dimensions.get('window');

interface DrawerMenuProps {
  visible: boolean;
  onClose: () => void;
}

interface MenuItem {
  id: string;
  title: string;
  icon: string;
  iconLibrary?: 'Ionicons' | 'FontAwesome5';
  color: string;
  description?: string;
  onPress: () => void;
}

export const DrawerMenu: React.FC<DrawerMenuProps> = ({ visible, onClose }) => {
  const navigation = useNavigation();
  const { theme, themeConfig, toggleTheme } = useTheme();
  const { t, language, setLanguage } = useLanguage();
  const { rSpacing, rFontSize } = useResponsive();
  
  const slideAnim = useRef(new Animated.Value(-screenWidth)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;

  // メニューアイテム
  const menuItems: MenuItem[] = [
    {
      id: 'home',
      title: t('nav.home'),
      icon: 'home',
      color: colors.purple.bright,
      description: language === 'ja' ? 'メインダッシュボード' : 'Main Dashboard',
      onPress: () => {
        onClose();
        navigation.navigate('Home' as never);
      }
    },
    {
      id: 'visitList',
      title: language === 'ja' ? '来園記録' : 'Visit Records',
      icon: 'list',
      color: colors.purple[500],
      description: language === 'ja' ? '過去の来園記録を表示' : 'View past visit records',
      onPress: () => {
        onClose();
        navigation.navigate('VisitList' as never);
      }
    },
    {
      id: 'record',
      title: t('nav.record'),
      icon: 'add-circle',
      color: colors.green[500],
      description: language === 'ja' ? '新しい来園を記録' : 'Record new visit',
      onPress: () => {
        onClose();
        navigation.navigate('Record' as never);
      }
    },
    {
      id: 'analytics',
      title: t('nav.analytics'),
      icon: 'stats-chart',
      color: colors.blue[500],
      description: language === 'ja' ? 'データ分析と統計' : 'Data analysis & statistics',
      onPress: () => {
        onClose();
        navigation.navigate('Analytics' as never);
      }
    },
    {
      id: 'profile',
      title: t('nav.profile'),
      icon: 'person',
      color: colors.orange[500],
      description: language === 'ja' ? 'プロフィールと設定' : 'Profile & settings',
      onPress: () => {
        onClose();
        navigation.navigate('Profile' as never);
      }
    },
  ];

  // 今日の日付を日本時間で取得
  const getTodayInJST = () => {
    const now = new Date();
    const jstOffset = 9 * 60; // JST is UTC+9
    const jstTime = new Date(now.getTime() + (jstOffset * 60 * 1000));
    return jstTime.toISOString().split('T')[0]; // YYYY-MM-DD format
  };

  const quickActions: MenuItem[] = [
    {
      id: 'disneyland',
      title: t('home.tokyoDisneyland'),
      icon: 'fort-awesome',
      iconLibrary: 'FontAwesome5',
      color: colors.pink[500],
      description: language === 'ja' ? '来園記録を追加' : 'Add visit record',
      onPress: () => {
        const today = getTodayInJST();
        console.log('Navigating to Record screen with LAND park and date:', today);
        onClose();
        navigation.navigate('Record' as never, {
          parkType: ParkType.LAND,
          date: today
        } as never);
      }
    },
    {
      id: 'disneysea',
      title: t('home.tokyoDisneysea'),
      icon: 'globe',
      iconLibrary: 'FontAwesome5',
      color: colors.teal[500],
      description: language === 'ja' ? '来園記録を追加' : 'Add visit record',
      onPress: () => {
        const today = getTodayInJST();
        console.log('Navigating to Record screen with SEA park and date:', today);
        onClose();
        navigation.navigate('Record' as never, {
          parkType: ParkType.SEA,
          date: today
        } as never);
      }
    },
  ];

  useEffect(() => {
    if (visible) {
      // 開くときは完全に左側から開始
      slideAnim.setValue(-screenWidth);
      fadeAnim.setValue(0);
      
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 280,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 280,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: -screenWidth,
          duration: 220,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 220,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible]);

  const handleLanguageToggle = () => {
    const newLanguage = language === 'ja' ? 'en' : 'ja';
    setLanguage(newLanguage);
  };


  return (
    <Modal
      visible={visible}
      transparent
      animationType="none"
      onRequestClose={onClose}
    >
      {/* Backdrop */}
      <Animated.View
        style={[
          styles.backdrop,
          {
            opacity: fadeAnim,
          },
        ]}
      >
        <TouchableOpacity
          style={StyleSheet.absoluteFillObject}
          activeOpacity={1}
          onPress={onClose}
        />
      </Animated.View>

      {/* Drawer Content */}
      <Animated.View
        style={[
          styles.drawer,
          {
            transform: [
              { translateX: slideAnim },
            ],
            opacity: fadeAnim,
          },
        ]}
      >
          <LinearGradient
            colors={['#ffffff', '#faf8ff']}
            style={styles.drawerGradient}
          >
          {/* Header */}
          <View style={styles.drawerHeader}>
            <View style={styles.appInfo}>
              <View style={styles.appIcon}>
                <Image 
                  source={require('../../assets/icon.png')} 
                  style={styles.appIconImage}
                  resizeMode="contain"
                />
              </View>
              <View style={styles.appText}>
                <Text style={styles.appTitle}>TDR Days</Text>
                <Text style={styles.appSubtitle}>
                  {language === 'ja' ? 'ディズニー来園記録' : 'Disney Resort Diary'}
                </Text>
              </View>
            </View>
          </View>

          <ScrollView
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {/* Main Navigation */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                {language === 'ja' ? 'メインメニュー' : 'Main Menu'}
              </Text>
              {menuItems.map((item) => (
                <TouchableOpacity
                  key={item.id}
                  style={styles.menuItem}
                  onPress={item.onPress}
                  activeOpacity={0.7}
                >
                  <View style={[styles.menuIcon, { backgroundColor: item.color + '15' }]}>
                    <Ionicons name={item.icon as any} size={20} color={item.color} />
                  </View>
                  <View style={styles.menuContent}>
                    <Text style={styles.menuTitle}>{item.title}</Text>
                    {item.description && (
                      <Text style={styles.menuDescription}>{item.description}</Text>
                    )}
                  </View>
                  <Ionicons name="chevron-forward" size={16} color={colors.text.tertiary} />
                </TouchableOpacity>
              ))}
            </View>

            {/* Quick Actions */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                {language === 'ja' ? 'クイックアクション' : 'Quick Actions'}
              </Text>
              {quickActions.map((item) => (
                <TouchableOpacity
                  key={item.id}
                  style={styles.menuItem}
                  onPress={item.onPress}
                  activeOpacity={0.7}
                >
                  <View style={[styles.menuIcon, { backgroundColor: item.color + '15' }]}>
                    {item.iconLibrary === 'FontAwesome5' ? (
                      <FontAwesome5 name={item.icon as any} size={20} color={item.color} />
                    ) : (
                      <Ionicons name={item.icon as any} size={20} color={item.color} />
                    )}
                  </View>
                  <View style={styles.menuContent}>
                    <Text style={styles.menuTitle}>{item.title}</Text>
                    {item.description && (
                      <Text style={styles.menuDescription}>{item.description}</Text>
                    )}
                  </View>
                  <Ionicons name="add" size={16} color={colors.text.tertiary} />
                </TouchableOpacity>
              ))}
            </View>

            {/* Settings */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                {language === 'ja' ? '設定' : 'Settings'}
              </Text>
              
              {/* Language Toggle */}
              <TouchableOpacity
                style={styles.menuItem}
                onPress={handleLanguageToggle}
                activeOpacity={0.7}
              >
                <View style={[styles.menuIcon, { backgroundColor: colors.blue[500] + '15' }]}>
                  <Ionicons name="language" size={20} color={colors.blue[500]} />
                </View>
                <View style={styles.menuContent}>
                  <Text style={styles.menuTitle}>
                    {language === 'ja' ? 'Language / 言語' : 'Language / 言語'}
                  </Text>
                  <Text style={styles.menuDescription}>
                    {language === 'ja' ? '現在: 日本語 → English に変更' : 'Current: English → 日本語 に変更'}
                  </Text>
                </View>
              </TouchableOpacity>
            </View>

            {/* Bottom Spacing */}
            <View style={{ height: 100 }} />
          </ScrollView>
          </LinearGradient>
      </Animated.View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  backdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  drawer: {
    position: 'absolute',
    left: 0,
    top: 0,
    bottom: 0,
    width: screenWidth * 0.85,
    maxWidth: 320,
    shadowColor: colors.effects.shadowMedium,
    shadowOffset: { width: 2, height: 0 },
    shadowOpacity: 1,
    shadowRadius: 8,
    elevation: 5,
  },
  drawerGradient: {
    flex: 1,
  },
  drawerHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'ios' ? 60 : 40,
    paddingBottom: 24,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(168, 85, 247, 0.1)',
  },
  appInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  appIcon: {
    width: 52,
    height: 52,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 16,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    overflow: 'hidden',
  },
  appIconImage: {
    width: '100%',
    height: '100%',
  },
  appText: {
    flex: 1,
  },
  appTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: colors.gray[800],
    marginBottom: 4,
  },
  appSubtitle: {
    fontSize: 14,
    color: colors.gray[600],
    fontWeight: '500',
  },
  scrollView: {
    flex: 1,
  },
  section: {
    paddingHorizontal: 20,
    paddingVertical: 16,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.gray[600],
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    marginBottom: 12,
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 12,
    marginBottom: 4,
    backgroundColor: '#ffffff',
    shadowColor: 'rgba(0, 0, 0, 0.1)',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 1,
    shadowRadius: 2,
    elevation: 1,
  },
  menuIcon: {
    width: 36,
    height: 36,
    borderRadius: 10,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  menuContent: {
    flex: 1,
  },
  menuTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: colors.gray[800],
    marginBottom: 2,
  },
  menuDescription: {
    fontSize: 12,
    color: colors.gray[600],
  },
});

export default DrawerMenu;
</file>

<file path="src/components/Header.tsx">
// 統一感のある美しいヘッダーコンポーネント
// 全ページで使用する共通ヘッダー

import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Animated,
  Platform,
  StatusBar,
} from 'react-native';
import { PanGestureHandler, State } from 'react-native-gesture-handler';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { useResponsive } from '../hooks/useResponsive';

interface HeaderAction {
  icon: string;
  onPress: () => void;
}

interface HeaderProps {
  title: string;
  subtitle?: string;
  showBackButton?: boolean;
  onBackPress?: () => void;
  rightComponent?: React.ReactNode;
  rightActions?: HeaderAction[];
  variant?: 'default' | 'minimal' | 'hero';
  onMenuOpen?: () => void;
}

export const Header: React.FC<HeaderProps> = ({
  title,
  subtitle,
  showBackButton = false,
  onBackPress,
  rightComponent,
  rightActions,
  variant = 'default',
  onMenuOpen
}) => {
  const { theme, themeConfig } = useTheme();
  const { t } = useLanguage();
  const { rSpacing, rFontSize, isBreakpoint } = useResponsive();

  const isTabletOrLarger = isBreakpoint('tablet');
  const isHeroVariant = variant === 'hero';
  const isMinimalVariant = variant === 'minimal';

  const statusBarHeight = Platform.OS === 'ios' ? 44 : StatusBar.currentHeight || 24;
  const headerHeight = statusBarHeight + 60; // Fixed height calculation

  return (
    <>
      <View style={[styles.container, { height: headerHeight }]}>
        {/* Beautiful Background Gradient */}
        <LinearGradient
          colors={['#fefbff', '#f8f4ff', '#f3e8ff']}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
          style={styles.gradient}
        >
          {/* Floating Decorative Elements */}
          <View style={styles.decorativeElements}>
            <View style={[styles.floatingDot, { top: statusBarHeight + 10, right: 30, backgroundColor: colors.purple[200] + '30' }]} />
            <View style={[styles.floatingDot, { top: statusBarHeight + 20, right: 80, backgroundColor: colors.pink[200] + '30' }]} />
            <View style={[styles.floatingDot, { top: statusBarHeight + 30, right: 50, backgroundColor: colors.blue[200] + '30' }]} />
          </View>

          {/* Status Bar Spacer */}
          <View style={{ height: statusBarHeight }} />
          
          {/* Header Content */}
          <View style={styles.content}>
            {/* Left Section - Beautiful Glass Button */}
            <View style={styles.leftSection}>
              {showBackButton ? (
                <TouchableOpacity
                  style={styles.modernButton}
                  onPress={onBackPress}
                  activeOpacity={0.7}
                >
                  <LinearGradient
                    colors={
                      theme.mode === 'dark' 
                        ? ['rgba(45, 45, 45, 0.95)', 'rgba(30, 30, 30, 0.85)']
                        : ['rgba(255, 255, 255, 0.95)', 'rgba(250, 250, 250, 0.85)']
                    }
                    style={styles.modernButtonGradient}
                  >
                    <View style={[
                      styles.modernButtonInner,
                      {
                        backgroundColor: theme.mode === 'dark' 
                          ? 'rgba(40, 40, 40, 0.98)' 
                          : 'rgba(255, 255, 255, 0.98)',
                        borderColor: theme.mode === 'dark'
                          ? 'rgba(255, 255, 255, 0.1)'
                          : 'rgba(0, 0, 0, 0.08)',
                      }
                    ]}>
                      <Ionicons 
                        name="arrow-back" 
                        size={20} 
                        color={theme.mode === 'dark' ? colors.gray[300] : colors.gray[700]} 
                      />
                    </View>
                  </LinearGradient>
                </TouchableOpacity>
              ) : (
                <TouchableOpacity
                  style={styles.modernButton}
                  onPress={() => onMenuOpen?.()}
                  activeOpacity={0.7}
                >
                  <LinearGradient
                    colors={
                      theme.mode === 'dark' 
                        ? ['rgba(45, 45, 45, 0.95)', 'rgba(30, 30, 30, 0.85)']
                        : ['rgba(255, 255, 255, 0.95)', 'rgba(250, 250, 250, 0.85)']
                    }
                    style={styles.modernButtonGradient}
                  >
                    <View style={[
                      styles.modernButtonInner,
                      {
                        backgroundColor: theme.mode === 'dark' 
                          ? 'rgba(40, 40, 40, 0.98)' 
                          : 'rgba(255, 255, 255, 0.98)',
                        borderColor: theme.mode === 'dark'
                          ? 'rgba(255, 255, 255, 0.1)'
                          : 'rgba(0, 0, 0, 0.08)',
                      }
                    ]}>
                      <Ionicons 
                        name="menu" 
                        size={20} 
                        color={theme.mode === 'dark' ? colors.gray[300] : colors.gray[700]} 
                      />
                    </View>
                  </LinearGradient>
                </TouchableOpacity>
              )}
            </View>

            {/* Center Section - Enhanced Typography */}
            <View style={styles.centerSection}>
              <Text 
                style={[
                  styles.title,
                  {
                    fontSize: rFontSize(20),
                    color: colors.gray[800],
                    fontWeight: '700',
                    letterSpacing: 0.3,
                  }
                ]}
                numberOfLines={1}
              >
                {title}
              </Text>
              {subtitle && (
                <Text 
                  style={[
                    styles.subtitle,
                    {
                      fontSize: rFontSize(14),
                      color: colors.gray[600],
                      marginTop: 2,
                    }
                  ]}
                  numberOfLines={1}
                >
                  {subtitle}
                </Text>
              )}
            </View>

            {/* Right Section - Glass Action Buttons */}
            <View style={styles.rightSection}>
              {rightComponent ? (
                rightComponent
              ) : rightActions && rightActions.length > 0 ? (
                <View style={styles.rightActions}>
                  {rightActions.map((action, index) => (
                    <TouchableOpacity
                      key={index}
                      style={[styles.modernButton, { marginLeft: index > 0 ? 8 : 0 }]}
                      onPress={action.onPress}
                      activeOpacity={0.7}
                    >
                      <LinearGradient
                        colors={
                          theme.mode === 'dark' 
                            ? ['rgba(45, 45, 45, 0.95)', 'rgba(30, 30, 30, 0.85)']
                            : ['rgba(255, 255, 255, 0.95)', 'rgba(250, 250, 250, 0.85)']
                        }
                        style={styles.modernButtonGradient}
                      >
                        <View style={[
                          styles.modernButtonInner,
                          {
                            backgroundColor: theme.mode === 'dark' 
                              ? 'rgba(40, 40, 40, 0.98)' 
                              : 'rgba(255, 255, 255, 0.98)',
                            borderColor: theme.mode === 'dark'
                              ? 'rgba(255, 255, 255, 0.1)'
                              : 'rgba(0, 0, 0, 0.08)',
                          }
                        ]}>
                          <Ionicons 
                            name={action.icon as any} 
                            size={18} 
                            color={theme.mode === 'dark' ? colors.gray[300] : colors.gray[700]} 
                          />
                        </View>
                      </LinearGradient>
                    </TouchableOpacity>
                  ))}
                </View>
              ) : (
                <View style={{ width: 44 }} />
              )}
            </View>
          </View>

          {/* Beautiful Bottom Shadow */}
          <LinearGradient
            colors={['transparent', 'rgba(0, 0, 0, 0.05)']}
            style={styles.bottomShadow}
            pointerEvents="none"
          />
        </LinearGradient>

        {/* Elegant Bottom Border */}
        <View style={[
          styles.bottomBorder, 
          { 
            backgroundColor: 'rgba(168, 85, 247, 0.1)',
            height: 1,
          }
        ]} />
      </View>
    </>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    zIndex: 1000,
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
  },
  gradient: {
    flex: 1,
    width: '100%',
    position: 'relative',
  },
  decorativeElements: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    pointerEvents: 'none',
  },
  floatingDot: {
    position: 'absolute',
    width: 8,
    height: 8,
    borderRadius: 4,
    opacity: 0.6,
  },
  content: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 0,
  },
  leftSection: {
    width: 52,
    alignItems: 'flex-start',
  },
  centerSection: {
    flex: 1,
    alignItems: 'center',
    paddingHorizontal: 16,
  },
  rightSection: {
    minWidth: 52,
    alignItems: 'flex-end',
  },
  rightActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  modernButton: {
    width: 42,
    height: 42,
    borderRadius: 14,
    overflow: 'hidden',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.12,
    shadowRadius: 12,
  },
  modernButtonGradient: {
    width: '100%',
    height: '100%',
    borderRadius: 14,
    padding: 1.5,
  },
  modernButtonInner: {
    flex: 1,
    borderRadius: 12.5,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 0.5,
  },
  circleButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(168, 85, 247, 0.1)',
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  glassButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    overflow: 'hidden',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  glassButtonGradient: {
    width: 44,
    height: 44,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 22,
    borderWidth: 0,
    overflow: 'hidden',
  },
  iconContainer: {
    width: 44,
    height: 44,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 22,
    overflow: 'hidden',
  },
  backButton: {
    // Additional styling for back button if needed
  },
  title: {
    textAlign: 'center',
    fontFamily: Platform.OS === 'ios' ? 'System' : 'sans-serif',
  },
  subtitle: {
    fontWeight: '500',
    textAlign: 'center',
    fontFamily: Platform.OS === 'ios' ? 'System' : 'sans-serif',
  },
  bottomShadow: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 8,
  },
  bottomBorder: {
    width: '100%',
  },
});

export default Header;
</file>

<file path="src/navigation/AppNavigator.tsx">
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { useTheme } from '../contexts/ThemeContext';
import { TabNavigator } from './TabNavigator';
import { VisitDetailScreen } from '../screens';
import { colors } from '../styles/colors';

const Stack = createStackNavigator();

export const AppNavigator = () => {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';

  return (
    <NavigationContainer
      theme={{
        dark: isDark,
        colors: {
          primary: colors.purple[500],
          background: theme.colors.background.primary,
          card: theme.colors.background.card,
          text: theme.colors.text.primary,
          border: theme.colors.utility.borderLight,
          notification: colors.purple[500],
        },
      }}
    >
      <Stack.Navigator
        screenOptions={{
          headerShown: false,
          cardStyle: {
            backgroundColor: theme.colors.background.primary,
          },
        }}
      >
        <Stack.Screen name="Main" component={TabNavigator} />
        <Stack.Screen name="VisitDetail" component={VisitDetailScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};
</file>

<file path="src/screens/HomeScreen.tsx">
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Alert,
  RefreshControl,
  Animated,
  Easing,
  Platform,
  ScrollView,
  Dimensions,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons, FontAwesome5 } from '@expo/vector-icons';
import DraggableFlatList, {
  ScaleDecorator,
  ShadowDecorator,
  OpacityDecorator,
} from 'react-native-draggable-flatlist';
import { useNavigation } from '@react-navigation/native';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { useVisits } from '../hooks/useVisits';
import { useActions } from '../hooks/useActions';
import { useResponsive, useColumns } from '../hooks/useResponsive';
import { colors } from '../styles/colors';
import { Header } from '../components/Header';
import { SwipeableScreen } from '../components/SwipeableScreen';
import { DrawerMenu } from '../components/DrawerMenu';
import { VisitCard } from '../components/VisitCard';
import { ActionModal } from '../components/ActionModal';
import { VisitFilter } from '../components/VisitFilter';
import { GridLayout } from '../components/layouts/GridLayout';
import { ResponsiveContainer, ResponsiveSection } from '../components/layouts/ResponsiveContainer';
import {
  Visit,
  TimelineAction,
  VisitFilter as VisitFilterType,
  CreateInput,
  UpdateInput,
  ParkType,
} from '../types/models';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface ExpandedVisit {
  visitId: string;
  isExpanded: boolean;
}

// Floating Magic Card Component
const MagicCard = ({ icon, title, subtitle, value, color, onPress, delay = 0, responsive }: any) => {
  const [fadeAnim] = useState(new Animated.Value(0));
  const [scaleAnim] = useState(new Animated.Value(0.8));
  const [floatAnim] = useState(new Animated.Value(0));
  
  // Calculate responsive dimensions for proper 2x2 grid layout
  const screenWidth = responsive?.dimensions?.width || 375;
  const containerPadding = 32; // 16px on each side
  const cardSpacing = 12; // Gap between cards
  const availableWidth = screenWidth - containerPadding - cardSpacing;
  const cardWidth = (availableWidth / 2) - 4; // Exact half width minus small margin

  useEffect(() => {
    // Entrance animation
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 800,
        delay,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        delay,
        tension: 80,
        friction: 8,
        useNativeDriver: true,
      }),
    ]).start();

    // Floating animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(floatAnim, {
          toValue: 1,
          duration: 3000,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
        Animated.timing(floatAnim, {
          toValue: 0,
          duration: 3000,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
      ])
    ).start();
  }, [delay]);

  const translateY = floatAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -8],
  });

  return (
    <Animated.View
      style={[
        {
          opacity: fadeAnim,
          transform: [
            { scale: scaleAnim },
            { translateY },
          ],
        },
      ]}
    >
      <TouchableOpacity
        onPress={onPress}
        style={[styles.magicCard, { 
          width: '100%',
          height: 120,
          marginHorizontal: 0,
          marginBottom: 0,
        }]}
        activeOpacity={0.8}
      >
        <LinearGradient
          colors={[`${color}15`, `${color}08`, `${color}15`]}
          style={[styles.magicCardGradient, { width: '100%', height: '100%' }]}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <BlurView intensity={25} style={styles.magicCardBlur}>
            <View style={[styles.magicCardIcon, { backgroundColor: `${color}15` }]}>
              {icon}
            </View>
            <Text style={[styles.magicCardValue, { color }]} numberOfLines={1}>{value}</Text>
            <Text style={styles.magicCardTitle} numberOfLines={1}>{title}</Text>
            <Text style={styles.magicCardSubtitle} numberOfLines={1}>{subtitle}</Text>
          </BlurView>
        </LinearGradient>
      </TouchableOpacity>
    </Animated.View>
  );
};



export const HomeScreen = () => {
  const navigation = useNavigation();
  const { theme } = useTheme();
  const { t, language } = useLanguage();
  const isDark = theme?.mode === 'dark';
  const [menuVisible, setMenuVisible] = useState(false);
  const responsive = useResponsive();
  const { 
    dimensions, 
    breakpoint, 
    rSpacing, 
    rFontSize,
    isBreakpoint,
    layoutConfig,
    gridConfig,
    responsive: responsiveValue 
  } = responsive || {};
  
  // Safe fallback values
  const safeRSpacing = (value: number) => rSpacing ? rSpacing(value) : value;
  const safeRFontSize = (value: number) => rFontSize ? rFontSize(value) : value;

  // Hooks
  const {
    visits = [],
    companions = [],
    isLoading: visitsLoading = false,
    error: visitsError,
    refreshData: refreshVisits,
  } = useVisits() || {};
  
  const {
    actions = [],
    isLoading: actionsLoading = false,
    error: actionsError,
    getActionsByVisit,
    createAction,
    updateAction,
    deleteAction,
    reorderActions,
    refreshData: refreshActions,
  } = useActions() || {};
  
  // State
  const [headerAnimation] = useState(new Animated.Value(0));
  const [refreshing, setRefreshing] = useState(false);
  const [floatingAnimation] = useState(new Animated.Value(0));

  // Animation effects
  useEffect(() => {
    Animated.timing(headerAnimation, {
      toValue: 1,
      duration: 1200,
      easing: Easing.out(Easing.bezier(0.25, 0.46, 0.45, 0.94)),
      useNativeDriver: true,
    }).start();

    // Floating elements animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(floatingAnimation, {
          toValue: 1,
          duration: 6000,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
        Animated.timing(floatingAnimation, {
          toValue: 0,
          duration: 6000,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
      ])
    ).start();
  }, []);

  // Get visit stats
  const getVisitStats = useMemo(() => {
    const totalVisits = visits.length;
    const landVisits = visits.filter(v => v.parkType === ParkType.LAND).length;
    const seaVisits = visits.filter(v => v.parkType === ParkType.SEA).length;
    const totalActions = visits.reduce((sum, visit) => sum + (visit.actionCount || 0), 0);
    const recentVisits = visits.filter(v => {
      // 日本時間での30日前の日付を計算
      const now = new Date();
      const jstOffset = 9 * 60; // JST is UTC+9
      const nowJST = new Date(now.getTime() + (jstOffset * 60 * 1000));
      const thirtyDaysAgoJST = new Date(nowJST);
      thirtyDaysAgoJST.setDate(thirtyDaysAgoJST.getDate() - 30);
      
      const visitDate = new Date(v.date);
      const visitDateJST = new Date(visitDate.getTime() + (jstOffset * 60 * 1000));
      
      return visitDateJST >= thirtyDaysAgoJST;
    }).length;
    
    return { totalVisits, landVisits, seaVisits, totalActions, recentVisits };
  }, [visits]);

  // Refresh handler
  const handleRefresh = useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([refreshVisits(), refreshActions()]);
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refreshVisits, refreshActions]);

  return (
    <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
      <ResponsiveContainer
        scroll={false}
        padding={false}
        style={[styles.container, { backgroundColor: theme?.colors?.background?.primary || '#fff' }]}
      >
        <Header 
          title={t('nav.home')} 
          onMenuOpen={() => setMenuVisible(true)}
        />
        <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            tintColor={colors.purple[500]}
            colors={[colors.purple[500]]}
          />
        }
      >
        {/* Enhanced Hero Section with Floating Elements */}
        <Animated.View
          style={[
            styles.heroSection,
            {
              opacity: headerAnimation,
              transform: [
                {
                  translateY: headerAnimation.interpolate({
                    inputRange: [0, 1],
                    outputRange: [-50, 0],
                  }),
                },
              ],
            },
          ]}
        >
          {/* Magical Background with Floating Elements */}
          <LinearGradient
            colors={[
              'rgba(167, 139, 250, 0.03)',
              'rgba(196, 181, 253, 0.02)',
              'rgba(255, 255, 255, 1)',
            ]}
            style={styles.heroGradient}
          >
            {/* Floating Magic Elements */}
            <View style={styles.floatingElementsContainer}>
              <Animated.View style={[
                styles.floatingElement, 
                { 
                  top: 20, 
                  left: 30, 
                  transform: [
                    { rotate: '15deg' },
                    {
                      translateY: floatingAnimation.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0, -10],
                      })
                    }
                  ] 
                }
              ]}>
                <Ionicons name="sparkles" size={16} color={colors.purple[300]} />
              </Animated.View>
              <Animated.View style={[
                styles.floatingElement, 
                { 
                  top: 40, 
                  right: 50, 
                  transform: [
                    { rotate: '-20deg' },
                    {
                      translateY: floatingAnimation.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0, 8],
                      })
                    }
                  ] 
                }
              ]}>
                <Ionicons name="star" size={14} color={colors.pink[300]} />
              </Animated.View>
              <Animated.View style={[
                styles.floatingElement, 
                { 
                  top: 80, 
                  left: 80, 
                  transform: [
                    { rotate: '25deg' },
                    {
                      translateY: floatingAnimation.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0, -6],
                      })
                    }
                  ] 
                }
              ]}>
                <FontAwesome5 name="magic" size={12} color={colors.blue[300]} />
              </Animated.View>
              <Animated.View style={[
                styles.floatingElement, 
                { 
                  top: 60, 
                  right: 30, 
                  transform: [
                    { rotate: '-15deg' },
                    {
                      translateY: floatingAnimation.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0, 12],
                      })
                    }
                  ] 
                }
              ]}>
                <Ionicons name="heart" size={12} color={colors.red[300]} />
              </Animated.View>
            </View>

            <View style={styles.heroContainer}>
              {/* Welcome Text with Enhanced Typography */}
              <View style={styles.welcomeContainer}>
                <Text style={[styles.welcomeText, { color: theme?.colors?.text?.secondary || '#666' }]}>
                  {t('home.welcome')}
                </Text>
                <Text style={[styles.appTitle, { color: theme?.colors?.text?.primary || '#000' }]}>
                  {t('home.appTitle')}
                  <Text style={[styles.appTitleAccent, { color: colors.purple[500] }]}> ✨</Text>
                </Text>
                <Text style={[styles.tagline, { color: theme?.colors?.text?.secondary || '#666' }]}>
                  {t('home.tagline')}
                </Text>
              </View>

              {/* Enhanced Stats Cards with Animations - 2x2 Grid */}
              <View style={[styles.statsCardsGrid, {
                paddingHorizontal: 16,
              }]}>
                <View style={styles.statsCardContainer}>
                  <MagicCard
                    icon={<Ionicons name="calendar" size={22} color={colors.purple.bright} />}
                    title={t('home.totalVisits')}
                    subtitle={t('home.allTime')}
                    value={getVisitStats.totalVisits}
                    color={colors.purple.bright}
                    delay={100}
                    responsive={responsive}
                  />
                </View>
                
                <View style={styles.statsCardContainer}>
                  <MagicCard
                    icon={<Ionicons name="flash" size={22} color={colors.blue[500]} />}
                    title={t('home.activities')}
                    subtitle={t('home.logged')}
                    value={getVisitStats.totalActions}
                    color={colors.blue[500]}
                    delay={200}
                    responsive={responsive}
                  />
                </View>
                
                <View style={styles.statsCardContainer}>
                  <MagicCard
                    icon={<FontAwesome5 name="fort-awesome" size={20} color={colors.pink[500]} />}
                    title={t('home.disneylandShort')}
                    subtitle=""
                    value={`${getVisitStats.landVisits}${t('home.visits')}`}
                    color={colors.pink[500]}
                    delay={300}
                    responsive={responsive}
                  />
                </View>
                
                <View style={styles.statsCardContainer}>
                  <MagicCard
                    icon={<FontAwesome5 name="globe" size={20} color={colors.teal[500]} />}
                    title={t('home.disneyseaShort')}
                    subtitle=""
                    value={`${getVisitStats.seaVisits}${t('home.visits')}`}
                    color={colors.teal[500]}
                    delay={400}
                    responsive={responsive}
                  />
                </View>
              </View>
            </View>
          </LinearGradient>
        </Animated.View>




        {/* Fun Stats Section */}
        <View style={styles.funStatsSection}>
          <Text style={[styles.sectionTitle, { color: theme?.colors?.text?.primary || '#000' }]}>
            {language === 'ja' ? '魔法の記録 📊' : 'Magic Records 📊'}
          </Text>
          
          <View style={styles.funStatsGrid}>
            <View style={styles.funStatCard}>
              <LinearGradient
                colors={[colors.yellow[100], colors.yellow[50]]}
                style={styles.funStatGradient}
              >
                <Ionicons name="trophy" size={32} color={colors.yellow[600]} />
                <Text style={[styles.funStatValue, { color: colors.yellow[700] }]}>
                  {getVisitStats.recentVisits}
                </Text>
                <Text style={[styles.funStatLabel, { color: colors.yellow[600] }]}>
                  {language === 'ja' ? '今月の来園' : 'This Month'}
                </Text>
              </LinearGradient>
            </View>
            
            <View style={styles.funStatCard}>
              <LinearGradient
                colors={[colors.green[100], colors.green[50]]}
                style={styles.funStatGradient}
              >
                <Ionicons name="list" size={32} color={colors.green[600]} />
                <Text style={[styles.funStatValue, { color: colors.green[700] }]}>
                  {getVisitStats.totalActions}
                </Text>
                <Text style={[styles.funStatLabel, { color: colors.green[600] }]}>
                  {language === 'ja' ? '総アクション数' : 'Total Actions'}
                </Text>
              </LinearGradient>
            </View>
          </View>
        </View>

        {/* Recent Activity Section (if any visits exist) */}
        {visits.length > 0 && (
          <View style={styles.recentActivitySection}>
            <Text style={[styles.sectionTitle, { color: theme?.colors?.text?.primary || '#000' }]}>
              {t('home.recentMagic')}
            </Text>
            
            <View style={styles.recentVisitsContainer}>
              {visits
                .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
                .slice(0, 3)
                .map((visit, index) => (
                <TouchableOpacity
                  key={visit.id}
                  style={styles.recentVisitCard}
                  activeOpacity={0.8}
                  onPress={() => (navigation as any).navigate('VisitDetail', { visitId: visit.id })}
                >
                  <LinearGradient
                    colors={[
                      visit.parkType === ParkType.LAND ? colors.pink[100] : colors.teal[100],
                      visit.parkType === ParkType.LAND ? colors.pink[50] : colors.teal[50],
                    ]}
                    style={styles.recentVisitGradient}
                  >
                    <View style={styles.recentVisitIcon}>
                      {visit.parkType === ParkType.LAND ? (
                        <FontAwesome5 name="fort-awesome" size={20} color={colors.pink[600]} />
                      ) : (
                        <FontAwesome5 name="globe" size={20} color={colors.teal[600]} />
                      )}
                    </View>
                    <View style={styles.recentVisitInfo}>
                      <Text style={styles.recentVisitDate}>
                        {new Date(visit.date).toLocaleDateString()}
                      </Text>
                      <Text style={styles.recentVisitPark}>
                        {visit.parkType === ParkType.LAND ? t('park.disneyland') : t('park.disneysea')}
                      </Text>
                    </View>
                    <Ionicons name="chevron-forward" size={20} color={theme?.colors?.text?.secondary || '#999'} />
                  </LinearGradient>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        )}

        {/* Empty State for New Users */}
        {visits.length === 0 && (
          <View style={styles.emptyStateSection}>
            <LinearGradient
              colors={['rgba(167, 139, 250, 0.1)', 'rgba(196, 181, 253, 0.05)']}
              style={styles.emptyStateGradient}
            >
              <BlurView intensity={20} style={styles.emptyStateBlur}>
                <View style={styles.emptyStateIcon}>
                  <Ionicons name="sparkles" size={64} color={colors.purple[300]} />
                </View>
                <Text style={[styles.emptyStateTitle, { color: theme?.colors?.text?.primary || '#000' }]}>
                  {t('home.startJourney')}
                </Text>
                <Text style={[styles.emptyStateMessage, { color: theme?.colors?.text?.secondary || '#666' }]}>
                  {t('home.firstVisitMessage')}
                </Text>
                <TouchableOpacity style={styles.emptyStateCTA}>
                  <LinearGradient
                    colors={[colors.purple[600], colors.purple[500]]}
                    style={styles.emptyStateCTAGradient}
                  >
                    <Ionicons name="add" size={24} color={colors.utility.white} />
                    <Text style={styles.emptyStateCTAText}>{t('home.recordFirstVisit')}</Text>
                  </LinearGradient>
                </TouchableOpacity>
              </BlurView>
            </LinearGradient>
          </View>
        )}

        {/* Bottom Spacing */}
        <View style={{ height: 120 }} />
      </ScrollView>
      </ResponsiveContainer>
      
      <DrawerMenu
        visible={menuVisible}
        onClose={() => setMenuVisible(false)}
      />
    </SwipeableScreen>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
  },
  heroSection: {
    paddingTop: 20,
    marginBottom: 32,
  },
  heroGradient: {
    flex: 1,
    position: 'relative',
  },
  floatingElementsContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  floatingElement: {
    position: 'absolute',
    opacity: 0.6,
  },
  heroContainer: {
    minHeight: 280,
    paddingHorizontal: 16,
    paddingVertical: 32,
    borderBottomLeftRadius: 24,
    borderBottomRightRadius: 24,
  },
  welcomeContainer: {
    alignItems: 'center',
    marginBottom: 32,
  },
  welcomeText: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
    textAlign: 'center',
  },
  appTitle: {
    fontSize: 32,
    fontWeight: '700',
    marginBottom: 8,
    textAlign: 'center',
  },
  appTitleAccent: {
    fontSize: 28,
  },
  tagline: {
    fontSize: 14,
    fontWeight: '400',
    textAlign: 'center',
    lineHeight: 20,
  },
  statsCardsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    width: '100%',
    paddingVertical: 4,
  },
  statsCardContainer: {
    width: '48%',
    marginBottom: 10,
    minHeight: 120,
  },
  statsCard: {
    flex: 1,
    minWidth: 150,
    maxWidth: 200,
    aspectRatio: 1.1,
    borderRadius: 16,
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: colors.utility.borderLight,
    marginHorizontal: 4,
  },
  statsCardIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
  },
  statsCardValue: {
    fontSize: 28,
    fontWeight: '700',
    marginBottom: 4,
  },
  statsCardTitle: {
    fontSize: 13,
    fontWeight: '600',
    marginBottom: 2,
    textAlign: 'center',
  },
  statsCardSubtitle: {
    fontSize: 11,
    textAlign: 'center',
  },
  sectionTitle: {
    fontSize: 28,
    fontWeight: '700',
    marginBottom: 8,
  },
  sectionSubtitle: {
    fontSize: 16,
    marginBottom: 24,
    lineHeight: 24,
  },
  recentActivitySection: {
    paddingHorizontal: 16,
    marginBottom: 32,
  },
  recentVisitsContainer: {
    gap: 12,
  },
  recentVisitCard: {
    borderRadius: 16,
    overflow: 'hidden',
  },
  recentVisitGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
  },
  recentVisitIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    marginRight: 16,
  },
  recentVisitInfo: {
    flex: 1,
  },
  recentVisitDate: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.gray[800],
    marginBottom: 2,
  },
  recentVisitPark: {
    fontSize: 14,
    color: colors.gray[600],
  },
  emptyStateSection: {
    paddingHorizontal: 16,
    marginTop: 32,
  },
  emptyStateGradient: {
    borderRadius: 24,
    overflow: 'hidden',
  },
  emptyStateBlur: {
    padding: 40,
    alignItems: 'center',
  },
  emptyStateIcon: {
    marginBottom: 24,
  },
  emptyStateTitle: {
    fontSize: 24,
    fontWeight: '700',
    textAlign: 'center',
    marginBottom: 12,
  },
  emptyStateMessage: {
    fontSize: 16,
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 32,
  },
  emptyStateCTA: {
    borderRadius: 16,
    overflow: 'hidden',
  },
  emptyStateCTAGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 16,
    gap: 8,
  },
  emptyStateCTAText: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.utility.white,
  },
  
  // Magic Card Styles
  magicCard: {
    borderRadius: 16,
    overflow: 'hidden',
    elevation: 6,
    shadowColor: colors.effects.shadowMedium,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    marginBottom: 0,
  },
  magicCardGradient: {
    flex: 1,
  },
  magicCardBlur: {
    flex: 1,
    padding: 12,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.4)',
  },
  magicCardIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
  },
  magicCardValue: {
    fontSize: 22,
    fontWeight: '700',
    marginBottom: 3,
    textAlign: 'center',
    lineHeight: 26,
  },
  magicCardTitle: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: 2,
    textAlign: 'center',
    color: colors.text.primary,
    lineHeight: 14,
  },
  magicCardSubtitle: {
    fontSize: 10,
    textAlign: 'center',
    color: colors.text.secondary,
    lineHeight: 12,
  },
  
  // Fun Stats Styles
  funStatsSection: {
    paddingHorizontal: 16,
    marginBottom: 32,
  },
  funStatsGrid: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'stretch',
    gap: 12,
  },
  funStatCard: {
    flex: 1,
    minWidth: 120,
    maxWidth: 180,
    borderRadius: 16,
    overflow: 'hidden',
    marginHorizontal: 4,
  },
  funStatGradient: {
    padding: 20,
    alignItems: 'center',
    minHeight: 120,
    justifyContent: 'center',
  },
  funStatValue: {
    fontSize: 24,
    fontWeight: '700',
    marginTop: 8,
    marginBottom: 4,
  },
  funStatLabel: {
    fontSize: 12,
    fontWeight: '600',
    textAlign: 'center',
  },
});
</file>

<file path="src/screens/index.ts">
// Export all screens from a single point
export { HomeScreen } from './HomeScreen';
export { RecordScreen } from './RecordScreen';
export { AnalyticsScreen } from './AnalyticsScreen';
export { ProfileScreen } from './ProfileScreen';
export { VisitListScreen } from './VisitListScreen';
export { VisitDetailScreen } from './VisitDetailScreen';
</file>

<file path="src/screens/ProfileScreen.tsx">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Image,
  Switch,
  Dimensions,
  Animated,
  Platform,
  Alert,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
// import * as Haptics from 'expo-haptics'; // Uncomment when installed
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage, Language } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { Header } from '../components/Header';
import { SwipeableScreen } from '../components/SwipeableScreen';
import { DrawerMenu } from '../components/DrawerMenu';
import ThemeCustomizer from '../components/ThemeCustomizer';
import { ProfileEditModal } from '../components/ProfileEditModal';
import { HelpSupportModal } from '../components/HelpSupportModal';
import { AboutAppModal } from '../components/AboutAppModal';
import { TermsOfServiceModal } from '../components/TermsOfServiceModal';
import { profileService, UserProfile } from '../services/profileService';
import { useVisits } from '../hooks/useVisits';
import { useActions } from '../hooks/useActions';
import { ActionCategory } from '../types/models';

const { width } = Dimensions.get('window');

export const ProfileScreen = () => {
  const { theme, themeConfig, toggleTheme } = useTheme();
  const { t, language, setLanguage } = useLanguage();
  const isDark = theme.mode === 'dark';
  const [showThemeCustomizer, setShowThemeCustomizer] = useState(false);
  const [showProfileEdit, setShowProfileEdit] = useState(false);
  const [showHelpSupport, setShowHelpSupport] = useState(false);
  const [showAboutApp, setShowAboutApp] = useState(false);
  const [showTerms, setShowTerms] = useState(false);
  const [menuVisible, setMenuVisible] = useState(false);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  
  // Get actual data from hooks
  const { visits, deleteAllVisits } = useVisits();
  const { actions, deleteAllActions } = useActions();

  useEffect(() => {
    loadProfile();
  }, []);

  const loadProfile = async () => {
    try {
      const profile = await profileService.getProfile();
      setUserProfile(profile);
    } catch (error) {
      console.error('Error loading profile:', error);
    }
  };

  const handleProfileUpdate = (updatedProfile: UserProfile) => {
    setUserProfile(updatedProfile);
  };

  const handleLanguageToggle = () => {
    const newLanguage: Language = language === 'ja' ? 'en' : 'ja';
    setLanguage(newLanguage);
  };

  const handleDeleteAllVisits = () => {
    Alert.alert(
      language === 'ja' ? '来園記録を全削除' : 'Delete All Visit Records',
      language === 'ja' ? 'すべての来園記録とアクションが削除されます。この操作は取り消せません。本当に削除しますか？' : 'All visit records and actions will be deleted. This action cannot be undone. Are you sure you want to delete?',
      [
        {
          text: language === 'ja' ? 'キャンセル' : 'Cancel',
          style: 'cancel',
        },
        {
          text: language === 'ja' ? '削除' : 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteAllActions();
              await deleteAllVisits();
              Alert.alert(
                language === 'ja' ? '完了' : 'Complete', 
                language === 'ja' ? 'すべての来園記録が削除されました。' : 'All visit records have been deleted.'
              );
            } catch (error) {
              console.error('Error deleting all visits:', error);
              Alert.alert(
                language === 'ja' ? 'エラー' : 'Error', 
                language === 'ja' ? '削除に失敗しました。' : 'Failed to delete.'
              );
            }
          },
        },
      ]
    );
  };

  const menuItems = [
    { 
      icon: 'person', 
      label: language === 'ja' ? 'プロフィール編集' : 'Edit Profile', 
      section: 'account', 
      action: () => setShowProfileEdit(true) 
    },
    { 
      icon: 'language', 
      label: language === 'ja' ? '言語設定' : 'Language', 
      section: 'preferences', 
      value: language === 'ja' ? '日本語 → English' : 'English → 日本語',
      action: handleLanguageToggle 
    },
    { 
      icon: 'trash', 
      label: language === 'ja' ? '来園記録を全削除' : 'Delete All Visit Records', 
      section: 'data', 
      action: handleDeleteAllVisits, 
      isDestructive: true 
    },
    { 
      icon: 'help-circle', 
      label: language === 'ja' ? 'ヘルプ・サポート' : 'Help & Support', 
      section: 'other', 
      action: () => setShowHelpSupport(true) 
    },
    { 
      icon: 'information-circle', 
      label: language === 'ja' ? 'アプリについて' : 'About App', 
      section: 'other', 
      action: () => setShowAboutApp(true) 
    },
    { 
      icon: 'document-text', 
      label: language === 'ja' ? '利用規約' : 'Terms of Service', 
      section: 'other', 
      action: () => setShowTerms(true) 
    },
  ];

  const sections = [
    { 
      key: 'account', 
      title: language === 'ja' ? 'アカウント' : 'Account' 
    },
    { 
      key: 'preferences', 
      title: language === 'ja' ? '設定' : 'Preferences' 
    },
    { 
      key: 'data', 
      title: language === 'ja' ? 'データ管理' : 'Data Management' 
    },
    { 
      key: 'other', 
      title: language === 'ja' ? 'その他' : 'Other' 
    },
  ];

  return (
    <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
      <Header 
        title={t('nav.profile')} 
        onMenuOpen={() => setMenuVisible(true)}
      />
      <ScrollView
        style={[styles.container, { backgroundColor: theme.colors.background.primary }]}
        showsVerticalScrollIndicator={false}
      >
      {/* Clean Profile Header */}
      <View style={[
        styles.profileHeader,
        {
          backgroundColor: colors.background.primary,
        }
      ]}>
        <View style={[
          styles.profileContent,
          {
            backgroundColor: colors.background.card,
            borderRadius: 20,
            margin: 20,
            padding: 32,
            borderWidth: 1,
            borderColor: colors.utility.borderLight,
          }
        ]}>
          <View style={styles.avatarContainer}>
            <View style={[
              styles.avatarGradient,
              {
                backgroundColor: colors.purple.bright + '15',
                borderWidth: 2,
                borderColor: colors.purple.bright + '30',
              }
            ]}>
              {userProfile?.avatarUri ? (
                <Image source={{ uri: userProfile.avatarUri }} style={styles.avatarImage} />
              ) : (
                <Ionicons name="person" size={48} color={colors.purple.bright} />
              )}
            </View>
          </View>
          <Text style={[styles.profileName, { color: theme.colors.text.primary }]}>
            {userProfile?.name || t('profile.disneyExplorer')}
          </Text>
          <View style={styles.statsRow}>
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: colors.purple.bright }]}>
                {visits.length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.colors.text.secondary }]}>
                {language === 'ja' ? '来園数' : 'Visits'}
              </Text>
            </View>
            <View style={[
              styles.statDivider,
              { backgroundColor: colors.utility.borderLight }
            ]} />
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: colors.blue[500] }]}>
                {actions.filter(action => action.category === ActionCategory.ATTRACTION).length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.colors.text.secondary }]}>
                {language === 'ja' ? 'アトラクション' : 'Attractions'}
              </Text>
            </View>
            <View style={[
              styles.statDivider,
              { backgroundColor: colors.utility.borderLight }
            ]} />
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: colors.green[500] }]}>
                {actions.reduce((total, action) => total + action.photos.length, 0)}
              </Text>
              <Text style={[styles.statLabel, { color: theme.colors.text.secondary }]}>
                {language === 'ja' ? '写真数' : 'Photos'}
              </Text>
            </View>
          </View>
        </View>
      </View>

      {/* Menu Sections */}
      {sections.map((section) => (
        <View key={section.key} style={styles.section}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text.secondary }]}>
            {section.title}
          </Text>
          <View
            style={[
              styles.sectionContent,
              {
                backgroundColor: isDark
                  ? theme.colors.background.secondary
                  : theme.colors.background.elevated,
              },
            ]}
          >
            {menuItems
              .filter((item) => item.section === section.key)
              .map((item, index, arr) => (
                <TouchableOpacity
                  key={index}
                  style={[
                    styles.menuItem,
                    index === arr.length - 1 && styles.menuItemLast,
                  ]}
                  onPress={item.action}
                  activeOpacity={0.7}
                  // Add haptic feedback if available
                  onPressIn={() => {
                    // Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  }}
                >
                  <View style={styles.menuItemContent}>
                    <View
                      style={[
                        styles.menuIconContainer,
                        item.isDestructive && styles.menuIconDestructive,
                      ]}
                    >
                      <Ionicons
                        name={item.icon as any}
                        size={22}
                        color={
                          item.isDestructive
                            ? colors.semantic.error.main
                            : colors.purple[500]
                        }
                      />
                    </View>
                    <View style={styles.menuLabelContainer}>
                      <Text
                        style={[
                          styles.menuLabel,
                          { color: theme.colors.text.primary },
                          item.isDestructive && { color: colors.semantic.error.main },
                        ]}
                      >
                        {item.label}
                      </Text>
                      {item.badge && (
                        <View
                          style={[
                            styles.menuBadge,
                            {
                              backgroundColor: themeConfig.accentColor,
                              borderRadius: theme.borderRadius?.full || 9999,
                            },
                          ]}
                        >
                          <Text style={styles.menuBadgeText}>{item.badge}</Text>
                        </View>
                      )}
                    </View>
                  </View>
                  {item.hasSwitch ? (
                    <Switch
                      value={isDark}
                      onValueChange={toggleTheme}
                      trackColor={{
                        false: colors.utility.gridLight,
                        true: colors.purple[300],
                      }}
                      thumbColor={isDark ? colors.purple[500] : colors.utility.white}
                    />
                  ) : item.value ? (
                    <Text style={[styles.menuValue, { color: theme.colors.text.secondary }]}>
                      {item.value}
                    </Text>
                  ) : (
                    <Ionicons
                      name="chevron-forward"
                      size={20}
                      color={theme.colors.text.secondary}
                    />
                  )}
                </TouchableOpacity>
              ))}
          </View>
        </View>
      ))}

      {/* App Version */}
      <View style={styles.versionContainer}>
        <Text style={[styles.versionText, { color: theme.colors.text.secondary }]}>
          TDR Days v1.0.0
        </Text>
        <Text style={[styles.versionSubtext, { color: theme.colors.text.disabled }]}>
          © 2024 TDR Days Team
        </Text>
      </View>

      {/* Bottom spacing */}
      <View style={{ height: 100 }} />
      </ScrollView>

      
      {/* Profile Edit Modal */}
      <ProfileEditModal
        visible={showProfileEdit}
        onClose={() => setShowProfileEdit(false)}
        onUpdate={handleProfileUpdate}
        currentProfile={userProfile}
      />
      
      {/* Help Support Modal */}
      <HelpSupportModal
        visible={showHelpSupport}
        onClose={() => setShowHelpSupport(false)}
      />
      
      {/* About App Modal */}
      <AboutAppModal
        visible={showAboutApp}
        onClose={() => setShowAboutApp(false)}
      />
      
      {/* Terms of Service Modal */}
      <TermsOfServiceModal
        visible={showTerms}
        onClose={() => setShowTerms(false)}
      />
      
      <DrawerMenu
        visible={menuVisible}
        onClose={() => setMenuVisible(false)}
      />
    </SwipeableScreen>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  profileHeader: {
    paddingTop: 20,
    paddingBottom: 0,
    marginBottom: 24,
  },
  profileContent: {
    alignItems: 'center',
  },
  avatarContainer: {
    marginBottom: 16,
  },
  avatarGradient: {
    width: 96,
    height: 96,
    borderRadius: 48,
    justifyContent: 'center',
    alignItems: 'center',
    overflow: 'hidden',
  },
  avatarImage: {
    width: '100%',
    height: '100%',
  },
  profileName: {
    fontSize: 28,
    fontWeight: '700',
    marginBottom: 4,
    textAlign: 'center',
  },
  profileEmail: {
    fontSize: 16,
    marginBottom: 24,
    textAlign: 'center',
  },
  statsRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statItem: {
    alignItems: 'center',
    paddingHorizontal: 24,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 14,
  },
  statDivider: {
    width: 1,
    height: 32,
  },
  section: {
    paddingHorizontal: 20,
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    marginBottom: 12,
    marginLeft: 16,
  },
  sectionContent: {
    borderRadius: 16,
    overflow: 'hidden',
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingVertical: 18,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 0, 0, 0.05)',
    transition: 'background-color 0.2s ease',
  },
  menuItemLast: {
    borderBottomWidth: 0,
  },
  menuItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  menuIconContainer: {
    width: 36,
    height: 36,
    borderRadius: 8,
    backgroundColor: 'rgba(168, 85, 247, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  menuIconDestructive: {
    backgroundColor: 'rgba(239, 68, 68, 0.1)',
  },
  menuLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    gap: 8,
  },
  menuLabel: {
    fontSize: 16,
    fontWeight: '500',
  },
  menuBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    minWidth: 24,
    alignItems: 'center',
  },
  menuBadgeText: {
    color: 'white',
    fontSize: 10,
    fontWeight: '700',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  menuValue: {
    fontSize: 14,
    marginRight: 8,
  },
  versionContainer: {
    alignItems: 'center',
    paddingVertical: 32,
  },
  versionText: {
    fontSize: 14,
    marginBottom: 4,
  },
  versionSubtext: {
    fontSize: 12,
  },
});
</file>

<file path="src/screens/RecordScreen.tsx">
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  Alert,
  Animated,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useLanguage } from '../contexts/LanguageContext';
import { colors } from '../styles/colors';
import { Header } from '../components/Header';
import { SwipeableScreen } from '../components/SwipeableScreen';
import { DrawerMenu } from '../components/DrawerMenu';
// Removed unused imports - now using responsive utilities directly
import { CalendarPicker } from '../components/CalendarPicker';
import { ParkSelector } from '../components/ParkSelector';
import { CompanionManager } from '../components/CompanionManager';
import { ResponsiveContainer, ResponsiveSection } from '../components/layouts/ResponsiveContainer';
import { useVisits } from '../hooks/useVisits';
import { useResponsive } from '../hooks/useResponsive';
import { ParkType, CreateInput, Visit } from '../types/models';

type WeatherType = 'SUNNY' | 'CLOUDY' | 'RAINY' | 'SNOWY';

const getWeatherOptions = (t: any): Array<{
  type: WeatherType;
  label: string;
  icon: string;
  color: string;
}> => [
  { type: 'SUNNY', label: t('record.sunny'), icon: 'sunny', color: '#ffd60a' },
  { type: 'CLOUDY', label: t('record.cloudy'), icon: 'cloudy', color: '#8d99ae' },
  { type: 'RAINY', label: t('record.rainy'), icon: 'rainy', color: '#457b9d' },
  { type: 'SNOWY', label: t('record.snowy'), icon: 'snow', color: '#f1faee' },
];

interface RecordScreenParams {
  parkType?: ParkType;
  date?: string;
  visitId?: string;
}

export const RecordScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const params = route.params as RecordScreenParams;
  const { theme } = useTheme();
  const { t } = useLanguage();
  const isDark = theme.mode === 'dark';
  const { 
    dimensions, 
    breakpoint, 
    rSpacing, 
    rFontSize,
    isBreakpoint,
    layoutConfig 
  } = useResponsive();
  
  // Add safe fallback values
  const safeRSpacing = (value: number) => rSpacing ? rSpacing(value) : value;
  const safeRFontSize = (value: number) => rFontSize ? rFontSize(value) : value;
  
  // Responsive states
  const isTabletOrLarger = isBreakpoint('tablet');
  const isLaptopOrLarger = isBreakpoint('laptop');
  
  // Hooks
  const {
    companions,
    createVisit,
    updateVisit,
    getVisit,
    createCompanion,
    deleteCompanion,
    isLoading,
  } = useVisits();

  // Form state
  const [selectedDate, setSelectedDate] = useState<string>(() => {
    console.log('RecordScreen params:', params);
    return params?.date || '';
  });
  const [selectedPark, setSelectedPark] = useState<ParkType | undefined>(() => {
    console.log('RecordScreen parkType param:', params?.parkType);
    return params?.parkType;
  });
  const [selectedCompanionIds, setSelectedCompanionIds] = useState<string[]>([]);
  const [selectedWeather, setSelectedWeather] = useState<WeatherType | undefined>();
  const [notes, setNotes] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [menuVisible, setMenuVisible] = useState(false);

  // Handle params changes (in case user navigates to this screen multiple times with different params)
  useEffect(() => {
    if (params?.date && params.date !== selectedDate) {
      console.log('Updating selectedDate from params:', params.date);
      setSelectedDate(params.date);
    }
    if (params?.parkType && params.parkType !== selectedPark) {
      console.log('Updating selectedPark from params:', params.parkType);
      setSelectedPark(params.parkType);
    }
  }, [params]);
  const [editingVisit, setEditingVisit] = useState<Visit | null>(null);

  // Animation refs
  const saveButtonScale = useRef(new Animated.Value(1)).current;
  const formProgressAnim = useRef(new Animated.Value(0)).current;

  // Validation
  const isFormValid = selectedDate && selectedPark;
  const completionPercentage = [
    selectedDate,
    selectedPark,
    selectedCompanionIds.length > 0,
    selectedWeather,
    notes.trim(),
  ].filter(Boolean).length / 5;

  // Update progress animation
  React.useEffect(() => {
    Animated.timing(formProgressAnim, {
      toValue: completionPercentage,
      duration: 300,
      useNativeDriver: false,
    }).start();
  }, [completionPercentage]);

  const handleCompanionToggle = (companionId: string) => {
    setSelectedCompanionIds(prev => 
      prev.includes(companionId)
        ? prev.filter(id => id !== companionId)
        : [...prev, companionId]
    );
  };

  const handleCompanionCreate = async (name: string) => {
    try {
      const newCompanion = await createCompanion({ name });
      setSelectedCompanionIds(prev => [...prev, newCompanion.id]);
    } catch (error) {
      throw error;
    }
  };

  const handleCompanionDelete = async (companionId: string) => {
    try {
      await deleteCompanion(companionId);
      setSelectedCompanionIds(prev => prev.filter(id => id !== companionId));
    } catch (error) {
      throw error;
    }
  };

  const handleWeatherSelect = (weather: WeatherType) => {
    setSelectedWeather(prev => prev === weather ? undefined : weather);
  };

  // Load visit data for editing
  useEffect(() => {
    const loadEditingVisit = async () => {
      if (params?.visitId) {
        try {
          const visit = await getVisit(params.visitId);
          if (visit) {
            setEditingVisit(visit);
            setSelectedDate(new Date(visit.date).toISOString().split('T')[0]);
            setSelectedPark(visit.parkType);
            setSelectedCompanionIds(visit.companionIds);
            setSelectedWeather(visit.weather);
            setNotes(visit.notes || '');
          }
        } catch (error) {
          Alert.alert(
            t('record.error'), 
            t('record.errorMessage')
          );
          navigation.goBack();
        }
      }
    };

    loadEditingVisit();
  }, [params?.visitId]);

  const handleSave = async () => {
    if (!isFormValid) {
      Alert.alert(t('record.incompleteForm'), t('record.selectDateAndPark'));
      return;
    }

    // Animate save button
    Animated.sequence([
      Animated.timing(saveButtonScale, {
        toValue: 0.95,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.spring(saveButtonScale, {
        toValue: 1,
        useNativeDriver: true,
        tension: 300,
        friction: 10,
      }),
    ]).start();

    setIsSaving(true);
    try {
      const visitData = {
        date: new Date(selectedDate),
        parkType: selectedPark!,
        companionIds: selectedCompanionIds,
        weather: selectedWeather,
        notes: notes.trim() || undefined,
      };

      let resultVisit: Visit;
      
      if (editingVisit) {
        // Update existing visit
        resultVisit = await updateVisit(editingVisit.id, visitData);
      } else {
        // Create new visit
        resultVisit = await createVisit(visitData as CreateInput<Visit>);
      }
      
      // Reset form only for new visits
      if (!editingVisit) {
        setSelectedDate('');
        setSelectedPark(undefined);
        setSelectedCompanionIds([]);
        setSelectedWeather(undefined);
        setNotes('');
      }

      // Navigate to the visit detail page
      navigation.navigate('VisitDetail' as never, { visitId: resultVisit.id } as never);
    } catch (error) {
      Alert.alert(t('record.error'), t('record.errorMessage'));
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <SwipeableScreen onSwipeFromLeft={() => setMenuVisible(true)}>
      <KeyboardAvoidingView
        style={{ flex: 1 }}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <Header 
          title={editingVisit ? t('record.editVisit') : t('nav.record')} 
          showBackButton={editingVisit ? true : false}
          onBackPress={editingVisit ? () => navigation.goBack() : undefined}
          onMenuOpen={() => setMenuVisible(true)}
        />
        <ScrollView
        style={[styles.container, { backgroundColor: theme.colors.background.primary }]}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        {/* Clean Header Section */}
        <View style={[
          styles.header,
          {
            backgroundColor: colors.background.primary,
            paddingHorizontal: safeRSpacing(20),
            marginBottom: safeRSpacing(24),
          }
        ]}>
          <View style={[
            styles.headerContent,
            {
              backgroundColor: colors.background.card,
              borderRadius: safeRSpacing(20),
              padding: safeRSpacing(24),
              borderWidth: 1,
              borderColor: colors.utility.borderLight,
            }
          ]}>
            <Text style={[
              styles.headerTitle, 
              { 
                color: theme.colors.text.primary,
                fontSize: safeRFontSize(28),
                marginBottom: safeRSpacing(8),
              }
            ]}>
              {t('record.title')}
            </Text>
            <Text style={[
              styles.headerSubtitle, 
              { 
                color: theme.colors.text.secondary,
                fontSize: safeRFontSize(16),
                marginBottom: safeRSpacing(20),
              }
            ]}>
              {t('record.subtitle')}
            </Text>
            
            {/* Progress Bar */}
            <View style={[
              styles.progressContainer,
              {
                gap: safeRSpacing(12),
              }
            ]}>
              <View style={[
                styles.progressTrack,
                {
                  backgroundColor: colors.background.tertiary,
                  borderRadius: safeRSpacing(8),
                }
              ]}>
                <Animated.View
                  style={[
                    styles.progressFill,
                    {
                      backgroundColor: colors.purple.bright,
                      borderRadius: safeRSpacing(8),
                      width: formProgressAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: ['0%', '100%'],
                      }),
                    },
                  ]}
                />
              </View>
              <Text style={[
                styles.progressText, 
                { 
                  color: theme.colors.text.secondary,
                  fontSize: safeRFontSize(14),
                }
              ]}>
                {Math.round(completionPercentage * 100)}{t('record.complete')}
              </Text>
            </View>
          </View>
        </View>

        <View style={[
          styles.formContainer,
          {
            paddingHorizontal: safeRSpacing(20),
          }
        ]}>
          {/* Calendar Picker */}
          <View style={[styles.section, { marginBottom: safeRSpacing(24) }]}>
            <CalendarPicker
              selectedDate={selectedDate}
              onDateSelect={setSelectedDate}
              minDate={new Date(2020, 0, 1).toISOString().split('T')[0]}
              maxDate={(() => {
                const now = new Date();
                const jstOffset = 9 * 60; // JST is UTC+9
                const jstTime = new Date(now.getTime() + (jstOffset * 60 * 1000));
                return jstTime.toISOString().split('T')[0];
              })()}
            />
          </View>

          {/* Park Selector */}
          <View style={[styles.section, { marginBottom: safeRSpacing(24) }]}>
            <ParkSelector
              selectedPark={selectedPark}
              onParkSelect={setSelectedPark}
            />
          </View>

          {/* Companion Manager */}
          <View style={[styles.section, { marginBottom: safeRSpacing(24) }]}>
            <CompanionManager
              companions={companions}
              selectedCompanionIds={selectedCompanionIds}
              onCompanionToggle={handleCompanionToggle}
              onCompanionCreate={handleCompanionCreate}
              onCompanionDelete={handleCompanionDelete}
              isCreating={isLoading}
            />
          </View>

          {/* Weather Selection */}
          <View style={[styles.section, { marginBottom: safeRSpacing(24) }]}>
            <Text style={[
              styles.sectionTitle, 
              { 
                color: theme.colors.text.primary,
                fontSize: safeRFontSize(20),
                marginBottom: safeRSpacing(16),
              }
            ]}>
              {t('record.weather')}
            </Text>
            <View style={[
              styles.weatherContainer,
              {
                gap: safeRSpacing(12),
                flexDirection: isTabletOrLarger ? 'row' : 'row',
              }
            ]}>
              {getWeatherOptions(t).map((weather) => {
                const isSelected = selectedWeather === weather.type;
                return (
                  <TouchableOpacity
                    key={weather.type}
                    onPress={() => handleWeatherSelect(weather.type)}
                    style={[
                      styles.weatherButton,
                      {
                        backgroundColor: isSelected
                          ? `${weather.color}20`
                          : isDark
                          ? theme.colors.background.secondary
                          : theme.colors.background.elevated,
                        borderColor: isSelected ? weather.color : 'transparent',
                        borderRadius: safeRSpacing(12),
                      },
                    ]}
                  >
                    <LinearGradient
                      colors={
                        isSelected
                          ? [`${weather.color}30`, `${weather.color}10`]
                          : ['transparent', 'transparent']
                      }
                      style={[
                        styles.weatherGradient,
                        {
                          padding: safeRSpacing(12),
                          gap: safeRSpacing(8),
                        }
                      ]}
                    >
                      <Ionicons
                        name={weather.icon as any}
                        size={24}
                        color={isSelected ? weather.color : theme.colors.text.secondary}
                      />
                      <Text
                        style={[
                          styles.weatherLabel,
                          {
                            color: isSelected
                              ? weather.color
                              : theme.colors.text.secondary,
                            fontWeight: isSelected ? '600' : '500',
                            fontSize: safeRFontSize(14),
                          },
                        ]}
                      >
                        {weather.label}
                      </Text>
                    </LinearGradient>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          {/* Notes Section */}
          <View style={[styles.section, { marginBottom: safeRSpacing(24) }]}>
            <Text style={[
              styles.sectionTitle, 
              { 
                color: theme.colors.text.primary,
                fontSize: safeRFontSize(20),
                marginBottom: safeRSpacing(16),
              }
            ]}>
              {t('record.notes')}
            </Text>
            <View
              style={[
                styles.notesContainer,
                {
                  backgroundColor: isDark
                    ? theme.colors.background.secondary
                    : theme.colors.background.elevated,
                  borderRadius: safeRSpacing(12),
                },
              ]}
            >
              <LinearGradient
                colors={
                  notes.trim()
                    ? ['rgba(147, 51, 234, 0.1)', 'rgba(168, 85, 247, 0.05)']
                    : ['transparent', 'transparent']
                }
                style={[
                  styles.notesGradient,
                  {
                    padding: safeRSpacing(16),
                  }
                ]}
              >
                <TextInput
                  style={[
                    styles.notesInput, 
                    { 
                      color: theme.colors.text.primary,
                      fontSize: safeRFontSize(16),
                      marginBottom: safeRSpacing(8),
                    }
                  ]}
                  placeholder={t('record.notesPlaceholder')}
                  placeholderTextColor={theme.colors.text.secondary}
                  value={notes}
                  onChangeText={setNotes}
                  multiline
                  numberOfLines={4}
                  textAlignVertical="top"
                  maxLength={500}
                />
                <View style={styles.notesFooter}>
                  <Text style={[
                    styles.characterCount, 
                    { 
                      color: theme.colors.text.secondary,
                      fontSize: safeRFontSize(12),
                    }
                  ]}>
                    {notes.length}/500
                  </Text>
                </View>
              </LinearGradient>
            </View>
          </View>

          {/* Save Button */}
          <Animated.View
            style={[
              styles.saveButtonContainer,
              { 
                transform: [{ scale: saveButtonScale }],
                marginTop: safeRSpacing(16),
                marginBottom: safeRSpacing(24),
              },
            ]}
          >
            <TouchableOpacity
              onPress={handleSave}
              disabled={!isFormValid || isSaving}
              style={[
                styles.saveButton,
                { 
                  opacity: !isFormValid || isSaving ? 0.5 : 1,
                  borderRadius: safeRSpacing(12),
                },
              ]}
            >
              <LinearGradient
                colors={['#a855f7', '#9333ea', '#7e22ce']}
                style={[
                  styles.saveGradient,
                  {
                    padding: safeRSpacing(20),
                  }
                ]}
              >
                <View style={[
                  styles.saveButtonContent,
                  {
                    gap: safeRSpacing(12),
                  }
                ]}>
                  {isSaving ? (
                    <>
                      <Animated.View style={styles.loadingSpinner}>
                        <Ionicons name="refresh" size={24} color={colors.text.dark.primary} />
                      </Animated.View>
                      <Text style={[
                        styles.saveText,
                        {
                          fontSize: safeRFontSize(18),
                        }
                      ]}>{t('record.savingVisit')}</Text>
                    </>
                  ) : (
                    <>
                      <Ionicons name="checkmark-circle" size={24} color={colors.text.dark.primary} />
                      <Text style={[
                        styles.saveText,
                        {
                          fontSize: safeRFontSize(18),
                        }
                      ]}>{t('record.saveVisit')}</Text>
                    </>
                  )}
                </View>
              </LinearGradient>
            </TouchableOpacity>
          </Animated.View>

          {/* Bottom spacing */}
          <View style={{ height: 100 }} />
        </View>
      </ScrollView>
      </KeyboardAvoidingView>
      
      <DrawerMenu
        visible={menuVisible}
        onClose={() => setMenuVisible(false)}
      />
    </SwipeableScreen>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    paddingTop: Platform.OS === 'ios' ? 60 : 40,
    paddingBottom: 0,
  },
  headerContent: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontWeight: '700',
    textAlign: 'center',
  },
  headerSubtitle: {
    textAlign: 'center',
    lineHeight: 24,
  },
  progressContainer: {
    width: '100%',
    alignItems: 'center',
  },
  progressTrack: {
    width: '100%',
    height: 8,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
  },
  progressText: {
    fontWeight: '600',
  },
  formContainer: {},
  section: {},
  sectionTitle: {
    fontWeight: '600',
  },
  weatherContainer: {
    flexDirection: 'row',
  },
  weatherButton: {
    flex: 1,
    borderWidth: 2,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  weatherGradient: {
    alignItems: 'center',
  },
  weatherLabel: {
    textAlign: 'center',
  },
  notesContainer: {
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  notesGradient: {},
  notesInput: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  notesFooter: {
    alignItems: 'flex-end',
  },
  characterCount: {},
  saveButtonContainer: {},
  saveButton: {
    overflow: 'hidden',
    shadowColor: '#a855f7',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.5,
    shadowRadius: 16,
    elevation: 8,
  },
  saveGradient: {
    alignItems: 'center',
  },
  saveButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  saveText: {
    fontWeight: '700',
    color: colors.text.dark.primary,
  },
  loadingSpinner: {
    // Add rotation animation here if needed
  },
});
</file>

</files>
